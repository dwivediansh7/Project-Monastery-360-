"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@genkit-ai";
exports.ids = ["vendor-chunks/@genkit-ai"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@genkit-ai/googleai/node_modules/@google/generative-ai/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@genkit-ai/googleai/node_modules/@google/generative-ai/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n * Contains the list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n * @public\n */\nexports.FunctionDeclarationSchemaType = void 0;\n(function (FunctionDeclarationSchemaType) {\n    /** String type. */\n    FunctionDeclarationSchemaType[\"STRING\"] = \"STRING\";\n    /** Number type. */\n    FunctionDeclarationSchemaType[\"NUMBER\"] = \"NUMBER\";\n    /** Integer type. */\n    FunctionDeclarationSchemaType[\"INTEGER\"] = \"INTEGER\";\n    /** Boolean type. */\n    FunctionDeclarationSchemaType[\"BOOLEAN\"] = \"BOOLEAN\";\n    /** Array type. */\n    FunctionDeclarationSchemaType[\"ARRAY\"] = \"ARRAY\";\n    /** Object type. */\n    FunctionDeclarationSchemaType[\"OBJECT\"] = \"OBJECT\";\n})(exports.FunctionDeclarationSchemaType || (exports.FunctionDeclarationSchemaType = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @public\n */\nexports.ExecutableCodeLanguage = void 0;\n(function (ExecutableCodeLanguage) {\n    ExecutableCodeLanguage[\"LANGUAGE_UNSPECIFIED\"] = \"language_unspecified\";\n    ExecutableCodeLanguage[\"PYTHON\"] = \"python\";\n})(exports.ExecutableCodeLanguage || (exports.ExecutableCodeLanguage = {}));\n/**\n * Possible outcomes of code execution.\n * @public\n */\nexports.Outcome = void 0;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"outcome_unspecified\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"outcome_ok\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the\n     * reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"outcome_failed\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not\n     * be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"outcome_deadline_exceeded\";\n})(exports.Outcome || (exports.Outcome = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Possible roles.\n * @public\n */\nconst POSSIBLE_ROLES = [\"user\", \"model\", \"function\", \"system\"];\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nexports.HarmCategory = void 0;\n(function (HarmCategory) {\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n})(exports.HarmCategory || (exports.HarmCategory = {}));\n/**\n * Threshold above which a prompt or candidate will be blocked.\n * @public\n */\nexports.HarmBlockThreshold = void 0;\n(function (HarmBlockThreshold) {\n    // Threshold is unspecified.\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    // Content with NEGLIGIBLE will be allowed.\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    // Content with NEGLIGIBLE and LOW will be allowed.\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    // Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    // All content will be allowed.\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nexports.HarmProbability = void 0;\n(function (HarmProbability) {\n    // Probability is unspecified.\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    // Content has a negligible chance of being unsafe.\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    // Content has a low chance of being unsafe.\n    HarmProbability[\"LOW\"] = \"LOW\";\n    // Content has a medium chance of being unsafe.\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    // Content has a high chance of being unsafe.\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(exports.HarmProbability || (exports.HarmProbability = {}));\n/**\n * Reason that a prompt was blocked.\n * @public\n */\nexports.BlockReason = void 0;\n(function (BlockReason) {\n    // A blocked reason was not specified.\n    BlockReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    // Content was blocked by safety settings.\n    BlockReason[\"SAFETY\"] = \"SAFETY\";\n    // Content was blocked, but the reason is uncategorized.\n    BlockReason[\"OTHER\"] = \"OTHER\";\n})(exports.BlockReason || (exports.BlockReason = {}));\n/**\n * Reason that a candidate finished.\n * @public\n */\nexports.FinishReason = void 0;\n(function (FinishReason) {\n    // Default value. This value is unused.\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    // Natural stop point of the model or provided stop sequence.\n    FinishReason[\"STOP\"] = \"STOP\";\n    // The maximum number of tokens as specified in the request was reached.\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    // The candidate content was flagged for safety reasons.\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    // The candidate content was flagged for recitation reasons.\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    // The candidate content was flagged for using an unsupported language.\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    // Unknown reason.\n    FinishReason[\"OTHER\"] = \"OTHER\";\n})(exports.FinishReason || (exports.FinishReason = {}));\n/**\n * Task type for embedding content.\n * @public\n */\nexports.TaskType = void 0;\n(function (TaskType) {\n    TaskType[\"TASK_TYPE_UNSPECIFIED\"] = \"TASK_TYPE_UNSPECIFIED\";\n    TaskType[\"RETRIEVAL_QUERY\"] = \"RETRIEVAL_QUERY\";\n    TaskType[\"RETRIEVAL_DOCUMENT\"] = \"RETRIEVAL_DOCUMENT\";\n    TaskType[\"SEMANTIC_SIMILARITY\"] = \"SEMANTIC_SIMILARITY\";\n    TaskType[\"CLASSIFICATION\"] = \"CLASSIFICATION\";\n    TaskType[\"CLUSTERING\"] = \"CLUSTERING\";\n})(exports.TaskType || (exports.TaskType = {}));\n/**\n * @public\n */\nexports.FunctionCallingMode = void 0;\n(function (FunctionCallingMode) {\n    // Unspecified function calling mode. This value should not be used.\n    FunctionCallingMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Default model behavior, model decides to predict either a function call\n    // or a natural language repspose.\n    FunctionCallingMode[\"AUTO\"] = \"AUTO\";\n    // Model is constrained to always predicting a function call only.\n    // If \"allowed_function_names\" are set, the predicted function call will be\n    // limited to any one of \"allowed_function_names\", else the predicted\n    // function call will be any one of the provided \"function_declarations\".\n    FunctionCallingMode[\"ANY\"] = \"ANY\";\n    // Model will not predict any function call. Model behavior is same as when\n    // not passing any function declarations.\n    FunctionCallingMode[\"NONE\"] = \"NONE\";\n})(exports.FunctionCallingMode || (exports.FunctionCallingMode = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Basic error type for this SDK.\n * @public\n */\nclass GoogleGenerativeAIError extends Error {\n    constructor(message) {\n        super(`[GoogleGenerativeAI Error]: ${message}`);\n    }\n}\n/**\n * Errors in the contents of a response from the model. This includes parsing\n * errors, or responses including a safety block reason.\n * @public\n */\nclass GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\n/**\n * Error class covering HTTP errors when calling the server. Includes HTTP\n * status, statusText, and optional details, if provided in the server response.\n * @public\n */\nclass GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {\n    constructor(message, status, statusText, errorDetails) {\n        super(message);\n        this.status = status;\n        this.statusText = statusText;\n        this.errorDetails = errorDetails;\n    }\n}\n/**\n * Errors in the contents of a request originating from user input.\n * @public\n */\nclass GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\nconst DEFAULT_API_VERSION = \"v1beta\";\n/**\n * We can't `require` package.json if this runs on web. We will use rollup to\n * swap in the version number here at build time.\n */\nconst PACKAGE_VERSION = \"0.16.1\";\nconst PACKAGE_LOG_HEADER = \"genai-js\";\nvar Task;\n(function (Task) {\n    Task[\"GENERATE_CONTENT\"] = \"generateContent\";\n    Task[\"STREAM_GENERATE_CONTENT\"] = \"streamGenerateContent\";\n    Task[\"COUNT_TOKENS\"] = \"countTokens\";\n    Task[\"EMBED_CONTENT\"] = \"embedContent\";\n    Task[\"BATCH_EMBED_CONTENTS\"] = \"batchEmbedContents\";\n})(Task || (Task = {}));\nclass RequestUrl {\n    constructor(model, task, apiKey, stream, requestOptions) {\n        this.model = model;\n        this.task = task;\n        this.apiKey = apiKey;\n        this.stream = stream;\n        this.requestOptions = requestOptions;\n    }\n    toString() {\n        var _a, _b;\n        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;\n        if (this.stream) {\n            url += \"?alt=sse\";\n        }\n        return url;\n    }\n}\n/**\n * Simple, but may become more complex if we add more versions to log.\n */\nfunction getClientHeaders(requestOptions) {\n    const clientHeaders = [];\n    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {\n        clientHeaders.push(requestOptions.apiClient);\n    }\n    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);\n    return clientHeaders.join(\" \");\n}\nasync function getHeaders(url) {\n    var _a;\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    headers.append(\"x-goog-api-client\", getClientHeaders(url.requestOptions));\n    headers.append(\"x-goog-api-key\", url.apiKey);\n    let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;\n    if (customHeaders) {\n        if (!(customHeaders instanceof Headers)) {\n            try {\n                customHeaders = new Headers(customHeaders);\n            }\n            catch (e) {\n                throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);\n            }\n        }\n        for (const [headerName, headerValue] of customHeaders.entries()) {\n            if (headerName === \"x-goog-api-key\") {\n                throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);\n            }\n            else if (headerName === \"x-goog-api-client\") {\n                throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);\n            }\n            headers.append(headerName, headerValue);\n        }\n    }\n    return headers;\n}\nasync function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {\n    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);\n    return {\n        url: url.toString(),\n        fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: \"POST\", headers: await getHeaders(url), body }),\n    };\n}\nasync function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, \n// Allows this to be stubbed for tests\nfetchFn = fetch) {\n    const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);\n    return makeRequest(url, fetchOptions, fetchFn);\n}\nasync function makeRequest(url, fetchOptions, fetchFn = fetch) {\n    let response;\n    try {\n        response = await fetchFn(url, fetchOptions);\n    }\n    catch (e) {\n        handleResponseError(e, url);\n    }\n    if (!response.ok) {\n        await handleResponseNotOk(response, url);\n    }\n    return response;\n}\nfunction handleResponseError(e, url) {\n    let err = e;\n    if (!(e instanceof GoogleGenerativeAIFetchError ||\n        e instanceof GoogleGenerativeAIRequestInputError)) {\n        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    throw err;\n}\nasync function handleResponseNotOk(response, url) {\n    let message = \"\";\n    let errorDetails;\n    try {\n        const json = await response.json();\n        message = json.error.message;\n        if (json.error.details) {\n            message += ` ${JSON.stringify(json.error.details)}`;\n            errorDetails = json.error.details;\n        }\n    }\n    catch (e) {\n        // ignored\n    }\n    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);\n}\n/**\n * Generates the request options to be passed to the fetch API.\n * @param requestOptions - The user-defined request options.\n * @returns The generated request options.\n */\nfunction buildFetchOptions(requestOptions) {\n    const fetchOptions = {};\n    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n        const controller = new AbortController();\n        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n            setTimeout(() => controller.abort(), requestOptions.timeout);\n        }\n        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {\n            requestOptions.signal.addEventListener(\"abort\", () => {\n                controller.abort();\n            });\n        }\n        fetchOptions.signal = controller.signal;\n    }\n    return fetchOptions;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Adds convenience helper methods to a response object, including stream\n * chunks (as long as each chunk is a complete GenerateContentResponse JSON).\n */\nfunction addHelpers(response) {\n    response.text = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning text from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getText(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return \"\";\n    };\n    /**\n     * TODO: remove at next major version\n     */\n    response.functionCall = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            console.warn(`response.functionCall() is deprecated. ` +\n                `Use response.functionCalls() instead.`);\n            return getFunctionCalls(response)[0];\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    response.functionCalls = () => {\n        if (response.candidates && response.candidates.length > 0) {\n            if (response.candidates.length > 1) {\n                console.warn(`This response had ${response.candidates.length} ` +\n                    `candidates. Returning function calls from the first candidate only. ` +\n                    `Access response.candidates directly to use the other candidates.`);\n            }\n            if (hadBadFinishReason(response.candidates[0])) {\n                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);\n            }\n            return getFunctionCalls(response);\n        }\n        else if (response.promptFeedback) {\n            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);\n        }\n        return undefined;\n    };\n    return response;\n}\n/**\n * Returns all text found in all parts of first candidate.\n */\nfunction getText(response) {\n    var _a, _b, _c, _d;\n    const textStrings = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.text) {\n                textStrings.push(part.text);\n            }\n            if (part.executableCode) {\n                textStrings.push(\"\\n```python\\n\" + part.executableCode.code + \"\\n```\\n\");\n            }\n            if (part.codeExecutionResult) {\n                textStrings.push(\"\\n```\\n\" + part.codeExecutionResult.output + \"\\n```\\n\");\n            }\n        }\n    }\n    if (textStrings.length > 0) {\n        return textStrings.join(\"\");\n    }\n    else {\n        return \"\";\n    }\n}\n/**\n * Returns functionCall of first candidate.\n */\nfunction getFunctionCalls(response) {\n    var _a, _b, _c, _d;\n    const functionCalls = [];\n    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {\n        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {\n            if (part.functionCall) {\n                functionCalls.push(part.functionCall);\n            }\n        }\n    }\n    if (functionCalls.length > 0) {\n        return functionCalls;\n    }\n    else {\n        return undefined;\n    }\n}\nconst badFinishReasons = [\n    exports.FinishReason.RECITATION,\n    exports.FinishReason.SAFETY,\n    exports.FinishReason.LANGUAGE,\n];\nfunction hadBadFinishReason(candidate) {\n    return (!!candidate.finishReason &&\n        badFinishReasons.includes(candidate.finishReason));\n}\nfunction formatBlockErrorMessage(response) {\n    var _a, _b, _c;\n    let message = \"\";\n    if ((!response.candidates || response.candidates.length === 0) &&\n        response.promptFeedback) {\n        message += \"Response was blocked\";\n        if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {\n            message += ` due to ${response.promptFeedback.blockReason}`;\n        }\n        if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {\n            message += `: ${response.promptFeedback.blockReasonMessage}`;\n        }\n    }\n    else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {\n        const firstCandidate = response.candidates[0];\n        if (hadBadFinishReason(firstCandidate)) {\n            message += `Candidate was blocked due to ${firstCandidate.finishReason}`;\n            if (firstCandidate.finishMessage) {\n                message += `: ${firstCandidate.finishMessage}`;\n            }\n        }\n    }\n    return message;\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst responseLineRE = /^data\\: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * Process a response.body stream from the backend and return an\n * iterator that provides one complete GenerateContentResponse at a time\n * and a promise that resolves with a single aggregated\n * GenerateContentResponse.\n *\n * @param response - Response from a fetch call\n */\nfunction processStream(response) {\n    const inputStream = response.body.pipeThrough(new TextDecoderStream(\"utf8\", { fatal: true }));\n    const responseStream = getResponseStream(inputStream);\n    const [stream1, stream2] = responseStream.tee();\n    return {\n        stream: generateResponseSequence(stream1),\n        response: getResponsePromise(stream2),\n    };\n}\nasync function getResponsePromise(stream) {\n    const allResponses = [];\n    const reader = stream.getReader();\n    while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n            return addHelpers(aggregateResponses(allResponses));\n        }\n        allResponses.push(value);\n    }\n}\nfunction generateResponseSequence(stream) {\n    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {\n        const reader = stream.getReader();\n        while (true) {\n            const { value, done } = yield __await(reader.read());\n            if (done) {\n                break;\n            }\n            yield yield __await(addHelpers(value));\n        }\n    });\n}\n/**\n * Reads a raw stream from the fetch response and join incomplete\n * chunks, returning a new stream that provides a single complete\n * GenerateContentResponse in each iteration.\n */\nfunction getResponseStream(inputStream) {\n    const reader = inputStream.getReader();\n    const stream = new ReadableStream({\n        start(controller) {\n            let currentText = \"\";\n            return pump();\n            function pump() {\n                return reader.read().then(({ value, done }) => {\n                    if (done) {\n                        if (currentText.trim()) {\n                            controller.error(new GoogleGenerativeAIError(\"Failed to parse stream\"));\n                            return;\n                        }\n                        controller.close();\n                        return;\n                    }\n                    currentText += value;\n                    let match = currentText.match(responseLineRE);\n                    let parsedResponse;\n                    while (match) {\n                        try {\n                            parsedResponse = JSON.parse(match[1]);\n                        }\n                        catch (e) {\n                            controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: \"${match[1]}\"`));\n                            return;\n                        }\n                        controller.enqueue(parsedResponse);\n                        currentText = currentText.substring(match[0].length);\n                        match = currentText.match(responseLineRE);\n                    }\n                    return pump();\n                });\n            }\n        },\n    });\n    return stream;\n}\n/**\n * Aggregates an array of `GenerateContentResponse`s into a single\n * GenerateContentResponse.\n */\nfunction aggregateResponses(responses) {\n    const lastResponse = responses[responses.length - 1];\n    const aggregatedResponse = {\n        promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback,\n    };\n    for (const response of responses) {\n        if (response.candidates) {\n            for (const candidate of response.candidates) {\n                const i = candidate.index;\n                if (!aggregatedResponse.candidates) {\n                    aggregatedResponse.candidates = [];\n                }\n                if (!aggregatedResponse.candidates[i]) {\n                    aggregatedResponse.candidates[i] = {\n                        index: candidate.index,\n                    };\n                }\n                // Keep overwriting, the last one will be final\n                aggregatedResponse.candidates[i].citationMetadata =\n                    candidate.citationMetadata;\n                aggregatedResponse.candidates[i].finishReason = candidate.finishReason;\n                aggregatedResponse.candidates[i].finishMessage =\n                    candidate.finishMessage;\n                aggregatedResponse.candidates[i].safetyRatings =\n                    candidate.safetyRatings;\n                /**\n                 * Candidates should always have content and parts, but this handles\n                 * possible malformed responses.\n                 */\n                if (candidate.content && candidate.content.parts) {\n                    if (!aggregatedResponse.candidates[i].content) {\n                        aggregatedResponse.candidates[i].content = {\n                            role: candidate.content.role || \"user\",\n                            parts: [],\n                        };\n                    }\n                    const newPart = {};\n                    for (const part of candidate.content.parts) {\n                        if (part.text) {\n                            newPart.text = part.text;\n                        }\n                        if (part.functionCall) {\n                            newPart.functionCall = part.functionCall;\n                        }\n                        if (part.executableCode) {\n                            newPart.executableCode = part.executableCode;\n                        }\n                        if (part.codeExecutionResult) {\n                            newPart.codeExecutionResult = part.codeExecutionResult;\n                        }\n                        if (Object.keys(newPart).length === 0) {\n                            newPart.text = \"\";\n                        }\n                        aggregatedResponse.candidates[i].content.parts.push(newPart);\n                    }\n                }\n            }\n        }\n        if (response.usageMetadata) {\n            aggregatedResponse.usageMetadata = response.usageMetadata;\n        }\n    }\n    return aggregatedResponse;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function generateContentStream(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, \n    /* stream */ true, JSON.stringify(params), requestOptions);\n    return processStream(response);\n}\nasync function generateContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, \n    /* stream */ false, JSON.stringify(params), requestOptions);\n    const responseJson = await response.json();\n    const enhancedResponse = addHelpers(responseJson);\n    return {\n        response: enhancedResponse,\n    };\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction formatSystemInstruction(input) {\n    // null or undefined\n    if (input == null) {\n        return undefined;\n    }\n    else if (typeof input === \"string\") {\n        return { role: \"system\", parts: [{ text: input }] };\n    }\n    else if (input.text) {\n        return { role: \"system\", parts: [input] };\n    }\n    else if (input.parts) {\n        if (!input.role) {\n            return { role: \"system\", parts: input.parts };\n        }\n        else {\n            return input;\n        }\n    }\n}\nfunction formatNewContent(request) {\n    let newParts = [];\n    if (typeof request === \"string\") {\n        newParts = [{ text: request }];\n    }\n    else {\n        for (const partOrString of request) {\n            if (typeof partOrString === \"string\") {\n                newParts.push({ text: partOrString });\n            }\n            else {\n                newParts.push(partOrString);\n            }\n        }\n    }\n    return assignRoleToPartsAndValidateSendMessageRequest(newParts);\n}\n/**\n * When multiple Part types (i.e. FunctionResponsePart and TextPart) are\n * passed in a single Part array, we may need to assign different roles to each\n * part. Currently only FunctionResponsePart requires a role other than 'user'.\n * @private\n * @param parts Array of parts to pass to the model\n * @returns Array of content items\n */\nfunction assignRoleToPartsAndValidateSendMessageRequest(parts) {\n    const userContent = { role: \"user\", parts: [] };\n    const functionContent = { role: \"function\", parts: [] };\n    let hasUserContent = false;\n    let hasFunctionContent = false;\n    for (const part of parts) {\n        if (\"functionResponse\" in part) {\n            functionContent.parts.push(part);\n            hasFunctionContent = true;\n        }\n        else {\n            userContent.parts.push(part);\n            hasUserContent = true;\n        }\n    }\n    if (hasUserContent && hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.\");\n    }\n    if (!hasUserContent && !hasFunctionContent) {\n        throw new GoogleGenerativeAIError(\"No content is provided for sending chat message.\");\n    }\n    if (hasUserContent) {\n        return userContent;\n    }\n    return functionContent;\n}\nfunction formatCountTokensInput(params, modelParams) {\n    var _a;\n    let formattedGenerateContentRequest = {\n        model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,\n        generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,\n        safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,\n        tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,\n        toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,\n        systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,\n        cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,\n        contents: [],\n    };\n    const containsGenerateContentRequest = params.generateContentRequest != null;\n    if (params.contents) {\n        if (containsGenerateContentRequest) {\n            throw new GoogleGenerativeAIRequestInputError(\"CountTokensRequest must have one of contents or generateContentRequest, not both.\");\n        }\n        formattedGenerateContentRequest.contents = params.contents;\n    }\n    else if (containsGenerateContentRequest) {\n        formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedGenerateContentRequest.contents = [content];\n    }\n    return { generateContentRequest: formattedGenerateContentRequest };\n}\nfunction formatGenerateContentInput(params) {\n    let formattedRequest;\n    if (params.contents) {\n        formattedRequest = params;\n    }\n    else {\n        // Array or string\n        const content = formatNewContent(params);\n        formattedRequest = { contents: [content] };\n    }\n    if (params.systemInstruction) {\n        formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);\n    }\n    return formattedRequest;\n}\nfunction formatEmbedContentInput(params) {\n    if (typeof params === \"string\" || Array.isArray(params)) {\n        const content = formatNewContent(params);\n        return { content };\n    }\n    return params;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://ai.google.dev/api/rest/v1beta/Content#part\nconst VALID_PART_FIELDS = [\n    \"text\",\n    \"inlineData\",\n    \"functionCall\",\n    \"functionResponse\",\n    \"executableCode\",\n    \"codeExecutionResult\",\n];\nconst VALID_PARTS_PER_ROLE = {\n    user: [\"text\", \"inlineData\"],\n    function: [\"functionResponse\"],\n    model: [\"text\", \"functionCall\", \"executableCode\", \"codeExecutionResult\"],\n    // System instructions shouldn't be in history anyway.\n    system: [\"text\"],\n};\nfunction validateChatHistory(history) {\n    let prevContent = false;\n    for (const currContent of history) {\n        const { role, parts } = currContent;\n        if (!prevContent && role !== \"user\") {\n            throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);\n        }\n        if (!POSSIBLE_ROLES.includes(role)) {\n            throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);\n        }\n        if (!Array.isArray(parts)) {\n            throw new GoogleGenerativeAIError(\"Content should have 'parts' property with an array of Parts\");\n        }\n        if (parts.length === 0) {\n            throw new GoogleGenerativeAIError(\"Each Content should have at least one part\");\n        }\n        const countFields = {\n            text: 0,\n            inlineData: 0,\n            functionCall: 0,\n            functionResponse: 0,\n            fileData: 0,\n            executableCode: 0,\n            codeExecutionResult: 0,\n        };\n        for (const part of parts) {\n            for (const key of VALID_PART_FIELDS) {\n                if (key in part) {\n                    countFields[key] += 1;\n                }\n            }\n        }\n        const validParts = VALID_PARTS_PER_ROLE[role];\n        for (const key of VALID_PART_FIELDS) {\n            if (!validParts.includes(key) && countFields[key] > 0) {\n                throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);\n            }\n        }\n        prevContent = true;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do not log a message for this error.\n */\nconst SILENT_ERROR = \"SILENT_ERROR\";\n/**\n * ChatSession class that enables sending chat messages and stores\n * history of sent and received messages so far.\n *\n * @public\n */\nclass ChatSession {\n    constructor(apiKey, model, params, _requestOptions = {}) {\n        this.model = model;\n        this.params = params;\n        this._requestOptions = _requestOptions;\n        this._history = [];\n        this._sendPromise = Promise.resolve();\n        this._apiKey = apiKey;\n        if (params === null || params === void 0 ? void 0 : params.history) {\n            validateChatHistory(params.history);\n            this._history = params.history;\n        }\n    }\n    /**\n     * Gets the chat history so far. Blocked prompts are not added to history.\n     * Blocked candidates are not added to history, nor are the prompts that\n     * generated them.\n     */\n    async getHistory() {\n        await this._sendPromise;\n        return this._history;\n    }\n    /**\n     * Sends a chat message and receives a non-streaming\n     * {@link GenerateContentResult}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async sendMessage(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        let finalResult;\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions))\n            .then((result) => {\n            var _a;\n            if (result.response.candidates &&\n                result.response.candidates.length > 0) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({ parts: [], \n                    // Response seems to come back without a role set.\n                    role: \"model\" }, (_a = result.response.candidates) === null || _a === void 0 ? void 0 : _a[0].content);\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(result.response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n            finalResult = result;\n        });\n        await this._sendPromise;\n        return finalResult;\n    }\n    /**\n     * Sends a chat message and receives the response as a\n     * {@link GenerateContentStreamResult} containing an iterable stream\n     * and a response promise.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async sendMessageStream(request, requestOptions = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        await this._sendPromise;\n        const newContent = formatNewContent(request);\n        const generateContentRequest = {\n            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,\n            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,\n            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,\n            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,\n            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,\n            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,\n            contents: [...this._history, newContent],\n        };\n        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);\n        // Add onto the chain.\n        this._sendPromise = this._sendPromise\n            .then(() => streamPromise)\n            // This must be handled to avoid unhandled rejection, but jump\n            // to the final catch block with a label to not log this error.\n            .catch((_ignored) => {\n            throw new Error(SILENT_ERROR);\n        })\n            .then((streamResult) => streamResult.response)\n            .then((response) => {\n            if (response.candidates && response.candidates.length > 0) {\n                this._history.push(newContent);\n                const responseContent = Object.assign({}, response.candidates[0].content);\n                // Response seems to come back without a role set.\n                if (!responseContent.role) {\n                    responseContent.role = \"model\";\n                }\n                this._history.push(responseContent);\n            }\n            else {\n                const blockErrorMessage = formatBlockErrorMessage(response);\n                if (blockErrorMessage) {\n                    console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);\n                }\n            }\n        })\n            .catch((e) => {\n            // Errors in streamPromise are already catchable by the user as\n            // streamPromise is returned.\n            // Avoid duplicating the error message in logs.\n            if (e.message !== SILENT_ERROR) {\n                // Users do not have access to _sendPromise to catch errors\n                // downstream from streamPromise, so they should not throw.\n                console.error(e);\n            }\n        });\n        return streamPromise;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function countTokens(apiKey, model, params, singleRequestOptions) {\n    const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function embedContent(apiKey, model, params, requestOptions) {\n    const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);\n    return response.json();\n}\nasync function batchEmbedContents(apiKey, model, params, requestOptions) {\n    const requestsWithModel = params.requests.map((request) => {\n        return Object.assign(Object.assign({}, request), { model });\n    });\n    const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);\n    return response.json();\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for generative model APIs.\n * @public\n */\nclass GenerativeModel {\n    constructor(apiKey, modelParams, _requestOptions = {}) {\n        this.apiKey = apiKey;\n        this._requestOptions = _requestOptions;\n        if (modelParams.model.includes(\"/\")) {\n            // Models may be named \"models/model-name\" or \"tunedModels/model-name\"\n            this.model = modelParams.model;\n        }\n        else {\n            // If path is not included, assume it's a non-tuned model.\n            this.model = `models/${modelParams.model}`;\n        }\n        this.generationConfig = modelParams.generationConfig || {};\n        this.safetySettings = modelParams.safetySettings || [];\n        this.tools = modelParams.tools;\n        this.toolConfig = modelParams.toolConfig;\n        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);\n        this.cachedContent = modelParams.cachedContent;\n    }\n    /**\n     * Makes a single non-streaming call to the model\n     * and returns an object containing a single {@link GenerateContentResponse}.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async generateContent(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Makes a single streaming call to the model and returns an object\n     * containing an iterable stream that iterates over all chunks in the\n     * streaming response as well as a promise that returns the final\n     * aggregated response.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async generateContentStream(request, requestOptions = {}) {\n        var _a;\n        const formattedParams = formatGenerateContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);\n    }\n    /**\n     * Gets a new {@link ChatSession} instance which can be used for\n     * multi-turn chats.\n     */\n    startChat(startChatParams) {\n        var _a;\n        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);\n    }\n    /**\n     * Counts the tokens in the provided request.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async countTokens(request, requestOptions = {}) {\n        const formattedParams = formatCountTokensInput(request, {\n            model: this.model,\n            generationConfig: this.generationConfig,\n            safetySettings: this.safetySettings,\n            tools: this.tools,\n            toolConfig: this.toolConfig,\n            systemInstruction: this.systemInstruction,\n            cachedContent: this.cachedContent,\n        });\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds the provided content.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async embedContent(request, requestOptions = {}) {\n        const formattedParams = formatEmbedContentInput(request);\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);\n    }\n    /**\n     * Embeds an array of {@link EmbedContentRequest}s.\n     *\n     * Fields set in the optional {@link SingleRequestOptions} parameter will\n     * take precedence over the {@link RequestOptions} values provided at the\n     * time of the {@link GoogleAIFileManager} initialization.\n     */\n    async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {\n        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Top-level class for this SDK\n * @public\n */\nclass GoogleGenerativeAI {\n    constructor(apiKey) {\n        this.apiKey = apiKey;\n    }\n    /**\n     * Gets a {@link GenerativeModel} instance for the provided model name.\n     */\n    getGenerativeModel(modelParams, requestOptions) {\n        if (!modelParams.model) {\n            throw new GoogleGenerativeAIError(`Must provide a model name. ` +\n                `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);\n        }\n        return new GenerativeModel(this.apiKey, modelParams, requestOptions);\n    }\n    /**\n     * Creates a {@link GenerativeModel} instance from provided content cache.\n     */\n    getGenerativeModelFromCachedContent(cachedContent, requestOptions) {\n        if (!cachedContent.name) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `name` field.\");\n        }\n        if (!cachedContent.model) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `model` field.\");\n        }\n        const modelParamsFromCache = {\n            model: cachedContent.model,\n            tools: cachedContent.tools,\n            toolConfig: cachedContent.toolConfig,\n            systemInstruction: cachedContent.systemInstruction,\n            cachedContent,\n        };\n        return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);\n    }\n}\n\nexports.ChatSession = ChatSession;\nexports.GenerativeModel = GenerativeModel;\nexports.GoogleGenerativeAI = GoogleGenerativeAI;\nexports.GoogleGenerativeAIError = GoogleGenerativeAIError;\nexports.GoogleGenerativeAIFetchError = GoogleGenerativeAIFetchError;\nexports.GoogleGenerativeAIRequestInputError = GoogleGenerativeAIRequestInputError;\nexports.GoogleGenerativeAIResponseError = GoogleGenerativeAIResponseError;\nexports.POSSIBLE_ROLES = POSSIBLE_ROLES;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZWFpL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmVyYXRpdmUtYWkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEMscUNBQXFDLEtBQUs7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUMscUNBQXFDLDhCQUE4QixLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0IsZUFBZSxLQUFLOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQixvQkFBb0IsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUMsMEJBQTBCLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLHVCQUF1QixLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsbUJBQW1CLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkIsb0JBQW9CLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLDJCQUEyQixLQUFLOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQixHQUFHLGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsK0JBQStCLGNBQWMsVUFBVTtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxXQUFXO0FBQzVHO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3Q0FBd0Msc0RBQXNEO0FBQ2xKO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWUsSUFBSSxVQUFVO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxlQUFlLEtBQUssaUJBQWlCLEVBQUUsb0JBQW9CLElBQUksUUFBUTtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0QkFBNEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0NBQWtDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGtDQUFrQztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNEJBQTRCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtDQUFrQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysa0NBQWtDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0QkFBNEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0NBQWtDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGtDQUFrQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBLDRCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0QkFBNEI7QUFDbkY7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsU0FBUztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQixhQUFhO0FBQ3hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsK0ZBQStGLEtBQUs7QUFDcEc7QUFDQTtBQUNBLDBGQUEwRixNQUFNLHVCQUF1QiwrQkFBK0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLLG1CQUFtQixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9ELGlDQUFpQyxzQkFBc0I7QUFDdkQsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0M7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0QsaUNBQWlDLHNCQUFzQjtBQUN2RCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0I7QUFDNUY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxPQUFPO0FBQ2xFLEtBQUs7QUFDTCw4R0FBOEcsNkJBQTZCO0FBQzNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0QsaUNBQWlDLHNCQUFzQjtBQUN2RCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsd0VBQXdFLGdRQUFnUTtBQUN4VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0QsaUNBQWlDLHNCQUFzQjtBQUN2RCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsOEVBQThFLGdRQUFnUTtBQUM5VTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxnUUFBZ1E7QUFDeFU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9ELGlDQUFpQyxzQkFBc0I7QUFDdkQsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRCxpQ0FBaUMsc0JBQXNCO0FBQ3ZELG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0QsaUNBQWlDLHNCQUFzQjtBQUN2RCxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsMEVBQTBFO0FBQzFFLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLDJDQUEyQztBQUMzQyx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvZ29vZ2xlYWkvbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2VuZXJhdGl2ZS1haS9kaXN0L2luZGV4LmpzP2RmNDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnRhaW5zIHRoZSBsaXN0IG9mIE9wZW5BUEkgZGF0YSB0eXBlc1xuICogYXMgZGVmaW5lZCBieSBodHRwczovL3N3YWdnZXIuaW8vZG9jcy9zcGVjaWZpY2F0aW9uL2RhdGEtbW9kZWxzL2RhdGEtdHlwZXMvXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvblNjaGVtYVR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uRGVjbGFyYXRpb25TY2hlbWFUeXBlKSB7XG4gICAgLyoqIFN0cmluZyB0eXBlLiAqL1xuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb25TY2hlbWFUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKiogTnVtYmVyIHR5cGUuICovXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvblNjaGVtYVR5cGVbXCJOVU1CRVJcIl0gPSBcIk5VTUJFUlwiO1xuICAgIC8qKiBJbnRlZ2VyIHR5cGUuICovXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvblNjaGVtYVR5cGVbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gICAgLyoqIEJvb2xlYW4gdHlwZS4gKi9cbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uU2NoZW1hVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKiogQXJyYXkgdHlwZS4gKi9cbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uU2NoZW1hVHlwZVtcIkFSUkFZXCJdID0gXCJBUlJBWVwiO1xuICAgIC8qKiBPYmplY3QgdHlwZS4gKi9cbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uU2NoZW1hVHlwZVtcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG59KShleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb25TY2hlbWFUeXBlIHx8IChleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb25TY2hlbWFUeXBlID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLkV4ZWN1dGFibGVDb2RlTGFuZ3VhZ2UgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEV4ZWN1dGFibGVDb2RlTGFuZ3VhZ2UpIHtcbiAgICBFeGVjdXRhYmxlQ29kZUxhbmd1YWdlW1wiTEFOR1VBR0VfVU5TUEVDSUZJRURcIl0gPSBcImxhbmd1YWdlX3Vuc3BlY2lmaWVkXCI7XG4gICAgRXhlY3V0YWJsZUNvZGVMYW5ndWFnZVtcIlBZVEhPTlwiXSA9IFwicHl0aG9uXCI7XG59KShleHBvcnRzLkV4ZWN1dGFibGVDb2RlTGFuZ3VhZ2UgfHwgKGV4cG9ydHMuRXhlY3V0YWJsZUNvZGVMYW5ndWFnZSA9IHt9KSk7XG4vKipcbiAqIFBvc3NpYmxlIG91dGNvbWVzIG9mIGNvZGUgZXhlY3V0aW9uLlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLk91dGNvbWUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBzdGF0dXMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCJdID0gXCJvdXRjb21lX3Vuc3BlY2lmaWVkXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9PS1wiXSA9IFwib3V0Y29tZV9va1wiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGZpbmlzaGVkIGJ1dCB3aXRoIGEgZmFpbHVyZS4gYHN0ZGVycmAgc2hvdWxkIGNvbnRhaW4gdGhlXG4gICAgICogcmVhc29uLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0ZBSUxFRFwiXSA9IFwib3V0Y29tZV9mYWlsZWRcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiByYW4gZm9yIHRvbyBsb25nLCBhbmQgd2FzIGNhbmNlbGxlZC4gVGhlcmUgbWF5IG9yIG1heSBub3RcbiAgICAgKiBiZSBhIHBhcnRpYWwgb3V0cHV0IHByZXNlbnQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIm91dGNvbWVfZGVhZGxpbmVfZXhjZWVkZWRcIjtcbn0pKGV4cG9ydHMuT3V0Y29tZSB8fCAoZXhwb3J0cy5PdXRjb21lID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUG9zc2libGUgcm9sZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFBPU1NJQkxFX1JPTEVTID0gW1widXNlclwiLCBcIm1vZGVsXCIsIFwiZnVuY3Rpb25cIiwgXCJzeXN0ZW1cIl07XG4vKipcbiAqIEhhcm0gY2F0ZWdvcmllcyB0aGF0IHdvdWxkIGNhdXNlIHByb21wdHMgb3IgY2FuZGlkYXRlcyB0byBiZSBibG9ja2VkLlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLkhhcm1DYXRlZ29yeSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIjtcbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCI7XG59KShleHBvcnRzLkhhcm1DYXRlZ29yeSB8fCAoZXhwb3J0cy5IYXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqXG4gKiBUaHJlc2hvbGQgYWJvdmUgd2hpY2ggYSBwcm9tcHQgb3IgY2FuZGlkYXRlIHdpbGwgYmUgYmxvY2tlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5IYXJtQmxvY2tUaHJlc2hvbGQgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja1RocmVzaG9sZCkge1xuICAgIC8vIFRocmVzaG9sZCBpcyB1bnNwZWNpZmllZC5cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvLyBDb250ZW50IHdpdGggTkVHTElHSUJMRSB3aWxsIGJlIGFsbG93ZWQuXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIC8vIENvbnRlbnQgd2l0aCBORUdMSUdJQkxFIGFuZCBMT1cgd2lsbCBiZSBhbGxvd2VkLlxuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICAvLyBDb250ZW50IHdpdGggTkVHTElHSUJMRSwgTE9XLCBhbmQgTUVESVVNIHdpbGwgYmUgYWxsb3dlZC5cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIC8vIEFsbCBjb250ZW50IHdpbGwgYmUgYWxsb3dlZC5cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG59KShleHBvcnRzLkhhcm1CbG9ja1RocmVzaG9sZCB8fCAoZXhwb3J0cy5IYXJtQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqXG4gKiBQcm9iYWJpbGl0eSB0aGF0IGEgcHJvbXB0IG9yIGNhbmRpZGF0ZSBtYXRjaGVzIGEgaGFybSBjYXRlZ29yeS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5IYXJtUHJvYmFiaWxpdHkgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEhhcm1Qcm9iYWJpbGl0eSkge1xuICAgIC8vIFByb2JhYmlsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvLyBDb250ZW50IGhhcyBhIG5lZ2xpZ2libGUgY2hhbmNlIG9mIGJlaW5nIHVuc2FmZS5cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJORUdMSUdJQkxFXCJdID0gXCJORUdMSUdJQkxFXCI7XG4gICAgLy8gQ29udGVudCBoYXMgYSBsb3cgY2hhbmNlIG9mIGJlaW5nIHVuc2FmZS5cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIC8vIENvbnRlbnQgaGFzIGEgbWVkaXVtIGNoYW5jZSBvZiBiZWluZyB1bnNhZmUuXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTUVESVVNXCJdID0gXCJNRURJVU1cIjtcbiAgICAvLyBDb250ZW50IGhhcyBhIGhpZ2ggY2hhbmNlIG9mIGJlaW5nIHVuc2FmZS5cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShleHBvcnRzLkhhcm1Qcm9iYWJpbGl0eSB8fCAoZXhwb3J0cy5IYXJtUHJvYmFiaWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBSZWFzb24gdGhhdCBhIHByb21wdCB3YXMgYmxvY2tlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5CbG9ja1JlYXNvbiA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQmxvY2tSZWFzb24pIHtcbiAgICAvLyBBIGJsb2NrZWQgcmVhc29uIHdhcyBub3Qgc3BlY2lmaWVkLlxuICAgIEJsb2NrUmVhc29uW1wiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLy8gQ29udGVudCB3YXMgYmxvY2tlZCBieSBzYWZldHkgc2V0dGluZ3MuXG4gICAgQmxvY2tSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIC8vIENvbnRlbnQgd2FzIGJsb2NrZWQsIGJ1dCB0aGUgcmVhc29uIGlzIHVuY2F0ZWdvcml6ZWQuXG4gICAgQmxvY2tSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbn0pKGV4cG9ydHMuQmxvY2tSZWFzb24gfHwgKGV4cG9ydHMuQmxvY2tSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBSZWFzb24gdGhhdCBhIGNhbmRpZGF0ZSBmaW5pc2hlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5GaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEZpbmlzaFJlYXNvbikge1xuICAgIC8vIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgIEZpbmlzaFJlYXNvbltcIkZJTklTSF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkZJTklTSF9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvLyBOYXR1cmFsIHN0b3AgcG9pbnQgb2YgdGhlIG1vZGVsIG9yIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UuXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgYXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLlxuICAgIEZpbmlzaFJlYXNvbltcIk1BWF9UT0tFTlNcIl0gPSBcIk1BWF9UT0tFTlNcIjtcbiAgICAvLyBUaGUgY2FuZGlkYXRlIGNvbnRlbnQgd2FzIGZsYWdnZWQgZm9yIHNhZmV0eSByZWFzb25zLlxuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLy8gVGhlIGNhbmRpZGF0ZSBjb250ZW50IHdhcyBmbGFnZ2VkIGZvciByZWNpdGF0aW9uIHJlYXNvbnMuXG4gICAgRmluaXNoUmVhc29uW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICAgIC8vIFRoZSBjYW5kaWRhdGUgY29udGVudCB3YXMgZmxhZ2dlZCBmb3IgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLy8gVW5rbm93biByZWFzb24uXG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG59KShleHBvcnRzLkZpbmlzaFJlYXNvbiB8fCAoZXhwb3J0cy5GaW5pc2hSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBUYXNrIHR5cGUgZm9yIGVtYmVkZGluZyBjb250ZW50LlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLlRhc2tUeXBlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChUYXNrVHlwZSkge1xuICAgIFRhc2tUeXBlW1wiVEFTS19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUQVNLX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICBUYXNrVHlwZVtcIlJFVFJJRVZBTF9RVUVSWVwiXSA9IFwiUkVUUklFVkFMX1FVRVJZXCI7XG4gICAgVGFza1R5cGVbXCJSRVRSSUVWQUxfRE9DVU1FTlRcIl0gPSBcIlJFVFJJRVZBTF9ET0NVTUVOVFwiO1xuICAgIFRhc2tUeXBlW1wiU0VNQU5USUNfU0lNSUxBUklUWVwiXSA9IFwiU0VNQU5USUNfU0lNSUxBUklUWVwiO1xuICAgIFRhc2tUeXBlW1wiQ0xBU1NJRklDQVRJT05cIl0gPSBcIkNMQVNTSUZJQ0FUSU9OXCI7XG4gICAgVGFza1R5cGVbXCJDTFVTVEVSSU5HXCJdID0gXCJDTFVTVEVSSU5HXCI7XG59KShleHBvcnRzLlRhc2tUeXBlIHx8IChleHBvcnRzLlRhc2tUeXBlID0ge30pKTtcbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLkZ1bmN0aW9uQ2FsbGluZ01vZGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uQ2FsbGluZ01vZGUpIHtcbiAgICAvLyBVbnNwZWNpZmllZCBmdW5jdGlvbiBjYWxsaW5nIG1vZGUuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgIEZ1bmN0aW9uQ2FsbGluZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLy8gRGVmYXVsdCBtb2RlbCBiZWhhdmlvciwgbW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBhIGZ1bmN0aW9uIGNhbGxcbiAgICAvLyBvciBhIG5hdHVyYWwgbGFuZ3VhZ2UgcmVwc3Bvc2UuXG4gICAgRnVuY3Rpb25DYWxsaW5nTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICAvLyBNb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdGluZyBhIGZ1bmN0aW9uIGNhbGwgb25seS5cbiAgICAvLyBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGwgd2lsbCBiZVxuICAgIC8vIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkXG4gICAgLy8gZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgRnVuY3Rpb25DYWxsaW5nTW9kZVtcIkFOWVwiXSA9IFwiQU5ZXCI7XG4gICAgLy8gTW9kZWwgd2lsbCBub3QgcHJlZGljdCBhbnkgZnVuY3Rpb24gY2FsbC4gTW9kZWwgYmVoYXZpb3IgaXMgc2FtZSBhcyB3aGVuXG4gICAgLy8gbm90IHBhc3NpbmcgYW55IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucy5cbiAgICBGdW5jdGlvbkNhbGxpbmdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xufSkoZXhwb3J0cy5GdW5jdGlvbkNhbGxpbmdNb2RlIHx8IChleHBvcnRzLkZ1bmN0aW9uQ2FsbGluZ01vZGUgPSB7fSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBCYXNpYyBlcnJvciB0eXBlIGZvciB0aGlzIFNESy5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihgW0dvb2dsZUdlbmVyYXRpdmVBSSBFcnJvcl06ICR7bWVzc2FnZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9ycyBpbiB0aGUgY29udGVudHMgb2YgYSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC4gVGhpcyBpbmNsdWRlcyBwYXJzaW5nXG4gKiBlcnJvcnMsIG9yIHJlc3BvbnNlcyBpbmNsdWRpbmcgYSBzYWZldHkgYmxvY2sgcmVhc29uLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHb29nbGVHZW5lcmF0aXZlQUlSZXNwb25zZUVycm9yIGV4dGVuZHMgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciBjbGFzcyBjb3ZlcmluZyBIVFRQIGVycm9ycyB3aGVuIGNhbGxpbmcgdGhlIHNlcnZlci4gSW5jbHVkZXMgSFRUUFxuICogc3RhdHVzLCBzdGF0dXNUZXh0LCBhbmQgb3B0aW9uYWwgZGV0YWlscywgaWYgcHJvdmlkZWQgaW4gdGhlIHNlcnZlciByZXNwb25zZS5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgR29vZ2xlR2VuZXJhdGl2ZUFJRmV0Y2hFcnJvciBleHRlbmRzIEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c1RleHQsIGVycm9yRGV0YWlscykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWxzID0gZXJyb3JEZXRhaWxzO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3JzIGluIHRoZSBjb250ZW50cyBvZiBhIHJlcXVlc3Qgb3JpZ2luYXRpbmcgZnJvbSB1c2VyIGlucHV0LlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHb29nbGVHZW5lcmF0aXZlQUlSZXF1ZXN0SW5wdXRFcnJvciBleHRlbmRzIEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yIHtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tXCI7XG5jb25zdCBERUZBVUxUX0FQSV9WRVJTSU9OID0gXCJ2MWJldGFcIjtcbi8qKlxuICogV2UgY2FuJ3QgYHJlcXVpcmVgIHBhY2thZ2UuanNvbiBpZiB0aGlzIHJ1bnMgb24gd2ViLiBXZSB3aWxsIHVzZSByb2xsdXAgdG9cbiAqIHN3YXAgaW4gdGhlIHZlcnNpb24gbnVtYmVyIGhlcmUgYXQgYnVpbGQgdGltZS5cbiAqL1xuY29uc3QgUEFDS0FHRV9WRVJTSU9OID0gXCIwLjE2LjFcIjtcbmNvbnN0IFBBQ0tBR0VfTE9HX0hFQURFUiA9IFwiZ2VuYWktanNcIjtcbnZhciBUYXNrO1xuKGZ1bmN0aW9uIChUYXNrKSB7XG4gICAgVGFza1tcIkdFTkVSQVRFX0NPTlRFTlRcIl0gPSBcImdlbmVyYXRlQ29udGVudFwiO1xuICAgIFRhc2tbXCJTVFJFQU1fR0VORVJBVEVfQ09OVEVOVFwiXSA9IFwic3RyZWFtR2VuZXJhdGVDb250ZW50XCI7XG4gICAgVGFza1tcIkNPVU5UX1RPS0VOU1wiXSA9IFwiY291bnRUb2tlbnNcIjtcbiAgICBUYXNrW1wiRU1CRURfQ09OVEVOVFwiXSA9IFwiZW1iZWRDb250ZW50XCI7XG4gICAgVGFza1tcIkJBVENIX0VNQkVEX0NPTlRFTlRTXCJdID0gXCJiYXRjaEVtYmVkQ29udGVudHNcIjtcbn0pKFRhc2sgfHwgKFRhc2sgPSB7fSkpO1xuY2xhc3MgUmVxdWVzdFVybCB7XG4gICAgY29uc3RydWN0b3IobW9kZWwsIHRhc2ssIGFwaUtleSwgc3RyZWFtLCByZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3RPcHRpb25zO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9ICgoX2EgPSB0aGlzLnJlcXVlc3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBpVmVyc2lvbikgfHwgREVGQVVMVF9BUElfVkVSU0lPTjtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9ICgoX2IgPSB0aGlzLnJlcXVlc3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmFzZVVybCkgfHwgREVGQVVMVF9CQVNFX1VSTDtcbiAgICAgICAgbGV0IHVybCA9IGAke2Jhc2VVcmx9LyR7YXBpVmVyc2lvbn0vJHt0aGlzLm1vZGVsfToke3RoaXMudGFza31gO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHVybCArPSBcIj9hbHQ9c3NlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG4vKipcbiAqIFNpbXBsZSwgYnV0IG1heSBiZWNvbWUgbW9yZSBjb21wbGV4IGlmIHdlIGFkZCBtb3JlIHZlcnNpb25zIHRvIGxvZy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50SGVhZGVycyhyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IGNsaWVudEhlYWRlcnMgPSBbXTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPcHRpb25zLmFwaUNsaWVudCkge1xuICAgICAgICBjbGllbnRIZWFkZXJzLnB1c2gocmVxdWVzdE9wdGlvbnMuYXBpQ2xpZW50KTtcbiAgICB9XG4gICAgY2xpZW50SGVhZGVycy5wdXNoKGAke1BBQ0tBR0VfTE9HX0hFQURFUn0vJHtQQUNLQUdFX1ZFUlNJT059YCk7XG4gICAgcmV0dXJuIGNsaWVudEhlYWRlcnMuam9pbihcIiBcIik7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRIZWFkZXJzKHVybCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJ4LWdvb2ctYXBpLWNsaWVudFwiLCBnZXRDbGllbnRIZWFkZXJzKHVybC5yZXF1ZXN0T3B0aW9ucykpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwieC1nb29nLWFwaS1rZXlcIiwgdXJsLmFwaUtleSk7XG4gICAgbGV0IGN1c3RvbUhlYWRlcnMgPSAoX2EgPSB1cmwucmVxdWVzdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b21IZWFkZXJzO1xuICAgIGlmIChjdXN0b21IZWFkZXJzKSB7XG4gICAgICAgIGlmICghKGN1c3RvbUhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjdXN0b21IZWFkZXJzID0gbmV3IEhlYWRlcnMoY3VzdG9tSGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlSZXF1ZXN0SW5wdXRFcnJvcihgdW5hYmxlIHRvIGNvbnZlcnQgY3VzdG9tSGVhZGVycyB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KGN1c3RvbUhlYWRlcnMpfSB0byBIZWFkZXJzOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0gb2YgY3VzdG9tSGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJOYW1lID09PSBcIngtZ29vZy1hcGkta2V5XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVxdWVzdElucHV0RXJyb3IoYENhbm5vdCBzZXQgcmVzZXJ2ZWQgaGVhZGVyIG5hbWUgJHtoZWFkZXJOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gXCJ4LWdvb2ctYXBpLWNsaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdvb2dsZUdlbmVyYXRpdmVBSVJlcXVlc3RJbnB1dEVycm9yKGBIZWFkZXIgbmFtZSAke2hlYWRlck5hbWV9IGNhbiBvbmx5IGJlIHNldCB1c2luZyB0aGUgYXBpQ2xpZW50IGZpZWxkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5hc3luYyBmdW5jdGlvbiBjb25zdHJ1Y3RNb2RlbFJlcXVlc3QobW9kZWwsIHRhc2ssIGFwaUtleSwgc3RyZWFtLCBib2R5LCByZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IG5ldyBSZXF1ZXN0VXJsKG1vZGVsLCB0YXNrLCBhcGlLZXksIHN0cmVhbSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdXJsLnRvU3RyaW5nKCksXG4gICAgICAgIGZldGNoT3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZEZldGNoT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpLCB7IG1ldGhvZDogXCJQT1NUXCIsIGhlYWRlcnM6IGF3YWl0IGdldEhlYWRlcnModXJsKSwgYm9keSB9KSxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWFrZU1vZGVsUmVxdWVzdChtb2RlbCwgdGFzaywgYXBpS2V5LCBzdHJlYW0sIGJvZHksIHJlcXVlc3RPcHRpb25zID0ge30sIFxuLy8gQWxsb3dzIHRoaXMgdG8gYmUgc3R1YmJlZCBmb3IgdGVzdHNcbmZldGNoRm4gPSBmZXRjaCkge1xuICAgIGNvbnN0IHsgdXJsLCBmZXRjaE9wdGlvbnMgfSA9IGF3YWl0IGNvbnN0cnVjdE1vZGVsUmVxdWVzdChtb2RlbCwgdGFzaywgYXBpS2V5LCBzdHJlYW0sIGJvZHksIHJlcXVlc3RPcHRpb25zKTtcbiAgICByZXR1cm4gbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMsIGZldGNoRm4pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWFrZVJlcXVlc3QodXJsLCBmZXRjaE9wdGlvbnMsIGZldGNoRm4gPSBmZXRjaCkge1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoRm4odXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVSZXNwb25zZUVycm9yKGUsIHVybCk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlUmVzcG9uc2VOb3RPayhyZXNwb25zZSwgdXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VFcnJvcihlLCB1cmwpIHtcbiAgICBsZXQgZXJyID0gZTtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgR29vZ2xlR2VuZXJhdGl2ZUFJRmV0Y2hFcnJvciB8fFxuICAgICAgICBlIGluc3RhbmNlb2YgR29vZ2xlR2VuZXJhdGl2ZUFJUmVxdWVzdElucHV0RXJyb3IpKSB7XG4gICAgICAgIGVyciA9IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlFcnJvcihgRXJyb3IgZmV0Y2hpbmcgZnJvbSAke3VybC50b1N0cmluZygpfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIGVyci5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICAgIHRocm93IGVycjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlTm90T2socmVzcG9uc2UsIHVybCkge1xuICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICBsZXQgZXJyb3JEZXRhaWxzO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIG1lc3NhZ2UgPSBqc29uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIGlmIChqc29uLmVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAke0pTT04uc3RyaW5naWZ5KGpzb24uZXJyb3IuZGV0YWlscyl9YDtcbiAgICAgICAgICAgIGVycm9yRGV0YWlscyA9IGpzb24uZXJyb3IuZGV0YWlscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVkXG4gICAgfVxuICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlGZXRjaEVycm9yKGBFcnJvciBmZXRjaGluZyBmcm9tICR7dXJsLnRvU3RyaW5nKCl9OiBbJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1dICR7bWVzc2FnZX1gLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIGVycm9yRGV0YWlscyk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgcmVxdWVzdCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgZmV0Y2ggQVBJLlxuICogQHBhcmFtIHJlcXVlc3RPcHRpb25zIC0gVGhlIHVzZXItZGVmaW5lZCByZXF1ZXN0IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHJlcXVlc3Qgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRGZXRjaE9wdGlvbnMocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7fTtcbiAgICBpZiAoKHJlcXVlc3RPcHRpb25zID09PSBudWxsIHx8IHJlcXVlc3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0T3B0aW9ucy5zaWduYWwpICE9PSB1bmRlZmluZWQgfHwgKHJlcXVlc3RPcHRpb25zID09PSBudWxsIHx8IHJlcXVlc3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0T3B0aW9ucy50aW1lb3V0KSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmICgocmVxdWVzdE9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPcHRpb25zLnRpbWVvdXQpID49IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCByZXF1ZXN0T3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmV0Y2hPcHRpb25zLnNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hPcHRpb25zO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBZGRzIGNvbnZlbmllbmNlIGhlbHBlciBtZXRob2RzIHRvIGEgcmVzcG9uc2Ugb2JqZWN0LCBpbmNsdWRpbmcgc3RyZWFtXG4gKiBjaHVua3MgKGFzIGxvbmcgYXMgZWFjaCBjaHVuayBpcyBhIGNvbXBsZXRlIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlIEpTT04pLlxuICovXG5mdW5jdGlvbiBhZGRIZWxwZXJzKHJlc3BvbnNlKSB7XG4gICAgcmVzcG9uc2UudGV4dCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNhbmRpZGF0ZXMgJiYgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGlzIHJlc3BvbnNlIGhhZCAke3Jlc3BvbnNlLmNhbmRpZGF0ZXMubGVuZ3RofSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGNhbmRpZGF0ZXMuIFJldHVybmluZyB0ZXh0IGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBvbmx5LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEFjY2VzcyByZXNwb25zZS5jYW5kaWRhdGVzIGRpcmVjdGx5IHRvIHVzZSB0aGUgb3RoZXIgY2FuZGlkYXRlcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYWRCYWRGaW5pc2hSZWFzb24ocmVzcG9uc2UuY2FuZGlkYXRlc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVzcG9uc2VFcnJvcihgJHtmb3JtYXRCbG9ja0Vycm9yTWVzc2FnZShyZXNwb25zZSl9YCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFRleHQocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnByb21wdEZlZWRiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVzcG9uc2VFcnJvcihgVGV4dCBub3QgYXZhaWxhYmxlLiAke2Zvcm1hdEJsb2NrRXJyb3JNZXNzYWdlKHJlc3BvbnNlKX1gLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUT0RPOiByZW1vdmUgYXQgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICovXG4gICAgcmVzcG9uc2UuZnVuY3Rpb25DYWxsID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyAmJiByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoaXMgcmVzcG9uc2UgaGFkICR7cmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGh9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgY2FuZGlkYXRlcy4gUmV0dXJuaW5nIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBvbmx5LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEFjY2VzcyByZXNwb25zZS5jYW5kaWRhdGVzIGRpcmVjdGx5IHRvIHVzZSB0aGUgb3RoZXIgY2FuZGlkYXRlcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYWRCYWRGaW5pc2hSZWFzb24ocmVzcG9uc2UuY2FuZGlkYXRlc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVzcG9uc2VFcnJvcihgJHtmb3JtYXRCbG9ja0Vycm9yTWVzc2FnZShyZXNwb25zZSl9YCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGByZXNwb25zZS5mdW5jdGlvbkNhbGwoKSBpcyBkZXByZWNhdGVkLiBgICtcbiAgICAgICAgICAgICAgICBgVXNlIHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMoKSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgcmV0dXJuIGdldEZ1bmN0aW9uQ2FsbHMocmVzcG9uc2UpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnByb21wdEZlZWRiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVzcG9uc2VFcnJvcihgRnVuY3Rpb24gY2FsbCBub3QgYXZhaWxhYmxlLiAke2Zvcm1hdEJsb2NrRXJyb3JNZXNzYWdlKHJlc3BvbnNlKX1gLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzICYmIHJlc3BvbnNlLmNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhpcyByZXNwb25zZSBoYWQgJHtyZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBjYW5kaWRhdGVzLiBSZXR1cm5pbmcgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIG9ubHkuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgQWNjZXNzIHJlc3BvbnNlLmNhbmRpZGF0ZXMgZGlyZWN0bHkgdG8gdXNlIHRoZSBvdGhlciBjYW5kaWRhdGVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhZEJhZEZpbmlzaFJlYXNvbihyZXNwb25zZS5jYW5kaWRhdGVzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlSZXNwb25zZUVycm9yKGAke2Zvcm1hdEJsb2NrRXJyb3JNZXNzYWdlKHJlc3BvbnNlKX1gLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RnVuY3Rpb25DYWxscyhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UucHJvbXB0RmVlZGJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlSZXNwb25zZUVycm9yKGBGdW5jdGlvbiBjYWxsIG5vdCBhdmFpbGFibGUuICR7Zm9ybWF0QmxvY2tFcnJvck1lc3NhZ2UocmVzcG9uc2UpfWAsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0ZXh0IGZvdW5kIGluIGFsbCBwYXJ0cyBvZiBmaXJzdCBjYW5kaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIGdldFRleHQocmVzcG9uc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgdGV4dFN0cmluZ3MgPSBbXTtcbiAgICBpZiAoKF9iID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmNvbnRlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9kID0gKF9jID0gcmVzcG9uc2UuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzBdLmNvbnRlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQudGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRTdHJpbmdzLnB1c2gocGFydC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0LmV4ZWN1dGFibGVDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGV4dFN0cmluZ3MucHVzaChcIlxcbmBgYHB5dGhvblxcblwiICsgcGFydC5leGVjdXRhYmxlQ29kZS5jb2RlICsgXCJcXG5gYGBcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGV4dFN0cmluZ3MucHVzaChcIlxcbmBgYFxcblwiICsgcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0Lm91dHB1dCArIFwiXFxuYGBgXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0U3RyaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0ZXh0U3RyaW5ncy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGZ1bmN0aW9uQ2FsbCBvZiBmaXJzdCBjYW5kaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQ2FsbHMocmVzcG9uc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IFtdO1xuICAgIGlmICgoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0uY29udGVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2QgPSAoX2MgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF0uY29udGVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC5mdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxzLnB1c2gocGFydC5mdW5jdGlvbkNhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmdW5jdGlvbkNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IGJhZEZpbmlzaFJlYXNvbnMgPSBbXG4gICAgZXhwb3J0cy5GaW5pc2hSZWFzb24uUkVDSVRBVElPTixcbiAgICBleHBvcnRzLkZpbmlzaFJlYXNvbi5TQUZFVFksXG4gICAgZXhwb3J0cy5GaW5pc2hSZWFzb24uTEFOR1VBR0UsXG5dO1xuZnVuY3Rpb24gaGFkQmFkRmluaXNoUmVhc29uKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiAoISFjYW5kaWRhdGUuZmluaXNoUmVhc29uICYmXG4gICAgICAgIGJhZEZpbmlzaFJlYXNvbnMuaW5jbHVkZXMoY2FuZGlkYXRlLmZpbmlzaFJlYXNvbikpO1xufVxuZnVuY3Rpb24gZm9ybWF0QmxvY2tFcnJvck1lc3NhZ2UocmVzcG9uc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgaWYgKCghcmVzcG9uc2UuY2FuZGlkYXRlcyB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgcmVzcG9uc2UucHJvbXB0RmVlZGJhY2spIHtcbiAgICAgICAgbWVzc2FnZSArPSBcIlJlc3BvbnNlIHdhcyBibG9ja2VkXCI7XG4gICAgICAgIGlmICgoX2EgPSByZXNwb25zZS5wcm9tcHRGZWVkYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsb2NrUmVhc29uKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgZHVlIHRvICR7cmVzcG9uc2UucHJvbXB0RmVlZGJhY2suYmxvY2tSZWFzb259YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gcmVzcG9uc2UucHJvbXB0RmVlZGJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja1JlYXNvbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtyZXNwb25zZS5wcm9tcHRGZWVkYmFjay5ibG9ja1JlYXNvbk1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoX2MgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF0pIHtcbiAgICAgICAgY29uc3QgZmlyc3RDYW5kaWRhdGUgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdO1xuICAgICAgICBpZiAoaGFkQmFkRmluaXNoUmVhc29uKGZpcnN0Q2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgQ2FuZGlkYXRlIHdhcyBibG9ja2VkIGR1ZSB0byAke2ZpcnN0Q2FuZGlkYXRlLmZpbmlzaFJlYXNvbn1gO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2FuZGlkYXRlLmZpbmlzaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7Zmlyc3RDYW5kaWRhdGUuZmluaXNoTWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCByZXNwb25zZUxpbmVSRSA9IC9eZGF0YVxcOiAoLiopKD86XFxuXFxufFxcclxccnxcXHJcXG5cXHJcXG4pLztcbi8qKlxuICogUHJvY2VzcyBhIHJlc3BvbnNlLmJvZHkgc3RyZWFtIGZyb20gdGhlIGJhY2tlbmQgYW5kIHJldHVybiBhblxuICogaXRlcmF0b3IgdGhhdCBwcm92aWRlcyBvbmUgY29tcGxldGUgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UgYXQgYSB0aW1lXG4gKiBhbmQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHNpbmdsZSBhZ2dyZWdhdGVkXG4gKiBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBSZXNwb25zZSBmcm9tIGEgZmV0Y2ggY2FsbFxuICovXG5mdW5jdGlvbiBwcm9jZXNzU3RyZWFtKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgaW5wdXRTdHJlYW0gPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbShcInV0ZjhcIiwgeyBmYXRhbDogdHJ1ZSB9KSk7XG4gICAgY29uc3QgcmVzcG9uc2VTdHJlYW0gPSBnZXRSZXNwb25zZVN0cmVhbShpbnB1dFN0cmVhbSk7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gcmVzcG9uc2VTdHJlYW0udGVlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBnZW5lcmF0ZVJlc3BvbnNlU2VxdWVuY2Uoc3RyZWFtMSksXG4gICAgICAgIHJlc3BvbnNlOiBnZXRSZXNwb25zZVByb21pc2Uoc3RyZWFtMiksXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlUHJvbWlzZShzdHJlYW0pIHtcbiAgICBjb25zdCBhbGxSZXNwb25zZXMgPSBbXTtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWxwZXJzKGFnZ3JlZ2F0ZVJlc3BvbnNlcyhhbGxSZXNwb25zZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxSZXNwb25zZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVSZXNwb25zZVNlcXVlbmNlKHN0cmVhbSkge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGdlbmVyYXRlUmVzcG9uc2VTZXF1ZW5jZV8xKCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSB5aWVsZCBfX2F3YWl0KHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoYWRkSGVscGVycyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFJlYWRzIGEgcmF3IHN0cmVhbSBmcm9tIHRoZSBmZXRjaCByZXNwb25zZSBhbmQgam9pbiBpbmNvbXBsZXRlXG4gKiBjaHVua3MsIHJldHVybmluZyBhIG5ldyBzdHJlYW0gdGhhdCBwcm92aWRlcyBhIHNpbmdsZSBjb21wbGV0ZVxuICogR2VuZXJhdGVDb250ZW50UmVzcG9uc2UgaW4gZWFjaCBpdGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3BvbnNlU3RyZWFtKGlucHV0U3RyZWFtKSB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oKHsgdmFsdWUsIGRvbmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBjdXJyZW50VGV4dC5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yKGBFcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2U6IFwiJHttYXRjaFsxXX1cImApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBjdXJyZW50VGV4dC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY3VycmVudFRleHQubWF0Y2gocmVzcG9uc2VMaW5lUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbn1cbi8qKlxuICogQWdncmVnYXRlcyBhbiBhcnJheSBvZiBgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VgcyBpbnRvIGEgc2luZ2xlXG4gKiBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gYWdncmVnYXRlUmVzcG9uc2VzKHJlc3BvbnNlcykge1xuICAgIGNvbnN0IGxhc3RSZXNwb25zZSA9IHJlc3BvbnNlc1tyZXNwb25zZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgYWdncmVnYXRlZFJlc3BvbnNlID0ge1xuICAgICAgICBwcm9tcHRGZWVkYmFjazogbGFzdFJlc3BvbnNlID09PSBudWxsIHx8IGxhc3RSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFJlc3BvbnNlLnByb21wdEZlZWRiYWNrLFxuICAgIH07XG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHJlc3BvbnNlLmNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gY2FuZGlkYXRlLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmICghYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhZ2dyZWdhdGVkUmVzcG9uc2UuY2FuZGlkYXRlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UuY2FuZGlkYXRlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjYW5kaWRhdGUuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEtlZXAgb3ZlcndyaXRpbmcsIHRoZSBsYXN0IG9uZSB3aWxsIGJlIGZpbmFsXG4gICAgICAgICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXNbaV0uY2l0YXRpb25NZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZS5jaXRhdGlvbk1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzW2ldLmZpbmlzaFJlYXNvbiA9IGNhbmRpZGF0ZS5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXNbaV0uZmluaXNoTWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZS5maW5pc2hNZXNzYWdlO1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzW2ldLnNhZmV0eVJhdGluZ3MgPVxuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUuc2FmZXR5UmF0aW5ncztcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYW5kaWRhdGVzIHNob3VsZCBhbHdheXMgaGF2ZSBjb250ZW50IGFuZCBwYXJ0cywgYnV0IHRoaXMgaGFuZGxlc1xuICAgICAgICAgICAgICAgICAqIHBvc3NpYmxlIG1hbGZvcm1lZCByZXNwb25zZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5jb250ZW50ICYmIGNhbmRpZGF0ZS5jb250ZW50LnBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXNbaV0uY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlLmNhbmRpZGF0ZXNbaV0uY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBjYW5kaWRhdGUuY29udGVudC5yb2xlIHx8IFwidXNlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UGFydCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY2FuZGlkYXRlLmNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LnRleHQgPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5mdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LmZ1bmN0aW9uQ2FsbCA9IHBhcnQuZnVuY3Rpb25DYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuZXhlY3V0YWJsZUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LmV4ZWN1dGFibGVDb2RlID0gcGFydC5leGVjdXRhYmxlQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQgPSBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3UGFydCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFydC50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZS5jYW5kaWRhdGVzW2ldLmNvbnRlbnQucGFydHMucHVzaChuZXdQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UudXNhZ2VNZXRhZGF0YSkge1xuICAgICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlLnVzYWdlTWV0YWRhdGEgPSByZXNwb25zZS51c2FnZU1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZ2dyZWdhdGVkUmVzcG9uc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRTdHJlYW0oYXBpS2V5LCBtb2RlbCwgcGFyYW1zLCByZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZU1vZGVsUmVxdWVzdChtb2RlbCwgVGFzay5TVFJFQU1fR0VORVJBVEVfQ09OVEVOVCwgYXBpS2V5LCBcbiAgICAvKiBzdHJlYW0gKi8gdHJ1ZSwgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIHJldHVybiBwcm9jZXNzU3RyZWFtKHJlc3BvbnNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudChhcGlLZXksIG1vZGVsLCBwYXJhbXMsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlTW9kZWxSZXF1ZXN0KG1vZGVsLCBUYXNrLkdFTkVSQVRFX0NPTlRFTlQsIGFwaUtleSwgXG4gICAgLyogc3RyZWFtICovIGZhbHNlLCBKU09OLnN0cmluZ2lmeShwYXJhbXMpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IGVuaGFuY2VkUmVzcG9uc2UgPSBhZGRIZWxwZXJzKHJlc3BvbnNlSnNvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzcG9uc2U6IGVuaGFuY2VkUmVzcG9uc2UsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFN5c3RlbUluc3RydWN0aW9uKGlucHV0KSB7XG4gICAgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgcm9sZTogXCJzeXN0ZW1cIiwgcGFydHM6IFt7IHRleHQ6IGlucHV0IH1dIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcm9sZTogXCJzeXN0ZW1cIiwgcGFydHM6IFtpbnB1dF0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQucGFydHMpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5yb2xlKSB7XG4gICAgICAgICAgICByZXR1cm4geyByb2xlOiBcInN5c3RlbVwiLCBwYXJ0czogaW5wdXQucGFydHMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE5ld0NvbnRlbnQocmVxdWVzdCkge1xuICAgIGxldCBuZXdQYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuZXdQYXJ0cyA9IFt7IHRleHQ6IHJlcXVlc3QgfV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRPclN0cmluZyBvZiByZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnRPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG5ld1BhcnRzLnB1c2goeyB0ZXh0OiBwYXJ0T3JTdHJpbmcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHBhcnRPclN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnblJvbGVUb1BhcnRzQW5kVmFsaWRhdGVTZW5kTWVzc2FnZVJlcXVlc3QobmV3UGFydHMpO1xufVxuLyoqXG4gKiBXaGVuIG11bHRpcGxlIFBhcnQgdHlwZXMgKGkuZS4gRnVuY3Rpb25SZXNwb25zZVBhcnQgYW5kIFRleHRQYXJ0KSBhcmVcbiAqIHBhc3NlZCBpbiBhIHNpbmdsZSBQYXJ0IGFycmF5LCB3ZSBtYXkgbmVlZCB0byBhc3NpZ24gZGlmZmVyZW50IHJvbGVzIHRvIGVhY2hcbiAqIHBhcnQuIEN1cnJlbnRseSBvbmx5IEZ1bmN0aW9uUmVzcG9uc2VQYXJ0IHJlcXVpcmVzIGEgcm9sZSBvdGhlciB0aGFuICd1c2VyJy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gcGFydHMgQXJyYXkgb2YgcGFydHMgdG8gcGFzcyB0byB0aGUgbW9kZWxcbiAqIEByZXR1cm5zIEFycmF5IG9mIGNvbnRlbnQgaXRlbXNcbiAqL1xuZnVuY3Rpb24gYXNzaWduUm9sZVRvUGFydHNBbmRWYWxpZGF0ZVNlbmRNZXNzYWdlUmVxdWVzdChwYXJ0cykge1xuICAgIGNvbnN0IHVzZXJDb250ZW50ID0geyByb2xlOiBcInVzZXJcIiwgcGFydHM6IFtdIH07XG4gICAgY29uc3QgZnVuY3Rpb25Db250ZW50ID0geyByb2xlOiBcImZ1bmN0aW9uXCIsIHBhcnRzOiBbXSB9O1xuICAgIGxldCBoYXNVc2VyQ29udGVudCA9IGZhbHNlO1xuICAgIGxldCBoYXNGdW5jdGlvbkNvbnRlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25SZXNwb25zZVwiIGluIHBhcnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQ29udGVudC5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgaGFzRnVuY3Rpb25Db250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZXJDb250ZW50LnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICBoYXNVc2VyQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1VzZXJDb250ZW50ICYmIGhhc0Z1bmN0aW9uQ29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3IoXCJXaXRoaW4gYSBzaW5nbGUgbWVzc2FnZSwgRnVuY3Rpb25SZXNwb25zZSBjYW5ub3QgYmUgbWl4ZWQgd2l0aCBvdGhlciB0eXBlIG9mIHBhcnQgaW4gdGhlIHJlcXVlc3QgZm9yIHNlbmRpbmcgY2hhdCBtZXNzYWdlLlwiKTtcbiAgICB9XG4gICAgaWYgKCFoYXNVc2VyQ29udGVudCAmJiAhaGFzRnVuY3Rpb25Db250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlFcnJvcihcIk5vIGNvbnRlbnQgaXMgcHJvdmlkZWQgZm9yIHNlbmRpbmcgY2hhdCBtZXNzYWdlLlwiKTtcbiAgICB9XG4gICAgaWYgKGhhc1VzZXJDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB1c2VyQ29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uQ29udGVudDtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvdW50VG9rZW5zSW5wdXQocGFyYW1zLCBtb2RlbFBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm9ybWF0dGVkR2VuZXJhdGVDb250ZW50UmVxdWVzdCA9IHtcbiAgICAgICAgbW9kZWw6IG1vZGVsUGFyYW1zID09PSBudWxsIHx8IG1vZGVsUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RlbFBhcmFtcy5tb2RlbCxcbiAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZzogbW9kZWxQYXJhbXMgPT09IG51bGwgfHwgbW9kZWxQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGVsUGFyYW1zLmdlbmVyYXRpb25Db25maWcsXG4gICAgICAgIHNhZmV0eVNldHRpbmdzOiBtb2RlbFBhcmFtcyA9PT0gbnVsbCB8fCBtb2RlbFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWxQYXJhbXMuc2FmZXR5U2V0dGluZ3MsXG4gICAgICAgIHRvb2xzOiBtb2RlbFBhcmFtcyA9PT0gbnVsbCB8fCBtb2RlbFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWxQYXJhbXMudG9vbHMsXG4gICAgICAgIHRvb2xDb25maWc6IG1vZGVsUGFyYW1zID09PSBudWxsIHx8IG1vZGVsUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RlbFBhcmFtcy50b29sQ29uZmlnLFxuICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbjogbW9kZWxQYXJhbXMgPT09IG51bGwgfHwgbW9kZWxQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGVsUGFyYW1zLnN5c3RlbUluc3RydWN0aW9uLFxuICAgICAgICBjYWNoZWRDb250ZW50OiAoX2EgPSBtb2RlbFBhcmFtcyA9PT0gbnVsbCB8fCBtb2RlbFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWxQYXJhbXMuY2FjaGVkQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUsXG4gICAgICAgIGNvbnRlbnRzOiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRhaW5zR2VuZXJhdGVDb250ZW50UmVxdWVzdCA9IHBhcmFtcy5nZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0ICE9IG51bGw7XG4gICAgaWYgKHBhcmFtcy5jb250ZW50cykge1xuICAgICAgICBpZiAoY29udGFpbnNHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJUmVxdWVzdElucHV0RXJyb3IoXCJDb3VudFRva2Vuc1JlcXVlc3QgbXVzdCBoYXZlIG9uZSBvZiBjb250ZW50cyBvciBnZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0LCBub3QgYm90aC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0dGVkR2VuZXJhdGVDb250ZW50UmVxdWVzdC5jb250ZW50cyA9IHBhcmFtcy5jb250ZW50cztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGFpbnNHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KSB7XG4gICAgICAgIGZvcm1hdHRlZEdlbmVyYXRlQ29udGVudFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdHRlZEdlbmVyYXRlQ29udGVudFJlcXVlc3QpLCBwYXJhbXMuZ2VuZXJhdGVDb250ZW50UmVxdWVzdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBvciBzdHJpbmdcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZvcm1hdE5ld0NvbnRlbnQocGFyYW1zKTtcbiAgICAgICAgZm9ybWF0dGVkR2VuZXJhdGVDb250ZW50UmVxdWVzdC5jb250ZW50cyA9IFtjb250ZW50XTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZ2VuZXJhdGVDb250ZW50UmVxdWVzdDogZm9ybWF0dGVkR2VuZXJhdGVDb250ZW50UmVxdWVzdCB9O1xufVxuZnVuY3Rpb24gZm9ybWF0R2VuZXJhdGVDb250ZW50SW5wdXQocGFyYW1zKSB7XG4gICAgbGV0IGZvcm1hdHRlZFJlcXVlc3Q7XG4gICAgaWYgKHBhcmFtcy5jb250ZW50cykge1xuICAgICAgICBmb3JtYXR0ZWRSZXF1ZXN0ID0gcGFyYW1zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQXJyYXkgb3Igc3RyaW5nXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmb3JtYXROZXdDb250ZW50KHBhcmFtcyk7XG4gICAgICAgIGZvcm1hdHRlZFJlcXVlc3QgPSB7IGNvbnRlbnRzOiBbY29udGVudF0gfTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5zeXN0ZW1JbnN0cnVjdGlvbikge1xuICAgICAgICBmb3JtYXR0ZWRSZXF1ZXN0LnN5c3RlbUluc3RydWN0aW9uID0gZm9ybWF0U3lzdGVtSW5zdHJ1Y3Rpb24ocGFyYW1zLnN5c3RlbUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFJlcXVlc3Q7XG59XG5mdW5jdGlvbiBmb3JtYXRFbWJlZENvbnRlbnRJbnB1dChwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZvcm1hdE5ld0NvbnRlbnQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHsgY29udGVudCB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gaHR0cHM6Ly9haS5nb29nbGUuZGV2L2FwaS9yZXN0L3YxYmV0YS9Db250ZW50I3BhcnRcbmNvbnN0IFZBTElEX1BBUlRfRklFTERTID0gW1xuICAgIFwidGV4dFwiLFxuICAgIFwiaW5saW5lRGF0YVwiLFxuICAgIFwiZnVuY3Rpb25DYWxsXCIsXG4gICAgXCJmdW5jdGlvblJlc3BvbnNlXCIsXG4gICAgXCJleGVjdXRhYmxlQ29kZVwiLFxuICAgIFwiY29kZUV4ZWN1dGlvblJlc3VsdFwiLFxuXTtcbmNvbnN0IFZBTElEX1BBUlRTX1BFUl9ST0xFID0ge1xuICAgIHVzZXI6IFtcInRleHRcIiwgXCJpbmxpbmVEYXRhXCJdLFxuICAgIGZ1bmN0aW9uOiBbXCJmdW5jdGlvblJlc3BvbnNlXCJdLFxuICAgIG1vZGVsOiBbXCJ0ZXh0XCIsIFwiZnVuY3Rpb25DYWxsXCIsIFwiZXhlY3V0YWJsZUNvZGVcIiwgXCJjb2RlRXhlY3V0aW9uUmVzdWx0XCJdLFxuICAgIC8vIFN5c3RlbSBpbnN0cnVjdGlvbnMgc2hvdWxkbid0IGJlIGluIGhpc3RvcnkgYW55d2F5LlxuICAgIHN5c3RlbTogW1widGV4dFwiXSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYXRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICBsZXQgcHJldkNvbnRlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGN1cnJDb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgY29uc3QgeyByb2xlLCBwYXJ0cyB9ID0gY3VyckNvbnRlbnQ7XG4gICAgICAgIGlmICghcHJldkNvbnRlbnQgJiYgcm9sZSAhPT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlFcnJvcihgRmlyc3QgY29udGVudCBzaG91bGQgYmUgd2l0aCByb2xlICd1c2VyJywgZ290ICR7cm9sZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVBPU1NJQkxFX1JPTEVTLmluY2x1ZGVzKHJvbGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3IoYEVhY2ggaXRlbSBzaG91bGQgaW5jbHVkZSByb2xlIGZpZWxkLiBHb3QgJHtyb2xlfSBidXQgdmFsaWQgcm9sZXMgYXJlOiAke0pTT04uc3RyaW5naWZ5KFBPU1NJQkxFX1JPTEVTKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3IoXCJDb250ZW50IHNob3VsZCBoYXZlICdwYXJ0cycgcHJvcGVydHkgd2l0aCBhbiBhcnJheSBvZiBQYXJ0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJRXJyb3IoXCJFYWNoIENvbnRlbnQgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHBhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnRGaWVsZHMgPSB7XG4gICAgICAgICAgICB0ZXh0OiAwLFxuICAgICAgICAgICAgaW5saW5lRGF0YTogMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbDogMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IDAsXG4gICAgICAgICAgICBmaWxlRGF0YTogMCxcbiAgICAgICAgICAgIGV4ZWN1dGFibGVDb2RlOiAwLFxuICAgICAgICAgICAgY29kZUV4ZWN1dGlvblJlc3VsdDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBWQUxJRF9QQVJUX0ZJRUxEUykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudEZpZWxkc1trZXldICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkUGFydHMgPSBWQUxJRF9QQVJUU19QRVJfUk9MRVtyb2xlXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgVkFMSURfUEFSVF9GSUVMRFMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRQYXJ0cy5pbmNsdWRlcyhrZXkpICYmIGNvdW50RmllbGRzW2tleV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yKGBDb250ZW50IHdpdGggcm9sZSAnJHtyb2xlfScgY2FuJ3QgY29udGFpbiAnJHtrZXl9JyBwYXJ0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbnRlbnQgPSB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG8gbm90IGxvZyBhIG1lc3NhZ2UgZm9yIHRoaXMgZXJyb3IuXG4gKi9cbmNvbnN0IFNJTEVOVF9FUlJPUiA9IFwiU0lMRU5UX0VSUk9SXCI7XG4vKipcbiAqIENoYXRTZXNzaW9uIGNsYXNzIHRoYXQgZW5hYmxlcyBzZW5kaW5nIGNoYXQgbWVzc2FnZXMgYW5kIHN0b3Jlc1xuICogaGlzdG9yeSBvZiBzZW50IGFuZCByZWNlaXZlZCBtZXNzYWdlcyBzbyBmYXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBDaGF0U2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5LCBtb2RlbCwgcGFyYW1zLCBfcmVxdWVzdE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0T3B0aW9ucyA9IF9yZXF1ZXN0T3B0aW9ucztcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLl9zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuaGlzdG9yeSkge1xuICAgICAgICAgICAgdmFsaWRhdGVDaGF0SGlzdG9yeShwYXJhbXMuaGlzdG9yeSk7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5ID0gcGFyYW1zLmhpc3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhdCBoaXN0b3J5IHNvIGZhci4gQmxvY2tlZCBwcm9tcHRzIGFyZSBub3QgYWRkZWQgdG8gaGlzdG9yeS5cbiAgICAgKiBCbG9ja2VkIGNhbmRpZGF0ZXMgYXJlIG5vdCBhZGRlZCB0byBoaXN0b3J5LCBub3IgYXJlIHRoZSBwcm9tcHRzIHRoYXRcbiAgICAgKiBnZW5lcmF0ZWQgdGhlbS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRIaXN0b3J5KCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zZW5kUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpc3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY2hhdCBtZXNzYWdlIGFuZCByZWNlaXZlcyBhIG5vbi1zdHJlYW1pbmdcbiAgICAgKiB7QGxpbmsgR2VuZXJhdGVDb250ZW50UmVzdWx0fS5cbiAgICAgKlxuICAgICAqIEZpZWxkcyBzZXQgaW4gdGhlIG9wdGlvbmFsIHtAbGluayBTaW5nbGVSZXF1ZXN0T3B0aW9uc30gcGFyYW1ldGVyIHdpbGxcbiAgICAgKiB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUge0BsaW5rIFJlcXVlc3RPcHRpb25zfSB2YWx1ZXMgcHJvdmlkZWQgYXQgdGhlXG4gICAgICogdGltZSBvZiB0aGUge0BsaW5rIEdvb2dsZUFJRmlsZU1hbmFnZXJ9IGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gZm9ybWF0TmV3Q29udGVudChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNhZmV0eVNldHRpbmdzOiAoX2EgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNhZmV0eVNldHRpbmdzLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZzogKF9iID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZW5lcmF0aW9uQ29uZmlnLFxuICAgICAgICAgICAgdG9vbHM6IChfYyA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHMsXG4gICAgICAgICAgICB0b29sQ29uZmlnOiAoX2QgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2xDb25maWcsXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbjogKF9lID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnQ6IChfZiA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FjaGVkQ29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBbLi4udGhpcy5faGlzdG9yeSwgbmV3Q29udGVudF0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYXRTZXNzaW9uUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JlcXVlc3RPcHRpb25zKSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBsZXQgZmluYWxSZXN1bHQ7XG4gICAgICAgIC8vIEFkZCBvbnRvIHRoZSBjaGFpbi5cbiAgICAgICAgdGhpcy5fc2VuZFByb21pc2UgPSB0aGlzLl9zZW5kUHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gZ2VuZXJhdGVDb250ZW50KHRoaXMuX2FwaUtleSwgdGhpcy5tb2RlbCwgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCwgY2hhdFNlc3Npb25SZXF1ZXN0T3B0aW9ucykpXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3BvbnNlLmNhbmRpZGF0ZXMgJiZcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKG5ld0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudCA9IE9iamVjdC5hc3NpZ24oeyBwYXJ0czogW10sIFxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBzZWVtcyB0byBjb21lIGJhY2sgd2l0aG91dCBhIHJvbGUgc2V0LlxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcIm1vZGVsXCIgfSwgKF9hID0gcmVzdWx0LnJlc3BvbnNlLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrRXJyb3JNZXNzYWdlID0gZm9ybWF0QmxvY2tFcnJvck1lc3NhZ2UocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBzZW5kTWVzc2FnZSgpIHdhcyB1bnN1Y2Nlc3NmdWwuICR7YmxvY2tFcnJvck1lc3NhZ2V9LiBJbnNwZWN0IHJlc3BvbnNlIG9iamVjdCBmb3IgZGV0YWlscy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRQcm9taXNlO1xuICAgICAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY2hhdCBtZXNzYWdlIGFuZCByZWNlaXZlcyB0aGUgcmVzcG9uc2UgYXMgYVxuICAgICAqIHtAbGluayBHZW5lcmF0ZUNvbnRlbnRTdHJlYW1SZXN1bHR9IGNvbnRhaW5pbmcgYW4gaXRlcmFibGUgc3RyZWFtXG4gICAgICogYW5kIGEgcmVzcG9uc2UgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEZpZWxkcyBzZXQgaW4gdGhlIG9wdGlvbmFsIHtAbGluayBTaW5nbGVSZXF1ZXN0T3B0aW9uc30gcGFyYW1ldGVyIHdpbGxcbiAgICAgKiB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUge0BsaW5rIFJlcXVlc3RPcHRpb25zfSB2YWx1ZXMgcHJvdmlkZWQgYXQgdGhlXG4gICAgICogdGltZSBvZiB0aGUge0BsaW5rIEdvb2dsZUFJRmlsZU1hbmFnZXJ9IGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gZm9ybWF0TmV3Q29udGVudChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNhZmV0eVNldHRpbmdzOiAoX2EgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNhZmV0eVNldHRpbmdzLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZzogKF9iID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZW5lcmF0aW9uQ29uZmlnLFxuICAgICAgICAgICAgdG9vbHM6IChfYyA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHMsXG4gICAgICAgICAgICB0b29sQ29uZmlnOiAoX2QgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2xDb25maWcsXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbjogKF9lID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnQ6IChfZiA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FjaGVkQ29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBbLi4udGhpcy5faGlzdG9yeSwgbmV3Q29udGVudF0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYXRTZXNzaW9uUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JlcXVlc3RPcHRpb25zKSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdHJlYW1Qcm9taXNlID0gZ2VuZXJhdGVDb250ZW50U3RyZWFtKHRoaXMuX2FwaUtleSwgdGhpcy5tb2RlbCwgZ2VuZXJhdGVDb250ZW50UmVxdWVzdCwgY2hhdFNlc3Npb25SZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIC8vIEFkZCBvbnRvIHRoZSBjaGFpbi5cbiAgICAgICAgdGhpcy5fc2VuZFByb21pc2UgPSB0aGlzLl9zZW5kUHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gc3RyZWFtUHJvbWlzZSlcbiAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBoYW5kbGVkIHRvIGF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb24sIGJ1dCBqdW1wXG4gICAgICAgICAgICAvLyB0byB0aGUgZmluYWwgY2F0Y2ggYmxvY2sgd2l0aCBhIGxhYmVsIHRvIG5vdCBsb2cgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIC5jYXRjaCgoX2lnbm9yZWQpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTSUxFTlRfRVJST1IpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHN0cmVhbVJlc3VsdCkgPT4gc3RyZWFtUmVzdWx0LnJlc3BvbnNlKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyAmJiByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2gobmV3Q29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBzZWVtcyB0byBjb21lIGJhY2sgd2l0aG91dCBhIHJvbGUgc2V0LlxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VDb250ZW50LnJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50LnJvbGUgPSBcIm1vZGVsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2tFcnJvck1lc3NhZ2UgPSBmb3JtYXRCbG9ja0Vycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihgc2VuZE1lc3NhZ2VTdHJlYW0oKSB3YXMgdW5zdWNjZXNzZnVsLiAke2Jsb2NrRXJyb3JNZXNzYWdlfS4gSW5zcGVjdCByZXNwb25zZSBvYmplY3QgZm9yIGRldGFpbHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBFcnJvcnMgaW4gc3RyZWFtUHJvbWlzZSBhcmUgYWxyZWFkeSBjYXRjaGFibGUgYnkgdGhlIHVzZXIgYXNcbiAgICAgICAgICAgIC8vIHN0cmVhbVByb21pc2UgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAvLyBBdm9pZCBkdXBsaWNhdGluZyB0aGUgZXJyb3IgbWVzc2FnZSBpbiBsb2dzLlxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSAhPT0gU0lMRU5UX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlcnMgZG8gbm90IGhhdmUgYWNjZXNzIHRvIF9zZW5kUHJvbWlzZSB0byBjYXRjaCBlcnJvcnNcbiAgICAgICAgICAgICAgICAvLyBkb3duc3RyZWFtIGZyb20gc3RyZWFtUHJvbWlzZSwgc28gdGhleSBzaG91bGQgbm90IHRocm93LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtUHJvbWlzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBjb3VudFRva2VucyhhcGlLZXksIG1vZGVsLCBwYXJhbXMsIHNpbmdsZVJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlTW9kZWxSZXF1ZXN0KG1vZGVsLCBUYXNrLkNPVU5UX1RPS0VOUywgYXBpS2V5LCBmYWxzZSwgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgc2luZ2xlUmVxdWVzdE9wdGlvbnMpO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbWJlZENvbnRlbnQoYXBpS2V5LCBtb2RlbCwgcGFyYW1zLCByZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZU1vZGVsUmVxdWVzdChtb2RlbCwgVGFzay5FTUJFRF9DT05URU5ULCBhcGlLZXksIGZhbHNlLCBKU09OLnN0cmluZ2lmeShwYXJhbXMpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhdGNoRW1iZWRDb250ZW50cyhhcGlLZXksIG1vZGVsLCBwYXJhbXMsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3QgcmVxdWVzdHNXaXRoTW9kZWwgPSBwYXJhbXMucmVxdWVzdHMubWFwKChyZXF1ZXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IG1vZGVsIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZU1vZGVsUmVxdWVzdChtb2RlbCwgVGFzay5CQVRDSF9FTUJFRF9DT05URU5UUywgYXBpS2V5LCBmYWxzZSwgSlNPTi5zdHJpbmdpZnkoeyByZXF1ZXN0czogcmVxdWVzdHNXaXRoTW9kZWwgfSksIHJlcXVlc3RPcHRpb25zKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDbGFzcyBmb3IgZ2VuZXJhdGl2ZSBtb2RlbCBBUElzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHZW5lcmF0aXZlTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSwgbW9kZWxQYXJhbXMsIF9yZXF1ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLl9yZXF1ZXN0T3B0aW9ucyA9IF9yZXF1ZXN0T3B0aW9ucztcbiAgICAgICAgaWYgKG1vZGVsUGFyYW1zLm1vZGVsLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICAgICAgLy8gTW9kZWxzIG1heSBiZSBuYW1lZCBcIm1vZGVscy9tb2RlbC1uYW1lXCIgb3IgXCJ0dW5lZE1vZGVscy9tb2RlbC1uYW1lXCJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbFBhcmFtcy5tb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHBhdGggaXMgbm90IGluY2x1ZGVkLCBhc3N1bWUgaXQncyBhIG5vbi10dW5lZCBtb2RlbC5cbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBgbW9kZWxzLyR7bW9kZWxQYXJhbXMubW9kZWx9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbmVyYXRpb25Db25maWcgPSBtb2RlbFBhcmFtcy5nZW5lcmF0aW9uQ29uZmlnIHx8IHt9O1xuICAgICAgICB0aGlzLnNhZmV0eVNldHRpbmdzID0gbW9kZWxQYXJhbXMuc2FmZXR5U2V0dGluZ3MgfHwgW107XG4gICAgICAgIHRoaXMudG9vbHMgPSBtb2RlbFBhcmFtcy50b29scztcbiAgICAgICAgdGhpcy50b29sQ29uZmlnID0gbW9kZWxQYXJhbXMudG9vbENvbmZpZztcbiAgICAgICAgdGhpcy5zeXN0ZW1JbnN0cnVjdGlvbiA9IGZvcm1hdFN5c3RlbUluc3RydWN0aW9uKG1vZGVsUGFyYW1zLnN5c3RlbUluc3RydWN0aW9uKTtcbiAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50ID0gbW9kZWxQYXJhbXMuY2FjaGVkQ29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBzaW5nbGUgbm9uLXN0cmVhbWluZyBjYWxsIHRvIHRoZSBtb2RlbFxuICAgICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGEgc2luZ2xlIHtAbGluayBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZX0uXG4gICAgICpcbiAgICAgKiBGaWVsZHMgc2V0IGluIHRoZSBvcHRpb25hbCB7QGxpbmsgU2luZ2xlUmVxdWVzdE9wdGlvbnN9IHBhcmFtZXRlciB3aWxsXG4gICAgICogdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhlIHtAbGluayBSZXF1ZXN0T3B0aW9uc30gdmFsdWVzIHByb3ZpZGVkIGF0IHRoZVxuICAgICAqIHRpbWUgb2YgdGhlIHtAbGluayBHb29nbGVBSUZpbGVNYW5hZ2VyfSBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnQocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEdlbmVyYXRlQ29udGVudElucHV0KHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNvbnRlbnQodGhpcy5hcGlLZXksIHRoaXMubW9kZWwsIE9iamVjdC5hc3NpZ24oeyBnZW5lcmF0aW9uQ29uZmlnOiB0aGlzLmdlbmVyYXRpb25Db25maWcsIHNhZmV0eVNldHRpbmdzOiB0aGlzLnNhZmV0eVNldHRpbmdzLCB0b29sczogdGhpcy50b29scywgdG9vbENvbmZpZzogdGhpcy50b29sQ29uZmlnLCBzeXN0ZW1JbnN0cnVjdGlvbjogdGhpcy5zeXN0ZW1JbnN0cnVjdGlvbiwgY2FjaGVkQ29udGVudDogKF9hID0gdGhpcy5jYWNoZWRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSB9LCBmb3JtYXR0ZWRQYXJhbXMpLCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgc2luZ2xlIHN0cmVhbWluZyBjYWxsIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAgICAgKiBjb250YWluaW5nIGFuIGl0ZXJhYmxlIHN0cmVhbSB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIGNodW5rcyBpbiB0aGVcbiAgICAgKiBzdHJlYW1pbmcgcmVzcG9uc2UgYXMgd2VsbCBhcyBhIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBmaW5hbFxuICAgICAqIGFnZ3JlZ2F0ZWQgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBGaWVsZHMgc2V0IGluIHRoZSBvcHRpb25hbCB7QGxpbmsgU2luZ2xlUmVxdWVzdE9wdGlvbnN9IHBhcmFtZXRlciB3aWxsXG4gICAgICogdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhlIHtAbGluayBSZXF1ZXN0T3B0aW9uc30gdmFsdWVzIHByb3ZpZGVkIGF0IHRoZVxuICAgICAqIHRpbWUgb2YgdGhlIHtAbGluayBHb29nbGVBSUZpbGVNYW5hZ2VyfSBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW0ocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEdlbmVyYXRlQ29udGVudElucHV0KHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNvbnRlbnRTdHJlYW0odGhpcy5hcGlLZXksIHRoaXMubW9kZWwsIE9iamVjdC5hc3NpZ24oeyBnZW5lcmF0aW9uQ29uZmlnOiB0aGlzLmdlbmVyYXRpb25Db25maWcsIHNhZmV0eVNldHRpbmdzOiB0aGlzLnNhZmV0eVNldHRpbmdzLCB0b29sczogdGhpcy50b29scywgdG9vbENvbmZpZzogdGhpcy50b29sQ29uZmlnLCBzeXN0ZW1JbnN0cnVjdGlvbjogdGhpcy5zeXN0ZW1JbnN0cnVjdGlvbiwgY2FjaGVkQ29udGVudDogKF9hID0gdGhpcy5jYWNoZWRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSB9LCBmb3JtYXR0ZWRQYXJhbXMpLCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcge0BsaW5rIENoYXRTZXNzaW9ufSBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCBmb3JcbiAgICAgKiBtdWx0aS10dXJuIGNoYXRzLlxuICAgICAqL1xuICAgIHN0YXJ0Q2hhdChzdGFydENoYXRQYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gbmV3IENoYXRTZXNzaW9uKHRoaXMuYXBpS2V5LCB0aGlzLm1vZGVsLCBPYmplY3QuYXNzaWduKHsgZ2VuZXJhdGlvbkNvbmZpZzogdGhpcy5nZW5lcmF0aW9uQ29uZmlnLCBzYWZldHlTZXR0aW5nczogdGhpcy5zYWZldHlTZXR0aW5ncywgdG9vbHM6IHRoaXMudG9vbHMsIHRvb2xDb25maWc6IHRoaXMudG9vbENvbmZpZywgc3lzdGVtSW5zdHJ1Y3Rpb246IHRoaXMuc3lzdGVtSW5zdHJ1Y3Rpb24sIGNhY2hlZENvbnRlbnQ6IChfYSA9IHRoaXMuY2FjaGVkQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUgfSwgc3RhcnRDaGF0UGFyYW1zKSwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIHRva2VucyBpbiB0aGUgcHJvdmlkZWQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyBzZXQgaW4gdGhlIG9wdGlvbmFsIHtAbGluayBTaW5nbGVSZXF1ZXN0T3B0aW9uc30gcGFyYW1ldGVyIHdpbGxcbiAgICAgKiB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUge0BsaW5rIFJlcXVlc3RPcHRpb25zfSB2YWx1ZXMgcHJvdmlkZWQgYXQgdGhlXG4gICAgICogdGltZSBvZiB0aGUge0BsaW5rIEdvb2dsZUFJRmlsZU1hbmFnZXJ9IGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkUGFyYW1zID0gZm9ybWF0Q291bnRUb2tlbnNJbnB1dChyZXF1ZXN0LCB7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGdlbmVyYXRpb25Db25maWc6IHRoaXMuZ2VuZXJhdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIHNhZmV0eVNldHRpbmdzOiB0aGlzLnNhZmV0eVNldHRpbmdzLFxuICAgICAgICAgICAgdG9vbHM6IHRoaXMudG9vbHMsXG4gICAgICAgICAgICB0b29sQ29uZmlnOiB0aGlzLnRvb2xDb25maWcsXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbjogdGhpcy5zeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgICAgIGNhY2hlZENvbnRlbnQ6IHRoaXMuY2FjaGVkQ29udGVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpdmVNb2RlbFJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0T3B0aW9ucyksIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNvdW50VG9rZW5zKHRoaXMuYXBpS2V5LCB0aGlzLm1vZGVsLCBmb3JtYXR0ZWRQYXJhbXMsIGdlbmVyYXRpdmVNb2RlbFJlcXVlc3RPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1iZWRzIHRoZSBwcm92aWRlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogRmllbGRzIHNldCBpbiB0aGUgb3B0aW9uYWwge0BsaW5rIFNpbmdsZVJlcXVlc3RPcHRpb25zfSBwYXJhbWV0ZXIgd2lsbFxuICAgICAqIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoZSB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9IHZhbHVlcyBwcm92aWRlZCBhdCB0aGVcbiAgICAgKiB0aW1lIG9mIHRoZSB7QGxpbmsgR29vZ2xlQUlGaWxlTWFuYWdlcn0gaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRDb250ZW50KHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkUGFyYW1zID0gZm9ybWF0RW1iZWRDb250ZW50SW5wdXQocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpdmVNb2RlbFJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0T3B0aW9ucyksIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkQ29udGVudCh0aGlzLmFwaUtleSwgdGhpcy5tb2RlbCwgZm9ybWF0dGVkUGFyYW1zLCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtYmVkcyBhbiBhcnJheSBvZiB7QGxpbmsgRW1iZWRDb250ZW50UmVxdWVzdH1zLlxuICAgICAqXG4gICAgICogRmllbGRzIHNldCBpbiB0aGUgb3B0aW9uYWwge0BsaW5rIFNpbmdsZVJlcXVlc3RPcHRpb25zfSBwYXJhbWV0ZXIgd2lsbFxuICAgICAqIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoZSB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9IHZhbHVlcyBwcm92aWRlZCBhdCB0aGVcbiAgICAgKiB0aW1lIG9mIHRoZSB7QGxpbmsgR29vZ2xlQUlGaWxlTWFuYWdlcn0gaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgYmF0Y2hFbWJlZENvbnRlbnRzKGJhdGNoRW1iZWRDb250ZW50UmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBnZW5lcmF0aXZlTW9kZWxSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmVxdWVzdE9wdGlvbnMpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYXRjaEVtYmVkQ29udGVudHModGhpcy5hcGlLZXksIHRoaXMubW9kZWwsIGJhdGNoRW1iZWRDb250ZW50UmVxdWVzdCwgZ2VuZXJhdGl2ZU1vZGVsUmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVG9wLWxldmVsIGNsYXNzIGZvciB0aGlzIFNES1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBHb29nbGVHZW5lcmF0aXZlQUkge1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSkge1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHtAbGluayBHZW5lcmF0aXZlTW9kZWx9IGluc3RhbmNlIGZvciB0aGUgcHJvdmlkZWQgbW9kZWwgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRHZW5lcmF0aXZlTW9kZWwobW9kZWxQYXJhbXMsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGlmICghbW9kZWxQYXJhbXMubW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlFcnJvcihgTXVzdCBwcm92aWRlIGEgbW9kZWwgbmFtZS4gYCArXG4gICAgICAgICAgICAgICAgYEV4YW1wbGU6IGdlbmFpLmdldEdlbmVyYXRpdmVNb2RlbCh7IG1vZGVsOiAnbXktbW9kZWwtbmFtZScgfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRpdmVNb2RlbCh0aGlzLmFwaUtleSwgbW9kZWxQYXJhbXMsIHJlcXVlc3RPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBHZW5lcmF0aXZlTW9kZWx9IGluc3RhbmNlIGZyb20gcHJvdmlkZWQgY29udGVudCBjYWNoZS5cbiAgICAgKi9cbiAgICBnZXRHZW5lcmF0aXZlTW9kZWxGcm9tQ2FjaGVkQ29udGVudChjYWNoZWRDb250ZW50LCByZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICBpZiAoIWNhY2hlZENvbnRlbnQubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdvb2dsZUdlbmVyYXRpdmVBSVJlcXVlc3RJbnB1dEVycm9yKFwiQ2FjaGVkIGNvbnRlbnQgbXVzdCBjb250YWluIGEgYG5hbWVgIGZpZWxkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hlZENvbnRlbnQubW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHb29nbGVHZW5lcmF0aXZlQUlSZXF1ZXN0SW5wdXRFcnJvcihcIkNhY2hlZCBjb250ZW50IG11c3QgY29udGFpbiBhIGBtb2RlbGAgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsUGFyYW1zRnJvbUNhY2hlID0ge1xuICAgICAgICAgICAgbW9kZWw6IGNhY2hlZENvbnRlbnQubW9kZWwsXG4gICAgICAgICAgICB0b29sczogY2FjaGVkQ29udGVudC50b29scyxcbiAgICAgICAgICAgIHRvb2xDb25maWc6IGNhY2hlZENvbnRlbnQudG9vbENvbmZpZyxcbiAgICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uOiBjYWNoZWRDb250ZW50LnN5c3RlbUluc3RydWN0aW9uLFxuICAgICAgICAgICAgY2FjaGVkQ29udGVudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aXZlTW9kZWwodGhpcy5hcGlLZXksIG1vZGVsUGFyYW1zRnJvbUNhY2hlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxufVxuXG5leHBvcnRzLkNoYXRTZXNzaW9uID0gQ2hhdFNlc3Npb247XG5leHBvcnRzLkdlbmVyYXRpdmVNb2RlbCA9IEdlbmVyYXRpdmVNb2RlbDtcbmV4cG9ydHMuR29vZ2xlR2VuZXJhdGl2ZUFJID0gR29vZ2xlR2VuZXJhdGl2ZUFJO1xuZXhwb3J0cy5Hb29nbGVHZW5lcmF0aXZlQUlFcnJvciA9IEdvb2dsZUdlbmVyYXRpdmVBSUVycm9yO1xuZXhwb3J0cy5Hb29nbGVHZW5lcmF0aXZlQUlGZXRjaEVycm9yID0gR29vZ2xlR2VuZXJhdGl2ZUFJRmV0Y2hFcnJvcjtcbmV4cG9ydHMuR29vZ2xlR2VuZXJhdGl2ZUFJUmVxdWVzdElucHV0RXJyb3IgPSBHb29nbGVHZW5lcmF0aXZlQUlSZXF1ZXN0SW5wdXRFcnJvcjtcbmV4cG9ydHMuR29vZ2xlR2VuZXJhdGl2ZUFJUmVzcG9uc2VFcnJvciA9IEdvb2dsZUdlbmVyYXRpdmVBSVJlc3BvbnNlRXJyb3I7XG5leHBvcnRzLlBPU1NJQkxFX1JPTEVTID0gUE9TU0lCTEVfUk9MRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/googleai/node_modules/@google/generative-ai/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/document.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar document_exports = {};\n__export(document_exports, {\n  Document: () => Document,\n  DocumentDataSchema: () => DocumentDataSchema,\n  MediaPartSchema: () => MediaPartSchema,\n  PartSchema: () => PartSchema,\n  TextPartSchema: () => TextPartSchema\n});\nmodule.exports = __toCommonJS(document_exports);\nvar import_zod = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nconst EmptyPartSchema = import_zod.default.object({\n  text: import_zod.default.never().optional(),\n  media: import_zod.default.never().optional()\n});\nconst TextPartSchema = EmptyPartSchema.extend({\n  /** The text of the document. */\n  text: import_zod.default.string()\n});\nconst MediaPartSchema = EmptyPartSchema.extend({\n  media: import_zod.default.object({\n    /** The media content type. Inferred from data uri if not provided. */\n    contentType: import_zod.default.string().optional(),\n    /** A `data:` or `https:` uri containing the media content.  */\n    url: import_zod.default.string()\n  })\n});\nconst PartSchema = import_zod.default.union([TextPartSchema, MediaPartSchema]);\nconst DocumentDataSchema = import_zod.default.object({\n  content: import_zod.default.array(PartSchema),\n  metadata: import_zod.default.record(import_zod.default.string(), import_zod.default.any()).optional()\n});\nclass Document {\n  constructor(data) {\n    this.content = data.content;\n    this.metadata = data.metadata;\n  }\n  static fromText(text, metadata) {\n    return new Document({\n      content: [{ text }],\n      metadata\n    });\n  }\n  /**\n   * Concatenates all `text` parts present in the document with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Returns the first media part detected in the document. Useful for extracting\n   * (for example) an image.\n   * @returns The first detected `media` part in the document.\n   */\n  media() {\n    var _a;\n    return ((_a = this.content.find((part) => part.media)) == null ? void 0 : _a.media) || null;\n  }\n  toJSON() {\n    return {\n      content: this.content,\n      metadata: this.metadata\n    };\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=document.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9kb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDBEQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU1MO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvZG9jdW1lbnQuanM/ZGY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZG9jdW1lbnRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZG9jdW1lbnRfZXhwb3J0cywge1xuICBEb2N1bWVudDogKCkgPT4gRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYTogKCkgPT4gRG9jdW1lbnREYXRhU2NoZW1hLFxuICBNZWRpYVBhcnRTY2hlbWE6ICgpID0+IE1lZGlhUGFydFNjaGVtYSxcbiAgUGFydFNjaGVtYTogKCkgPT4gUGFydFNjaGVtYSxcbiAgVGV4dFBhcnRTY2hlbWE6ICgpID0+IFRleHRQYXJ0U2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGRvY3VtZW50X2V4cG9ydHMpO1xudmFyIGltcG9ydF96b2QgPSBfX3RvRVNNKHJlcXVpcmUoXCJ6b2RcIikpO1xuY29uc3QgRW1wdHlQYXJ0U2NoZW1hID0gaW1wb3J0X3pvZC5kZWZhdWx0Lm9iamVjdCh7XG4gIHRleHQ6IGltcG9ydF96b2QuZGVmYXVsdC5uZXZlcigpLm9wdGlvbmFsKCksXG4gIG1lZGlhOiBpbXBvcnRfem9kLmRlZmF1bHQubmV2ZXIoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFRleHRQYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIC8qKiBUaGUgdGV4dCBvZiB0aGUgZG9jdW1lbnQuICovXG4gIHRleHQ6IGltcG9ydF96b2QuZGVmYXVsdC5zdHJpbmcoKVxufSk7XG5jb25zdCBNZWRpYVBhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgbWVkaWE6IGltcG9ydF96b2QuZGVmYXVsdC5vYmplY3Qoe1xuICAgIC8qKiBUaGUgbWVkaWEgY29udGVudCB0eXBlLiBJbmZlcnJlZCBmcm9tIGRhdGEgdXJpIGlmIG5vdCBwcm92aWRlZC4gKi9cbiAgICBjb250ZW50VHlwZTogaW1wb3J0X3pvZC5kZWZhdWx0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgLyoqIEEgYGRhdGE6YCBvciBgaHR0cHM6YCB1cmkgY29udGFpbmluZyB0aGUgbWVkaWEgY29udGVudC4gICovXG4gICAgdXJsOiBpbXBvcnRfem9kLmRlZmF1bHQuc3RyaW5nKClcbiAgfSlcbn0pO1xuY29uc3QgUGFydFNjaGVtYSA9IGltcG9ydF96b2QuZGVmYXVsdC51bmlvbihbVGV4dFBhcnRTY2hlbWEsIE1lZGlhUGFydFNjaGVtYV0pO1xuY29uc3QgRG9jdW1lbnREYXRhU2NoZW1hID0gaW1wb3J0X3pvZC5kZWZhdWx0Lm9iamVjdCh7XG4gIGNvbnRlbnQ6IGltcG9ydF96b2QuZGVmYXVsdC5hcnJheShQYXJ0U2NoZW1hKSxcbiAgbWV0YWRhdGE6IGltcG9ydF96b2QuZGVmYXVsdC5yZWNvcmQoaW1wb3J0X3pvZC5kZWZhdWx0LnN0cmluZygpLCBpbXBvcnRfem9kLmRlZmF1bHQuYW55KCkpLm9wdGlvbmFsKClcbn0pO1xuY2xhc3MgRG9jdW1lbnQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5jb250ZW50ID0gZGF0YS5jb250ZW50O1xuICAgIHRoaXMubWV0YWRhdGEgPSBkYXRhLm1ldGFkYXRhO1xuICB9XG4gIHN0YXRpYyBmcm9tVGV4dCh0ZXh0LCBtZXRhZGF0YSkge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQoe1xuICAgICAgY29udGVudDogW3sgdGV4dCB9XSxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgYHRleHRgIHBhcnRzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IHdpdGggbm8gZGVsaW1pdGVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyBvZiBhbGwgY29uY2F0ZW5hdGVkIHRleHQgcGFydHMuXG4gICAqL1xuICB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBwYXJ0LnRleHQgfHwgXCJcIikuam9pbihcIlwiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgbWVkaWEgcGFydCBkZXRlY3RlZCBpbiB0aGUgZG9jdW1lbnQuIFVzZWZ1bCBmb3IgZXh0cmFjdGluZ1xuICAgKiAoZm9yIGV4YW1wbGUpIGFuIGltYWdlLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgZGV0ZWN0ZWQgYG1lZGlhYCBwYXJ0IGluIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIG1lZGlhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuY29udGVudC5maW5kKChwYXJ0KSA9PiBwYXJ0Lm1lZGlhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1lZGlhKSB8fCBudWxsO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGFcbiAgICB9O1xuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYSxcbiAgTWVkaWFQYXJ0U2NoZW1hLFxuICBQYXJ0U2NoZW1hLFxuICBUZXh0UGFydFNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/embedder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar embedder_exports = {};\n__export(embedder_exports, {\n  EmbedderInfoSchema: () => EmbedderInfoSchema,\n  EmbeddingSchema: () => EmbeddingSchema,\n  defineEmbedder: () => defineEmbedder,\n  embed: () => embed,\n  embedMany: () => embedMany,\n  embedderRef: () => embedderRef\n});\nmodule.exports = __toCommonJS(embedder_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nconst EmbeddingSchema = z.array(z.number());\nconst EmbedRequestSchema = z.object({\n  input: z.array(import_document.DocumentDataSchema),\n  options: z.any().optional()\n});\nconst EmbedResponseSchema = z.object({\n  embeddings: z.array(z.object({ embedding: EmbeddingSchema }))\n  // TODO: stats, etc.\n});\nfunction withMetadata(embedder, configSchema) {\n  const withMeta = embedder;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction defineEmbedder(options, runner) {\n  const embedder = (0, import_core.defineAction)(\n    {\n      actionType: \"embedder\",\n      name: options.name,\n      inputSchema: options.configSchema ? EmbedRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : EmbedRequestSchema,\n      outputSchema: EmbedResponseSchema,\n      metadata: {\n        type: \"embedder\",\n        info: options.info\n      }\n    },\n    (i) => runner(\n      i.input.map((dd) => new import_document.Document(dd)),\n      i.options\n    )\n  );\n  const ewm = withMetadata(\n    embedder,\n    options.configSchema\n  );\n  return ewm;\n}\nfunction embed(params) {\n  return __async(this, null, function* () {\n    let embedder;\n    if (typeof params.embedder === \"string\") {\n      embedder = yield (0, import_registry.lookupAction)(`/embedder/${params.embedder}`);\n    } else if (Object.hasOwnProperty.call(params.embedder, \"info\")) {\n      embedder = yield (0, import_registry.lookupAction)(\n        `/embedder/${params.embedder.name}`\n      );\n    } else {\n      embedder = params.embedder;\n    }\n    if (!embedder) {\n      throw new Error(\"Unable to utilize the provided embedder\");\n    }\n    const response = yield embedder({\n      input: typeof params.content === \"string\" ? [import_document.Document.fromText(params.content, params.metadata)] : [params.content],\n      options: params.options\n    });\n    return response.embeddings[0].embedding;\n  });\n}\nfunction embedMany(params) {\n  return __async(this, null, function* () {\n    let embedder;\n    if (typeof params.embedder === \"string\") {\n      embedder = yield (0, import_registry.lookupAction)(`/embedder/${params.embedder}`);\n    } else if (Object.hasOwnProperty.call(params.embedder, \"info\")) {\n      embedder = yield (0, import_registry.lookupAction)(\n        `/embedder/${params.embedder.name}`\n      );\n    } else {\n      embedder = params.embedder;\n    }\n    if (!embedder) {\n      throw new Error(\"Unable to utilize the provided embedder\");\n    }\n    const response = yield embedder({\n      input: params.content.map(\n        (i) => typeof i === \"string\" ? import_document.Document.fromText(i, params.metadata) : i\n      ),\n      options: params.options\n    });\n    return response.embeddings;\n  });\n}\nconst EmbedderInfoSchema = z.object({\n  /** Friendly label for this model (e.g. \"Google AI - Gemini Pro\") */\n  label: z.string().optional(),\n  /** Supported model capabilities. */\n  supports: z.object({\n    /** Model can input this type of data. */\n    input: z.array(z.enum([\"text\", \"image\"])).optional(),\n    /** Model can support multiple languages */\n    multilingual: z.boolean().optional()\n  }).optional(),\n  /** Embedding dimension */\n  dimensions: z.number().optional()\n});\nfunction embedderRef(options) {\n  return __spreadValues({}, options);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=embedder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9lbWJlZGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMsMERBQUs7QUFDN0Isc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEYsTUFBTTtBQUNOO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGLE1BQU07QUFDTjtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvZW1iZWRkZXIuanM/MTgzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGVtYmVkZGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVtYmVkZGVyX2V4cG9ydHMsIHtcbiAgRW1iZWRkZXJJbmZvU2NoZW1hOiAoKSA9PiBFbWJlZGRlckluZm9TY2hlbWEsXG4gIEVtYmVkZGluZ1NjaGVtYTogKCkgPT4gRW1iZWRkaW5nU2NoZW1hLFxuICBkZWZpbmVFbWJlZGRlcjogKCkgPT4gZGVmaW5lRW1iZWRkZXIsXG4gIGVtYmVkOiAoKSA9PiBlbWJlZCxcbiAgZW1iZWRNYW55OiAoKSA9PiBlbWJlZE1hbnksXG4gIGVtYmVkZGVyUmVmOiAoKSA9PiBlbWJlZGRlclJlZlxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhlbWJlZGRlcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X3JlZ2lzdHJ5ID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9yZWdpc3RyeVwiKTtcbnZhciB6ID0gX190b0VTTShyZXF1aXJlKFwiem9kXCIpKTtcbnZhciBpbXBvcnRfZG9jdW1lbnQgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbmNvbnN0IEVtYmVkZGluZ1NjaGVtYSA9IHouYXJyYXkoei5udW1iZXIoKSk7XG5jb25zdCBFbWJlZFJlcXVlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGlucHV0OiB6LmFycmF5KGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudERhdGFTY2hlbWEpLFxuICBvcHRpb25zOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgRW1iZWRSZXNwb25zZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgZW1iZWRkaW5nczogei5hcnJheSh6Lm9iamVjdCh7IGVtYmVkZGluZzogRW1iZWRkaW5nU2NoZW1hIH0pKVxuICAvLyBUT0RPOiBzdGF0cywgZXRjLlxufSk7XG5mdW5jdGlvbiB3aXRoTWV0YWRhdGEoZW1iZWRkZXIsIGNvbmZpZ1NjaGVtYSkge1xuICBjb25zdCB3aXRoTWV0YSA9IGVtYmVkZGVyO1xuICB3aXRoTWV0YS5fX2NvbmZpZ1NjaGVtYSA9IGNvbmZpZ1NjaGVtYTtcbiAgcmV0dXJuIHdpdGhNZXRhO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1iZWRkZXIob3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IGVtYmVkZGVyID0gKDAsIGltcG9ydF9jb3JlLmRlZmluZUFjdGlvbikoXG4gICAge1xuICAgICAgYWN0aW9uVHlwZTogXCJlbWJlZGRlclwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IG9wdGlvbnMuY29uZmlnU2NoZW1hID8gRW1iZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pIDogRW1iZWRSZXF1ZXN0U2NoZW1hLFxuICAgICAgb3V0cHV0U2NoZW1hOiBFbWJlZFJlc3BvbnNlU2NoZW1hLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJlbWJlZGRlclwiLFxuICAgICAgICBpbmZvOiBvcHRpb25zLmluZm9cbiAgICAgIH1cbiAgICB9LFxuICAgIChpKSA9PiBydW5uZXIoXG4gICAgICBpLmlucHV0Lm1hcCgoZGQpID0+IG5ldyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQoZGQpKSxcbiAgICAgIGkub3B0aW9uc1xuICAgIClcbiAgKTtcbiAgY29uc3QgZXdtID0gd2l0aE1ldGFkYXRhKFxuICAgIGVtYmVkZGVyLFxuICAgIG9wdGlvbnMuY29uZmlnU2NoZW1hXG4gICk7XG4gIHJldHVybiBld207XG59XG5mdW5jdGlvbiBlbWJlZChwYXJhbXMpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZW1iZWRkZXI7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZW1iZWRkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGVtYmVkZGVyID0geWllbGQgKDAsIGltcG9ydF9yZWdpc3RyeS5sb29rdXBBY3Rpb24pKGAvZW1iZWRkZXIvJHtwYXJhbXMuZW1iZWRkZXJ9YCk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMuZW1iZWRkZXIsIFwiaW5mb1wiKSkge1xuICAgICAgZW1iZWRkZXIgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoXG4gICAgICAgIGAvZW1iZWRkZXIvJHtwYXJhbXMuZW1iZWRkZXIubmFtZX1gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWJlZGRlciA9IHBhcmFtcy5lbWJlZGRlcjtcbiAgICB9XG4gICAgaWYgKCFlbWJlZGRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHV0aWxpemUgdGhlIHByb3ZpZGVkIGVtYmVkZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGVtYmVkZGVyKHtcbiAgICAgIGlucHV0OiB0eXBlb2YgcGFyYW1zLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBbaW1wb3J0X2RvY3VtZW50LkRvY3VtZW50LmZyb21UZXh0KHBhcmFtcy5jb250ZW50LCBwYXJhbXMubWV0YWRhdGEpXSA6IFtwYXJhbXMuY29udGVudF0sXG4gICAgICBvcHRpb25zOiBwYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5lbWJlZGRpbmdzWzBdLmVtYmVkZGluZztcbiAgfSk7XG59XG5mdW5jdGlvbiBlbWJlZE1hbnkocGFyYW1zKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGVtYmVkZGVyO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmVtYmVkZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlbWJlZGRlciA9IHlpZWxkICgwLCBpbXBvcnRfcmVnaXN0cnkubG9va3VwQWN0aW9uKShgL2VtYmVkZGVyLyR7cGFyYW1zLmVtYmVkZGVyfWApO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLmVtYmVkZGVyLCBcImluZm9cIikpIHtcbiAgICAgIGVtYmVkZGVyID0geWllbGQgKDAsIGltcG9ydF9yZWdpc3RyeS5sb29rdXBBY3Rpb24pKFxuICAgICAgICBgL2VtYmVkZGVyLyR7cGFyYW1zLmVtYmVkZGVyLm5hbWV9YFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1iZWRkZXIgPSBwYXJhbXMuZW1iZWRkZXI7XG4gICAgfVxuICAgIGlmICghZW1iZWRkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB1dGlsaXplIHRoZSBwcm92aWRlZCBlbWJlZGRlclwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBlbWJlZGRlcih7XG4gICAgICBpbnB1dDogcGFyYW1zLmNvbnRlbnQubWFwKFxuICAgICAgICAoaSkgPT4gdHlwZW9mIGkgPT09IFwic3RyaW5nXCIgPyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQuZnJvbVRleHQoaSwgcGFyYW1zLm1ldGFkYXRhKSA6IGlcbiAgICAgICksXG4gICAgICBvcHRpb25zOiBwYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5lbWJlZGRpbmdzO1xuICB9KTtcbn1cbmNvbnN0IEVtYmVkZGVySW5mb1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgLyoqIEZyaWVuZGx5IGxhYmVsIGZvciB0aGlzIG1vZGVsIChlLmcuIFwiR29vZ2xlIEFJIC0gR2VtaW5pIFByb1wiKSAqL1xuICBsYWJlbDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAvKiogU3VwcG9ydGVkIG1vZGVsIGNhcGFiaWxpdGllcy4gKi9cbiAgc3VwcG9ydHM6IHoub2JqZWN0KHtcbiAgICAvKiogTW9kZWwgY2FuIGlucHV0IHRoaXMgdHlwZSBvZiBkYXRhLiAqL1xuICAgIGlucHV0OiB6LmFycmF5KHouZW51bShbXCJ0ZXh0XCIsIFwiaW1hZ2VcIl0pKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gc3VwcG9ydCBtdWx0aXBsZSBsYW5ndWFnZXMgKi9cbiAgICBtdWx0aWxpbmd1YWw6IHouYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKSxcbiAgLyoqIEVtYmVkZGluZyBkaW1lbnNpb24gKi9cbiAgZGltZW5zaW9uczogei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcbmZ1bmN0aW9uIGVtYmVkZGVyUmVmKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBFbWJlZGRlckluZm9TY2hlbWEsXG4gIEVtYmVkZGluZ1NjaGVtYSxcbiAgZGVmaW5lRW1iZWRkZXIsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGVtYmVkZGVyUmVmXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/evaluator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar evaluator_exports = {};\n__export(evaluator_exports, {\n  ATTR_PREFIX: () => ATTR_PREFIX,\n  BaseDataPointSchema: () => BaseDataPointSchema,\n  EVALUATOR_METADATA_KEY_DEFINITION: () => EVALUATOR_METADATA_KEY_DEFINITION,\n  EVALUATOR_METADATA_KEY_DISPLAY_NAME: () => EVALUATOR_METADATA_KEY_DISPLAY_NAME,\n  EVALUATOR_METADATA_KEY_IS_BILLED: () => EVALUATOR_METADATA_KEY_IS_BILLED,\n  EvalResponseSchema: () => EvalResponseSchema,\n  EvalResponsesSchema: () => EvalResponsesSchema,\n  EvaluatorInfoSchema: () => EvaluatorInfoSchema,\n  SPAN_STATE_ATTR: () => SPAN_STATE_ATTR,\n  ScoreSchema: () => ScoreSchema,\n  defineEvaluator: () => defineEvaluator,\n  evaluate: () => evaluate,\n  evaluatorRef: () => evaluatorRef\n});\nmodule.exports = __toCommonJS(evaluator_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_logging = __webpack_require__(/*! @genkit-ai/core/logging */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nconst ATTR_PREFIX = \"genkit\";\nconst SPAN_STATE_ATTR = ATTR_PREFIX + \":state\";\nconst BaseDataPointSchema = z.object({\n  input: z.unknown(),\n  output: z.unknown().optional(),\n  context: z.array(z.unknown()).optional(),\n  reference: z.unknown().optional(),\n  testCaseId: z.string().optional(),\n  traceIds: z.array(z.string()).optional()\n});\nconst ScoreSchema = z.object({\n  score: z.union([z.number(), z.string(), z.boolean()]).optional(),\n  // TODO: use StatusSchema\n  error: z.string().optional(),\n  details: z.object({\n    reasoning: z.string().optional()\n  }).passthrough().optional()\n});\nconst EVALUATOR_METADATA_KEY_DISPLAY_NAME = \"evaluatorDisplayName\";\nconst EVALUATOR_METADATA_KEY_DEFINITION = \"evaluatorDefinition\";\nconst EVALUATOR_METADATA_KEY_IS_BILLED = \"evaluatorIsBilled\";\nconst EvalResponseSchema = z.object({\n  sampleIndex: z.number().optional(),\n  testCaseId: z.string().optional(),\n  traceId: z.string().optional(),\n  spanId: z.string().optional(),\n  evaluation: ScoreSchema\n});\nconst EvalResponsesSchema = z.array(EvalResponseSchema);\nfunction withMetadata(evaluator, dataPointType, configSchema) {\n  const withMeta = evaluator;\n  withMeta.__dataPointType = dataPointType;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nconst EvalRequestSchema = z.object({\n  dataset: z.array(BaseDataPointSchema),\n  options: z.unknown()\n});\nfunction defineEvaluator(options, runner) {\n  var _a;\n  const metadata = {};\n  metadata[EVALUATOR_METADATA_KEY_IS_BILLED] = options.isBilled == void 0 ? true : options.isBilled;\n  metadata[EVALUATOR_METADATA_KEY_DISPLAY_NAME] = options.displayName;\n  metadata[EVALUATOR_METADATA_KEY_DEFINITION] = options.definition;\n  const evaluator = (0, import_core.defineAction)(\n    {\n      actionType: \"evaluator\",\n      name: options.name,\n      inputSchema: EvalRequestSchema.extend({\n        dataset: options.dataPointType ? z.array(options.dataPointType) : z.array(BaseDataPointSchema),\n        options: (_a = options.configSchema) != null ? _a : z.unknown(),\n        evalRunId: z.string()\n      }),\n      outputSchema: EvalResponsesSchema,\n      metadata\n    },\n    (i) => __async(this, null, function* () {\n      let evalResponses = [];\n      for (let index = 0; index < i.dataset.length; index++) {\n        const datapoint = i.dataset[index];\n        try {\n          yield (0, import_tracing.runInNewSpan)(\n            {\n              metadata: {\n                name: `Test Case ${datapoint.testCaseId}`,\n                metadata: { \"evaluator:evalRunId\": i.evalRunId }\n              },\n              labels: {\n                [import_tracing.SPAN_TYPE_ATTR]: \"evaluator\"\n              }\n            },\n            (metadata2, otSpan) => __async(this, null, function* () {\n              const spanId = otSpan.spanContext().spanId;\n              const traceId = otSpan.spanContext().traceId;\n              try {\n                metadata2.input = {\n                  input: datapoint.input,\n                  output: datapoint.output,\n                  context: datapoint.context\n                };\n                const testCaseOutput = yield runner(datapoint, i.options);\n                testCaseOutput.sampleIndex = index;\n                testCaseOutput.spanId = spanId;\n                testCaseOutput.traceId = traceId;\n                metadata2.output = testCaseOutput;\n                evalResponses.push(testCaseOutput);\n                return testCaseOutput;\n              } catch (e) {\n                evalResponses.push({\n                  sampleIndex: index,\n                  spanId,\n                  traceId,\n                  testCaseId: datapoint.testCaseId,\n                  evaluation: {\n                    error: `Evaluation of test case ${datapoint.testCaseId} failed: \n${e.stack}`\n                  }\n                });\n                throw e;\n              }\n            })\n          );\n        } catch (e) {\n          import_logging.logger.error(\n            `Evaluation of test case ${datapoint.testCaseId} failed: \n${e.stack}`\n          );\n          continue;\n        }\n      }\n      return evalResponses;\n    })\n  );\n  const ewm = withMetadata(\n    evaluator,\n    options.dataPointType,\n    options.configSchema\n  );\n  return ewm;\n}\nfunction evaluate(params) {\n  return __async(this, null, function* () {\n    let evaluator;\n    if (typeof params.evaluator === \"string\") {\n      evaluator = yield (0, import_registry.lookupAction)(`/evaluator/${params.evaluator}`);\n    } else if (Object.hasOwnProperty.call(params.evaluator, \"info\")) {\n      evaluator = yield (0, import_registry.lookupAction)(`/evaluator/${params.evaluator.name}`);\n    } else {\n      evaluator = params.evaluator;\n    }\n    if (!evaluator) {\n      throw new Error(\"Unable to utilize the provided evaluator\");\n    }\n    return yield evaluator({\n      dataset: params.dataset,\n      options: params.options\n    });\n  });\n}\nconst EvaluatorInfoSchema = z.object({\n  /** Friendly label for this evaluator */\n  label: z.string().optional(),\n  metrics: z.array(z.string())\n});\nfunction evaluatorRef(options) {\n  return __spreadValues({}, options);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=evaluator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9ldmFsdWF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDdEQsc0JBQXNCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3hELHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELDRCQUE0QjtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUUsRUFBRSxRQUFRO0FBQ1Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsRUFBRSxRQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGLE1BQU07QUFDTix3RUFBd0Usc0JBQXNCO0FBQzlGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxNQUFNLENBY0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9ldmFsdWF0b3IuanM/MTdmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGV2YWx1YXRvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChldmFsdWF0b3JfZXhwb3J0cywge1xuICBBVFRSX1BSRUZJWDogKCkgPT4gQVRUUl9QUkVGSVgsXG4gIEJhc2VEYXRhUG9pbnRTY2hlbWE6ICgpID0+IEJhc2VEYXRhUG9pbnRTY2hlbWEsXG4gIEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfREVGSU5JVElPTjogKCkgPT4gRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ERUZJTklUSU9OLFxuICBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRTogKCkgPT4gRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ESVNQTEFZX05BTUUsXG4gIEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfSVNfQklMTEVEOiAoKSA9PiBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0lTX0JJTExFRCxcbiAgRXZhbFJlc3BvbnNlU2NoZW1hOiAoKSA9PiBFdmFsUmVzcG9uc2VTY2hlbWEsXG4gIEV2YWxSZXNwb25zZXNTY2hlbWE6ICgpID0+IEV2YWxSZXNwb25zZXNTY2hlbWEsXG4gIEV2YWx1YXRvckluZm9TY2hlbWE6ICgpID0+IEV2YWx1YXRvckluZm9TY2hlbWEsXG4gIFNQQU5fU1RBVEVfQVRUUjogKCkgPT4gU1BBTl9TVEFURV9BVFRSLFxuICBTY29yZVNjaGVtYTogKCkgPT4gU2NvcmVTY2hlbWEsXG4gIGRlZmluZUV2YWx1YXRvcjogKCkgPT4gZGVmaW5lRXZhbHVhdG9yLFxuICBldmFsdWF0ZTogKCkgPT4gZXZhbHVhdGUsXG4gIGV2YWx1YXRvclJlZjogKCkgPT4gZXZhbHVhdG9yUmVmXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGV2YWx1YXRvcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfY29yZSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmVcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL2xvZ2dpbmdcIik7XG52YXIgaW1wb3J0X3JlZ2lzdHJ5ID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9yZWdpc3RyeVwiKTtcbnZhciBpbXBvcnRfdHJhY2luZyA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvdHJhY2luZ1wiKTtcbnZhciB6ID0gX190b0VTTShyZXF1aXJlKFwiem9kXCIpKTtcbmNvbnN0IEFUVFJfUFJFRklYID0gXCJnZW5raXRcIjtcbmNvbnN0IFNQQU5fU1RBVEVfQVRUUiA9IEFUVFJfUFJFRklYICsgXCI6c3RhdGVcIjtcbmNvbnN0IEJhc2VEYXRhUG9pbnRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGlucHV0OiB6LnVua25vd24oKSxcbiAgb3V0cHV0OiB6LnVua25vd24oKS5vcHRpb25hbCgpLFxuICBjb250ZXh0OiB6LmFycmF5KHoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICByZWZlcmVuY2U6IHoudW5rbm93bigpLm9wdGlvbmFsKCksXG4gIHRlc3RDYXNlSWQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdHJhY2VJZHM6IHouYXJyYXkoei5zdHJpbmcoKSkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBTY29yZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc2NvcmU6IHoudW5pb24oW3oubnVtYmVyKCksIHouc3RyaW5nKCksIHouYm9vbGVhbigpXSkub3B0aW9uYWwoKSxcbiAgLy8gVE9ETzogdXNlIFN0YXR1c1NjaGVtYVxuICBlcnJvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBkZXRhaWxzOiB6Lm9iamVjdCh7XG4gICAgcmVhc29uaW5nOiB6LnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSkucGFzc3Rocm91Z2goKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEVWQUxVQVRPUl9NRVRBREFUQV9LRVlfRElTUExBWV9OQU1FID0gXCJldmFsdWF0b3JEaXNwbGF5TmFtZVwiO1xuY29uc3QgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ERUZJTklUSU9OID0gXCJldmFsdWF0b3JEZWZpbml0aW9uXCI7XG5jb25zdCBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0lTX0JJTExFRCA9IFwiZXZhbHVhdG9ySXNCaWxsZWRcIjtcbmNvbnN0IEV2YWxSZXNwb25zZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc2FtcGxlSW5kZXg6IHoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgdGVzdENhc2VJZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0cmFjZUlkOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHNwYW5JZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBldmFsdWF0aW9uOiBTY29yZVNjaGVtYVxufSk7XG5jb25zdCBFdmFsUmVzcG9uc2VzU2NoZW1hID0gei5hcnJheShFdmFsUmVzcG9uc2VTY2hlbWEpO1xuZnVuY3Rpb24gd2l0aE1ldGFkYXRhKGV2YWx1YXRvciwgZGF0YVBvaW50VHlwZSwgY29uZmlnU2NoZW1hKSB7XG4gIGNvbnN0IHdpdGhNZXRhID0gZXZhbHVhdG9yO1xuICB3aXRoTWV0YS5fX2RhdGFQb2ludFR5cGUgPSBkYXRhUG9pbnRUeXBlO1xuICB3aXRoTWV0YS5fX2NvbmZpZ1NjaGVtYSA9IGNvbmZpZ1NjaGVtYTtcbiAgcmV0dXJuIHdpdGhNZXRhO1xufVxuY29uc3QgRXZhbFJlcXVlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRhdGFzZXQ6IHouYXJyYXkoQmFzZURhdGFQb2ludFNjaGVtYSksXG4gIG9wdGlvbnM6IHoudW5rbm93bigpXG59KTtcbmZ1bmN0aW9uIGRlZmluZUV2YWx1YXRvcihvcHRpb25zLCBydW5uZXIpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICBtZXRhZGF0YVtFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0lTX0JJTExFRF0gPSBvcHRpb25zLmlzQmlsbGVkID09IHZvaWQgMCA/IHRydWUgOiBvcHRpb25zLmlzQmlsbGVkO1xuICBtZXRhZGF0YVtFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRV0gPSBvcHRpb25zLmRpc3BsYXlOYW1lO1xuICBtZXRhZGF0YVtFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RFRklOSVRJT05dID0gb3B0aW9ucy5kZWZpbml0aW9uO1xuICBjb25zdCBldmFsdWF0b3IgPSAoMCwgaW1wb3J0X2NvcmUuZGVmaW5lQWN0aW9uKShcbiAgICB7XG4gICAgICBhY3Rpb25UeXBlOiBcImV2YWx1YXRvclwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgaW5wdXRTY2hlbWE6IEV2YWxSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIGRhdGFzZXQ6IG9wdGlvbnMuZGF0YVBvaW50VHlwZSA/IHouYXJyYXkob3B0aW9ucy5kYXRhUG9pbnRUeXBlKSA6IHouYXJyYXkoQmFzZURhdGFQb2ludFNjaGVtYSksXG4gICAgICAgIG9wdGlvbnM6IChfYSA9IG9wdGlvbnMuY29uZmlnU2NoZW1hKSAhPSBudWxsID8gX2EgOiB6LnVua25vd24oKSxcbiAgICAgICAgZXZhbFJ1bklkOiB6LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIG91dHB1dFNjaGVtYTogRXZhbFJlc3BvbnNlc1NjaGVtYSxcbiAgICAgIG1ldGFkYXRhXG4gICAgfSxcbiAgICAoaSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGV2YWxSZXNwb25zZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpLmRhdGFzZXQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFwb2ludCA9IGkuZGF0YXNldFtpbmRleF07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgKDAsIGltcG9ydF90cmFjaW5nLnJ1bkluTmV3U3BhbikoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYFRlc3QgQ2FzZSAke2RhdGFwb2ludC50ZXN0Q2FzZUlkfWAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHsgXCJldmFsdWF0b3I6ZXZhbFJ1bklkXCI6IGkuZXZhbFJ1bklkIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgW2ltcG9ydF90cmFjaW5nLlNQQU5fVFlQRV9BVFRSXTogXCJldmFsdWF0b3JcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKG1ldGFkYXRhMiwgb3RTcGFuKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYW5JZCA9IG90U3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VJZCA9IG90U3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEyLmlucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGRhdGFwb2ludC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogZGF0YXBvaW50Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGRhdGFwb2ludC5jb250ZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0Q2FzZU91dHB1dCA9IHlpZWxkIHJ1bm5lcihkYXRhcG9pbnQsIGkub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGVzdENhc2VPdXRwdXQuc2FtcGxlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0ZXN0Q2FzZU91dHB1dC5zcGFuSWQgPSBzcGFuSWQ7XG4gICAgICAgICAgICAgICAgdGVzdENhc2VPdXRwdXQudHJhY2VJZCA9IHRyYWNlSWQ7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEyLm91dHB1dCA9IHRlc3RDYXNlT3V0cHV0O1xuICAgICAgICAgICAgICAgIGV2YWxSZXNwb25zZXMucHVzaCh0ZXN0Q2FzZU91dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RDYXNlT3V0cHV0O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXZhbFJlc3BvbnNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZUluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgIHNwYW5JZCxcbiAgICAgICAgICAgICAgICAgIHRyYWNlSWQsXG4gICAgICAgICAgICAgICAgICB0ZXN0Q2FzZUlkOiBkYXRhcG9pbnQudGVzdENhc2VJZCxcbiAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBFdmFsdWF0aW9uIG9mIHRlc3QgY2FzZSAke2RhdGFwb2ludC50ZXN0Q2FzZUlkfSBmYWlsZWQ6IFxuJHtlLnN0YWNrfWBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgRXZhbHVhdGlvbiBvZiB0ZXN0IGNhc2UgJHtkYXRhcG9pbnQudGVzdENhc2VJZH0gZmFpbGVkOiBcbiR7ZS5zdGFja31gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2YWxSZXNwb25zZXM7XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgZXdtID0gd2l0aE1ldGFkYXRhKFxuICAgIGV2YWx1YXRvcixcbiAgICBvcHRpb25zLmRhdGFQb2ludFR5cGUsXG4gICAgb3B0aW9ucy5jb25maWdTY2hlbWFcbiAgKTtcbiAgcmV0dXJuIGV3bTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHBhcmFtcykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBldmFsdWF0b3I7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZXZhbHVhdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBldmFsdWF0b3IgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9ldmFsdWF0b3IvJHtwYXJhbXMuZXZhbHVhdG9yfWApO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLmV2YWx1YXRvciwgXCJpbmZvXCIpKSB7XG4gICAgICBldmFsdWF0b3IgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9ldmFsdWF0b3IvJHtwYXJhbXMuZXZhbHVhdG9yLm5hbWV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2YWx1YXRvciA9IHBhcmFtcy5ldmFsdWF0b3I7XG4gICAgfVxuICAgIGlmICghZXZhbHVhdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gdXRpbGl6ZSB0aGUgcHJvdmlkZWQgZXZhbHVhdG9yXCIpO1xuICAgIH1cbiAgICByZXR1cm4geWllbGQgZXZhbHVhdG9yKHtcbiAgICAgIGRhdGFzZXQ6IHBhcmFtcy5kYXRhc2V0LFxuICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBFdmFsdWF0b3JJbmZvU2NoZW1hID0gei5vYmplY3Qoe1xuICAvKiogRnJpZW5kbHkgbGFiZWwgZm9yIHRoaXMgZXZhbHVhdG9yICovXG4gIGxhYmVsOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1ldHJpY3M6IHouYXJyYXkoei5zdHJpbmcoKSlcbn0pO1xuZnVuY3Rpb24gZXZhbHVhdG9yUmVmKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBVFRSX1BSRUZJWCxcbiAgQmFzZURhdGFQb2ludFNjaGVtYSxcbiAgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9ERUZJTklUSU9OLFxuICBFVkFMVUFUT1JfTUVUQURBVEFfS0VZX0RJU1BMQVlfTkFNRSxcbiAgRVZBTFVBVE9SX01FVEFEQVRBX0tFWV9JU19CSUxMRUQsXG4gIEV2YWxSZXNwb25zZVNjaGVtYSxcbiAgRXZhbFJlc3BvbnNlc1NjaGVtYSxcbiAgRXZhbHVhdG9ySW5mb1NjaGVtYSxcbiAgU1BBTl9TVEFURV9BVFRSLFxuICBTY29yZVNjaGVtYSxcbiAgZGVmaW5lRXZhbHVhdG9yLFxuICBldmFsdWF0ZSxcbiAgZXZhbHVhdG9yUmVmXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2YWx1YXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/extract.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar extract_exports = {};\n__export(extract_exports, {\n  extractJson: () => extractJson,\n  parsePartialJson: () => parsePartialJson\n});\nmodule.exports = __toCommonJS(extract_exports);\nvar import_json5 = __toESM(__webpack_require__(/*! json5 */ \"(action-browser)/./node_modules/json5/dist/index.mjs\"));\nvar import_partial_json = __webpack_require__(/*! partial-json */ \"(action-browser)/./node_modules/partial-json/dist/index.js\");\nfunction parsePartialJson(jsonString) {\n  return import_json5.default.parse(JSON.stringify((0, import_partial_json.parse)(jsonString, import_partial_json.Allow.ALL)));\n}\nfunction extractJson(text, throwOnBadJson) {\n  let openingChar;\n  let closingChar;\n  let startPos;\n  let nestingCount = 0;\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i].replace(/\\u00A0/g, \" \");\n    if (!openingChar && (char === \"{\" || char === \"[\")) {\n      openingChar = char;\n      closingChar = char === \"{\" ? \"}\" : \"]\";\n      startPos = i;\n      nestingCount++;\n    } else if (char === openingChar) {\n      nestingCount++;\n    } else if (char === closingChar) {\n      nestingCount--;\n      if (!nestingCount) {\n        return import_json5.default.parse(text.substring(startPos || 0, i + 1));\n      }\n    }\n  }\n  if (startPos !== void 0 && nestingCount > 0) {\n    try {\n      return parsePartialJson(text.substring(startPos));\n    } catch (e) {\n      if (throwOnBadJson) {\n        throw new Error(`Invalid JSON extracted from model output: ${text}`);\n      }\n      return null;\n    }\n  }\n  if (throwOnBadJson) {\n    throw new Error(`Invalid JSON extracted from model output: ${text}`);\n  }\n  return null;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=extract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsbUVBQU87QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FHTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvYWkvbGliL2V4dHJhY3QuanM/NGMwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZXh0cmFjdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRyYWN0X2V4cG9ydHMsIHtcbiAgZXh0cmFjdEpzb246ICgpID0+IGV4dHJhY3RKc29uLFxuICBwYXJzZVBhcnRpYWxKc29uOiAoKSA9PiBwYXJzZVBhcnRpYWxKc29uXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGV4dHJhY3RfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2pzb241ID0gX190b0VTTShyZXF1aXJlKFwianNvbjVcIikpO1xudmFyIGltcG9ydF9wYXJ0aWFsX2pzb24gPSByZXF1aXJlKFwicGFydGlhbC1qc29uXCIpO1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uU3RyaW5nKSB7XG4gIHJldHVybiBpbXBvcnRfanNvbjUuZGVmYXVsdC5wYXJzZShKU09OLnN0cmluZ2lmeSgoMCwgaW1wb3J0X3BhcnRpYWxfanNvbi5wYXJzZSkoanNvblN0cmluZywgaW1wb3J0X3BhcnRpYWxfanNvbi5BbGxvdy5BTEwpKSk7XG59XG5mdW5jdGlvbiBleHRyYWN0SnNvbih0ZXh0LCB0aHJvd09uQmFkSnNvbikge1xuICBsZXQgb3BlbmluZ0NoYXI7XG4gIGxldCBjbG9zaW5nQ2hhcjtcbiAgbGV0IHN0YXJ0UG9zO1xuICBsZXQgbmVzdGluZ0NvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHRleHRbaV0ucmVwbGFjZSgvXFx1MDBBMC9nLCBcIiBcIik7XG4gICAgaWYgKCFvcGVuaW5nQ2hhciAmJiAoY2hhciA9PT0gXCJ7XCIgfHwgY2hhciA9PT0gXCJbXCIpKSB7XG4gICAgICBvcGVuaW5nQ2hhciA9IGNoYXI7XG4gICAgICBjbG9zaW5nQ2hhciA9IGNoYXIgPT09IFwie1wiID8gXCJ9XCIgOiBcIl1cIjtcbiAgICAgIHN0YXJ0UG9zID0gaTtcbiAgICAgIG5lc3RpbmdDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gb3BlbmluZ0NoYXIpIHtcbiAgICAgIG5lc3RpbmdDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gY2xvc2luZ0NoYXIpIHtcbiAgICAgIG5lc3RpbmdDb3VudC0tO1xuICAgICAgaWYgKCFuZXN0aW5nQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydF9qc29uNS5kZWZhdWx0LnBhcnNlKHRleHQuc3Vic3RyaW5nKHN0YXJ0UG9zIHx8IDAsIGkgKyAxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzdGFydFBvcyAhPT0gdm9pZCAwICYmIG5lc3RpbmdDb3VudCA+IDApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHBhcnNlUGFydGlhbEpzb24odGV4dC5zdWJzdHJpbmcoc3RhcnRQb3MpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAodGhyb3dPbkJhZEpzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gZXh0cmFjdGVkIGZyb20gbW9kZWwgb3V0cHV0OiAke3RleHR9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRocm93T25CYWRKc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gZXh0cmFjdGVkIGZyb20gbW9kZWwgb3V0cHV0OiAke3RleHR9YCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0cmFjdEpzb24sXG4gIHBhcnNlUGFydGlhbEpzb25cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/generate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => {\n  return (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  };\n  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));\n  var it = {};\n  return generator = generator.apply(__this, __arguments), it[__knownSymbol(\"asyncIterator\")] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\nvar generate_exports = {};\n__export(generate_exports, {\n  Candidate: () => Candidate,\n  GenerateResponse: () => GenerateResponse,\n  GenerateResponseChunk: () => GenerateResponseChunk,\n  Message: () => Message,\n  NoValidCandidatesError: () => NoValidCandidatesError,\n  generate: () => generate,\n  generateStream: () => generateStream,\n  toGenerateRequest: () => toGenerateRequest\n});\nmodule.exports = __toCommonJS(generate_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_extract = __webpack_require__(/*! ./extract.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nvar import_tool = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\nclass Message {\n  constructor(message) {\n    this.role = message.role;\n    this.content = message.content;\n  }\n  /**\n   * If a message contains a `data` part, it is returned. Otherwise, the `output()`\n   * method extracts the first valid JSON object or array from the text contained in\n   * the message and returns it.\n   *\n   * @returns The structured output contained in the message.\n   */\n  output() {\n    return this.data() || (0, import_extract.extractJson)(this.text());\n  }\n  toolResponseParts() {\n    const res = this.content.filter((part) => !!part.toolResponse);\n    return res;\n  }\n  /**\n   * Concatenates all `text` parts present in the message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Returns the first media part detected in the message. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the message.\n   */\n  media() {\n    var _a;\n    return ((_a = this.content.find((part) => part.media)) == null ? void 0 : _a.media) || null;\n  }\n  /**\n   * Returns the first detected `data` part of a message.\n   * @returns The first `data` part detected in the message (if any).\n   */\n  data() {\n    var _a;\n    return (_a = this.content.find((part) => part.data)) == null ? void 0 : _a.data;\n  }\n  /**\n   * Returns all tool request found in this message.\n   * @returns Array of all tool request found in this message.\n   */\n  toolRequests() {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    );\n  }\n  /**\n   * Converts the Message to a plain JS object.\n   * @returns Plain JS object representing the data contained in the message.\n   */\n  toJSON() {\n    return {\n      role: this.role,\n      content: [...this.content]\n    };\n  }\n}\nclass Candidate {\n  constructor(candidate, request) {\n    this.message = new Message(candidate.message);\n    this.index = candidate.index;\n    this.usage = candidate.usage || {};\n    this.finishReason = candidate.finishReason;\n    this.finishMessage = candidate.finishMessage || \"\";\n    this.custom = candidate.custom;\n    this.request = request;\n  }\n  /**\n   * If a candidate's message contains a `data` part, it is returned. Otherwise, the `output()`\n   * method extracts the first valid JSON object or array from the text contained in\n   * the candidate's message and returns it.\n   *\n   * @returns The structured output contained in the candidate.\n   */\n  output() {\n    return this.message.output();\n  }\n  /**\n   * Concatenates all `text` parts present in the candidate's message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text() {\n    return this.message.text();\n  }\n  /**\n   * Returns the first detected media part in the candidate's message. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the candidate.\n   */\n  media() {\n    return this.message.media();\n  }\n  /**\n   * Returns the first detected `data` part of a candidate's message.\n   * @returns The first `data` part detected in the candidate (if any).\n   */\n  data() {\n    return this.message.data();\n  }\n  /**\n   * Returns all tool request found in this candidate.\n   * @returns Array of all tool request found in this candidate.\n   */\n  toolRequests() {\n    return this.message.toolRequests();\n  }\n  /**\n   * Determine whether this candidate has output that conforms to a provided schema.\n   *\n   * @param request A request containing output schema to validate against. If not provided, uses request embedded in candidate.\n   * @returns True if output matches request schema or if no request schema is provided.\n   */\n  hasValidOutput(request) {\n    var _a, _b, _c;\n    const o = this.output();\n    if (!request && !this.request) {\n      return true;\n    }\n    const { valid } = (0, import_schema.validateSchema)(o, {\n      jsonSchema: ((_a = request == null ? void 0 : request.output) == null ? void 0 : _a.schema) || ((_c = (_b = this.request) == null ? void 0 : _b.output) == null ? void 0 : _c.schema)\n    });\n    return valid;\n  }\n  /**\n   * Appends the message generated by this candidate to the messages already\n   * present in the generation request. The result of this method can be safely\n   * serialized to JSON for persistence in a database.\n   * @returns A serializable list of messages compatible with `generate({history})`.\n   */\n  toHistory() {\n    var _a;\n    if (!this.request)\n      throw new Error(\n        \"Can't construct history for candidate without request data.\"\n      );\n    return [...(_a = this.request) == null ? void 0 : _a.messages, this.message.toJSON()];\n  }\n  /**\n   * Converts the Candidate to a plain JS object.\n   * @returns Plain JS object representing the data contained in the candidate.\n   */\n  toJSON() {\n    var _a, _b;\n    return {\n      message: this.message.toJSON(),\n      index: this.index,\n      usage: this.usage,\n      finishReason: this.finishReason,\n      finishMessage: this.finishMessage,\n      custom: !!this.custom && ((_b = (_a = this.custom).toJSON) == null ? void 0 : _b.call(_a)) || this.custom\n    };\n  }\n}\nclass GenerateResponse {\n  /**\n   * If the selected candidate's message contains a `data` part, it is returned. Otherwise,\n   * the `output()` method extracts the first valid JSON object or array from the text\n   * contained in the selected candidate's message and returns it.\n   *\n   * @param index The candidate index from which to extract output. If not provided, finds first candidate that conforms to output schema.\n   * @returns The structured output contained in the selected candidate.\n   */\n  output(index) {\n    var _a, _b;\n    if (index === void 0) {\n      const c = this.candidates.find((c2) => c2.hasValidOutput(this.request));\n      return (c == null ? void 0 : c.output()) || ((_a = this.candidates[0]) == null ? void 0 : _a.output());\n    }\n    return ((_b = this.candidates[index]) == null ? void 0 : _b.output()) || null;\n  }\n  /**\n   * Concatenates all `text` parts present in the candidate's message with no delimiter.\n   * @param index The candidate index from which to extract text, defaults to first candidate.\n   * @returns A string of all concatenated text parts.\n   */\n  text(index = 0) {\n    var _a;\n    return ((_a = this.candidates[index]) == null ? void 0 : _a.text()) || \"\";\n  }\n  /**\n   * Returns the first detected media part in the selected candidate's message. Useful for\n   * extracting (for example) an image from a generation expected to create one.\n   * @param index The candidate index from which to extract media, defaults to first candidate.\n   * @returns The first detected `media` part in the candidate.\n   */\n  media(index = 0) {\n    var _a;\n    return ((_a = this.candidates[index]) == null ? void 0 : _a.media()) || null;\n  }\n  /**\n   * Returns the first detected `data` part of the selected candidate's message.\n   * @param index The candidate index from which to extract data, defaults to first candidate.\n   * @returns The first `data` part detected in the candidate (if any).\n   */\n  data(index = 0) {\n    var _a;\n    return ((_a = this.candidates[index]) == null ? void 0 : _a.data()) || null;\n  }\n  /**\n   * Returns all tool request found in the candidate.\n   * @param index The candidate index from which to extract tool requests, defaults to first candidate.\n   * @returns Array of all tool request found in the candidate.\n   */\n  toolRequests(index = 0) {\n    return this.candidates[index].toolRequests();\n  }\n  /**\n   * Appends the message generated by the selected candidate to the messages already\n   * present in the generation request. The result of this method can be safely\n   * serialized to JSON for persistence in a database.\n   * @param index The candidate index to utilize during conversion, defaults to first candidate.\n   * @returns A serializable list of messages compatible with `generate({history})`.\n   */\n  toHistory(index = 0) {\n    return this.candidates[index].toHistory();\n  }\n  constructor(response, request) {\n    this.candidates = (response.candidates || []).map(\n      (candidate) => new Candidate(candidate, request)\n    );\n    this.usage = response.usage || {};\n    this.custom = response.custom || {};\n    this.request = request;\n  }\n  toJSON() {\n    var _a, _b;\n    return {\n      candidates: this.candidates.map((candidate) => candidate.toJSON()),\n      usage: this.usage,\n      custom: ((_b = (_a = this.custom).toJSON) == null ? void 0 : _b.call(_a)) || this.custom,\n      request: this.request\n    };\n  }\n}\nclass GenerateResponseChunk {\n  constructor(data, accumulatedChunks) {\n    this.index = data.index;\n    this.content = data.content || [];\n    this.custom = data.custom;\n    this.accumulatedChunks = accumulatedChunks;\n  }\n  /**\n   * Concatenates all `text` parts present in the chunk with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text() {\n    return this.content.map((part) => part.text || \"\").join(\"\");\n  }\n  /**\n   * Returns the first media part detected in the chunk. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the chunk.\n   */\n  media() {\n    var _a;\n    return ((_a = this.content.find((part) => part.media)) == null ? void 0 : _a.media) || null;\n  }\n  /**\n   * Returns the first detected `data` part of a chunk.\n   * @returns The first `data` part detected in the chunk (if any).\n   */\n  data() {\n    var _a;\n    return (_a = this.content.find((part) => part.data)) == null ? void 0 : _a.data;\n  }\n  /**\n   * Returns all tool request found in this chunk.\n   * @returns Array of all tool request found in this chunk.\n   */\n  toolRequests() {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    );\n  }\n  /**\n   * Attempts to extract the longest valid JSON substring from the accumulated chunks.\n   * @returns The longest valid JSON substring found in the accumulated chunks.\n   */\n  output() {\n    if (!this.accumulatedChunks)\n      return null;\n    const accumulatedText = this.accumulatedChunks.map((chunk) => chunk.content.map((part) => part.text || \"\").join(\"\")).join(\"\");\n    return (0, import_extract.extractJson)(accumulatedText, false);\n  }\n  toJSON() {\n    return { index: this.index, content: this.content, custom: this.custom };\n  }\n}\nfunction getRoleFromPart(part) {\n  if (part.toolRequest !== void 0)\n    return \"model\";\n  if (part.toolResponse !== void 0)\n    return \"tool\";\n  if (part.text !== void 0)\n    return \"user\";\n  if (part.media !== void 0)\n    return \"user\";\n  if (part.data !== void 0)\n    return \"user\";\n  throw new Error(\"No recognized fields in content\");\n}\nfunction inferRoleFromParts(parts) {\n  const uniqueRoles = /* @__PURE__ */ new Set();\n  for (const part of parts) {\n    const role = getRoleFromPart(part);\n    uniqueRoles.add(role);\n    if (uniqueRoles.size > 1) {\n      throw new Error(\"Contents contain mixed roles\");\n    }\n  }\n  return Array.from(uniqueRoles)[0];\n}\nfunction toGenerateRequest(options) {\n  return __async(this, null, function* () {\n    var _a, _b, _c, _d, _e;\n    const promptMessage = { role: \"user\", content: [] };\n    if (typeof options.prompt === \"string\") {\n      promptMessage.content.push({ text: options.prompt });\n    } else if (Array.isArray(options.prompt)) {\n      promptMessage.role = inferRoleFromParts(options.prompt);\n      promptMessage.content.push(...options.prompt);\n    } else {\n      promptMessage.role = inferRoleFromParts([options.prompt]);\n      promptMessage.content.push(options.prompt);\n    }\n    const messages = [...options.history || [], promptMessage];\n    let tools;\n    if (options.tools) {\n      tools = yield (0, import_tool.resolveTools)(options.tools);\n    }\n    const out = {\n      messages,\n      candidates: options.candidates,\n      config: options.config,\n      context: options.context,\n      tools: (tools == null ? void 0 : tools.map((tool) => (0, import_tool.toToolDefinition)(tool))) || [],\n      output: {\n        format: ((_a = options.output) == null ? void 0 : _a.format) || (((_b = options.output) == null ? void 0 : _b.schema) || ((_c = options.output) == null ? void 0 : _c.jsonSchema) ? \"json\" : \"text\"),\n        schema: (0, import_schema.toJsonSchema)({\n          schema: (_d = options.output) == null ? void 0 : _d.schema,\n          jsonSchema: (_e = options.output) == null ? void 0 : _e.jsonSchema\n        })\n      }\n    };\n    if (!out.output.schema)\n      delete out.output.schema;\n    return out;\n  });\n}\nconst isValidCandidate = (candidate, tools) => {\n  const toolCalls = candidate.message.content.filter(\n    (part) => !!part.toolRequest\n  );\n  return toolCalls.every((toolCall) => {\n    var _a;\n    const tool = tools == null ? void 0 : tools.find(\n      (tool2) => {\n        var _a2;\n        return tool2.__action.name === ((_a2 = toolCall.toolRequest) == null ? void 0 : _a2.name);\n      }\n    );\n    if (!tool)\n      return false;\n    const { valid } = (0, import_schema.validateSchema)((_a = toolCall.toolRequest) == null ? void 0 : _a.input, {\n      schema: tool.__action.inputSchema,\n      jsonSchema: tool.__action.inputJsonSchema\n    });\n    return valid;\n  });\n};\nfunction resolveModel(options) {\n  return __async(this, null, function* () {\n    var _a, _b;\n    let model = options.model;\n    if (!model) {\n      if ((_b = (_a = import_core.config) == null ? void 0 : _a.options) == null ? void 0 : _b.defaultModel) {\n        model = typeof import_core.config.options.defaultModel.name === \"string\" ? import_core.config.options.defaultModel.name : import_core.config.options.defaultModel.name.name;\n        if ((!options.config || Object.keys(options.config).length === 0) && import_core.config.options.defaultModel.config) {\n          options.config = import_core.config.options.defaultModel.config;\n        }\n      } else {\n        throw new Error(\"Unable to resolve model.\");\n      }\n    }\n    if (typeof model === \"string\") {\n      return yield (0, import_registry.lookupAction)(`/model/${model}`);\n    } else if (model.hasOwnProperty(\"info\")) {\n      const ref = model;\n      return yield (0, import_registry.lookupAction)(`/model/${ref.name}`);\n    } else {\n      return model;\n    }\n  });\n}\nclass NoValidCandidatesError extends import_core.GenkitError {\n  constructor({\n    message,\n    response,\n    detail\n  }) {\n    super({\n      status: \"FAILED_PRECONDITION\",\n      message,\n      detail\n    });\n    this.detail = __spreadValues({ response }, detail);\n  }\n}\nfunction generate(options) {\n  return __async(this, null, function* () {\n    var _a, _b, _c, _d, _e;\n    const resolvedOptions = yield Promise.resolve(options);\n    const model = yield resolveModel(resolvedOptions);\n    if (!model) {\n      throw new Error(`Model ${JSON.stringify(resolvedOptions.model)} not found`);\n    }\n    let tools;\n    if ((_a = resolvedOptions.tools) == null ? void 0 : _a.length) {\n      if (!((_c = (_b = model.__action.metadata) == null ? void 0 : _b.model.supports) == null ? void 0 : _c.tools)) {\n        throw new Error(\n          `Model ${JSON.stringify(resolvedOptions.model)} does not support tools, but some tools were supplied to generate(). Please call generate() without tools if you would like to use this model.`\n        );\n      }\n      tools = yield (0, import_tool.resolveTools)(resolvedOptions.tools);\n    }\n    const request = yield toGenerateRequest(resolvedOptions);\n    const accumulatedChunks = [];\n    const response = yield (0, import_core.runWithStreamingCallback)(\n      resolvedOptions.streamingCallback ? (chunk) => {\n        accumulatedChunks.push(chunk);\n        if (resolvedOptions.streamingCallback) {\n          resolvedOptions.streamingCallback(\n            new GenerateResponseChunk(chunk, accumulatedChunks)\n          );\n        }\n      } : void 0,\n      () => __async(this, null, function* () {\n        return new GenerateResponse(yield model(request), request);\n      })\n    );\n    if (!response.candidates.some(\n      (c) => [\"stop\", \"length\"].includes(c.finishReason)\n    )) {\n      throw new NoValidCandidatesError({\n        message: `All candidates returned finishReason issues: ${JSON.stringify(response.candidates.map((c) => c.finishReason))}`,\n        response\n      });\n    }\n    if (((_d = resolvedOptions.output) == null ? void 0 : _d.schema) || ((_e = resolvedOptions.output) == null ? void 0 : _e.jsonSchema)) {\n      const candidateErrors = response.candidates.map((c) => {\n        var _a2, _b2;\n        if (c.text() === \"\" && c.data() === null)\n          return null;\n        try {\n          (0, import_schema.parseSchema)(c.output(), {\n            jsonSchema: (_a2 = resolvedOptions.output) == null ? void 0 : _a2.jsonSchema,\n            schema: (_b2 = resolvedOptions.output) == null ? void 0 : _b2.schema\n          });\n          return null;\n        } catch (e) {\n          return e;\n        }\n      });\n      if (candidateErrors.every((c) => !!c)) {\n        throw new NoValidCandidatesError({\n          message: `Generation resulted in no candidates matching provided output schema.${candidateErrors.map((e, i) => `\n\nCandidate[${i}] ${e.toString()}`)}`,\n          response,\n          detail: {\n            candidateErrors\n          }\n        });\n      }\n    }\n    let selected;\n    for (const candidate of response.candidates) {\n      if (isValidCandidate(candidate, tools || [])) {\n        selected = candidate;\n        break;\n      }\n    }\n    if (!selected) {\n      throw new Error(\"No valid candidates found\");\n    }\n    const toolCalls = selected.message.content.filter(\n      (part) => !!part.toolRequest\n    );\n    if (resolvedOptions.returnToolRequests || toolCalls.length === 0) {\n      return response;\n    }\n    const toolResponses = yield Promise.all(\n      toolCalls.map((part) => __async(this, null, function* () {\n        var _a2;\n        if (!part.toolRequest) {\n          throw Error(\n            \"Tool request expected but not provided in tool request part\"\n          );\n        }\n        const tool = tools == null ? void 0 : tools.find(\n          (tool2) => {\n            var _a3;\n            return tool2.__action.name === ((_a3 = part.toolRequest) == null ? void 0 : _a3.name);\n          }\n        );\n        if (!tool) {\n          throw Error(\"Tool not found\");\n        }\n        return {\n          toolResponse: {\n            name: part.toolRequest.name,\n            ref: part.toolRequest.ref,\n            output: yield tool((_a2 = part.toolRequest) == null ? void 0 : _a2.input)\n          }\n        };\n      }))\n    );\n    resolvedOptions.history = request.messages;\n    resolvedOptions.history.push(selected.message);\n    resolvedOptions.prompt = toolResponses;\n    return yield generate(resolvedOptions);\n  });\n}\nfunction createPromise() {\n  let resolve, reject;\n  let promise = new Promise((res, rej) => [resolve, reject] = [res, rej]);\n  return { resolve, reject, promise };\n}\nfunction generateStream(options) {\n  return __async(this, null, function* () {\n    let firstChunkSent = false;\n    return new Promise(\n      (initialResolve, initialReject) => {\n        const {\n          resolve: finalResolve,\n          reject: finalReject,\n          promise: finalPromise\n        } = createPromise();\n        let provideNextChunk, nextChunk;\n        ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());\n        function chunkStream() {\n          return __asyncGenerator(this, null, function* () {\n            while (true) {\n              const next = yield new __await(nextChunk);\n              if (!next)\n                break;\n              yield next;\n            }\n          });\n        }\n        try {\n          generate(__spreadProps(__spreadValues({}, options), {\n            streamingCallback: (chunk) => {\n              firstChunkSent = true;\n              provideNextChunk(chunk);\n              ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());\n            }\n          })).then((result) => {\n            provideNextChunk(null);\n            finalResolve(result);\n          });\n        } catch (e) {\n          if (!firstChunkSent) {\n            initialReject(e);\n            return;\n          }\n          provideNextChunk(null);\n          finalReject(e);\n        }\n        initialResolve({\n          response: () => finalPromise,\n          stream: chunkStream\n        });\n      }\n    );\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=generate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLCtCQUErQixzQkFBc0IsZ0JBQWdCO0FBQ2xMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLGlHQUEwQjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFFBQVE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pELE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFLE1BQU07QUFDTjtBQUNBLCtEQUErRCxTQUFTO0FBQ3hFLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVDQUF1QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrREFBK0Q7QUFDaEk7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkZBQTJGOztBQUUzRixZQUFZLEVBQUUsSUFBSSxhQUFhLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFnRDtBQUNqRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLENBU0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9nZW5lcmF0ZS5qcz9hNDJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2tub3duU3ltYm9sID0gKG5hbWUsIHN5bWJvbCkgPT4ge1xuICByZXR1cm4gKHN5bWJvbCA9IFN5bWJvbFtuYW1lXSkgPyBzeW1ib2wgOiBTeW1ib2wuZm9yKFwiU3ltYm9sLlwiICsgbmFtZSk7XG59O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fYXdhaXQgPSBmdW5jdGlvbihwcm9taXNlLCBpc1lpZWxkU3Rhcikge1xuICB0aGlzWzBdID0gcHJvbWlzZTtcbiAgdGhpc1sxXSA9IGlzWWllbGRTdGFyO1xufTtcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICB2YXIgcmVzdW1lID0gKGssIHYsIHllcywgbm8pID0+IHtcbiAgICB0cnkge1xuICAgICAgdmFyIHggPSBnZW5lcmF0b3Jba10odiksIGlzQXdhaXQgPSAodiA9IHgudmFsdWUpIGluc3RhbmNlb2YgX19hd2FpdCwgZG9uZSA9IHguZG9uZTtcbiAgICAgIFByb21pc2UucmVzb2x2ZShpc0F3YWl0ID8gdlswXSA6IHYpLnRoZW4oKHkpID0+IGlzQXdhaXQgPyByZXN1bWUoayA9PT0gXCJyZXR1cm5cIiA/IGsgOiBcIm5leHRcIiwgdlsxXSA/IHsgZG9uZTogeS5kb25lLCB2YWx1ZTogeS52YWx1ZSB9IDogeSwgeWVzLCBubykgOiB5ZXMoeyB2YWx1ZTogeSwgZG9uZSB9KSkuY2F0Y2goKGUpID0+IHJlc3VtZShcInRocm93XCIsIGUsIHllcywgbm8pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBubyhlKTtcbiAgICB9XG4gIH07XG4gIHZhciBtZXRob2QgPSAoaykgPT4gaXRba10gPSAoeCkgPT4gbmV3IFByb21pc2UoKHllcywgbm8pID0+IHJlc3VtZShrLCB4LCB5ZXMsIG5vKSk7XG4gIHZhciBpdCA9IHt9O1xuICByZXR1cm4gZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpLCBpdFtfX2tub3duU3ltYm9sKFwiYXN5bmNJdGVyYXRvclwiKV0gPSAoKSA9PiBpdCwgbWV0aG9kKFwibmV4dFwiKSwgbWV0aG9kKFwidGhyb3dcIiksIG1ldGhvZChcInJldHVyblwiKSwgaXQ7XG59O1xudmFyIGdlbmVyYXRlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdlbmVyYXRlX2V4cG9ydHMsIHtcbiAgQ2FuZGlkYXRlOiAoKSA9PiBDYW5kaWRhdGUsXG4gIEdlbmVyYXRlUmVzcG9uc2U6ICgpID0+IEdlbmVyYXRlUmVzcG9uc2UsXG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVuazogKCkgPT4gR2VuZXJhdGVSZXNwb25zZUNodW5rLFxuICBNZXNzYWdlOiAoKSA9PiBNZXNzYWdlLFxuICBOb1ZhbGlkQ2FuZGlkYXRlc0Vycm9yOiAoKSA9PiBOb1ZhbGlkQ2FuZGlkYXRlc0Vycm9yLFxuICBnZW5lcmF0ZTogKCkgPT4gZ2VuZXJhdGUsXG4gIGdlbmVyYXRlU3RyZWFtOiAoKSA9PiBnZW5lcmF0ZVN0cmVhbSxcbiAgdG9HZW5lcmF0ZVJlcXVlc3Q6ICgpID0+IHRvR2VuZXJhdGVSZXF1ZXN0XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdlbmVyYXRlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfcmVnaXN0cnkgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3JlZ2lzdHJ5XCIpO1xudmFyIGltcG9ydF9zY2hlbWEgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3NjaGVtYVwiKTtcbnZhciBpbXBvcnRfZXh0cmFjdCA9IHJlcXVpcmUoXCIuL2V4dHJhY3QuanNcIik7XG52YXIgaW1wb3J0X3Rvb2wgPSByZXF1aXJlKFwiLi90b29sLmpzXCIpO1xuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gICAgdGhpcy5jb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICB9XG4gIC8qKlxuICAgKiBJZiBhIG1lc3NhZ2UgY29udGFpbnMgYSBgZGF0YWAgcGFydCwgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGBvdXRwdXQoKWBcbiAgICogbWV0aG9kIGV4dHJhY3RzIHRoZSBmaXJzdCB2YWxpZCBKU09OIG9iamVjdCBvciBhcnJheSBmcm9tIHRoZSB0ZXh0IGNvbnRhaW5lZCBpblxuICAgKiB0aGUgbWVzc2FnZSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHN0cnVjdHVyZWQgb3V0cHV0IGNvbnRhaW5lZCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIG91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhKCkgfHwgKDAsIGltcG9ydF9leHRyYWN0LmV4dHJhY3RKc29uKSh0aGlzLnRleHQoKSk7XG4gIH1cbiAgdG9vbFJlc3BvbnNlUGFydHMoKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gISFwYXJ0LnRvb2xSZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCBgdGV4dGAgcGFydHMgcHJlc2VudCBpbiB0aGUgbWVzc2FnZSB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCB0ZXh0IHBhcnRzLlxuICAgKi9cbiAgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcCgocGFydCkgPT4gcGFydC50ZXh0IHx8IFwiXCIpLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1lZGlhIHBhcnQgZGV0ZWN0ZWQgaW4gdGhlIG1lc3NhZ2UuIFVzZWZ1bCBmb3IgZXh0cmFjdGluZ1xuICAgKiAoZm9yIGV4YW1wbGUpIGFuIGltYWdlIGZyb20gYSBnZW5lcmF0aW9uIGV4cGVjdGVkIHRvIGNyZWF0ZSBvbmUuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBkZXRlY3RlZCBgbWVkaWFgIHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBtZWRpYSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNvbnRlbnQuZmluZCgocGFydCkgPT4gcGFydC5tZWRpYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tZWRpYSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZGV0ZWN0ZWQgYGRhdGFgIHBhcnQgb2YgYSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgYGRhdGFgIHBhcnQgZGV0ZWN0ZWQgaW4gdGhlIG1lc3NhZ2UgKGlmIGFueSkuXG4gICAqL1xuICBkYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5jb250ZW50LmZpbmQoKHBhcnQpID0+IHBhcnQuZGF0YSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGwgdG9vbCByZXF1ZXN0IGZvdW5kIGluIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIHRvb2xSZXF1ZXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihcbiAgICAgIChwYXJ0KSA9PiAhIXBhcnQudG9vbFJlcXVlc3RcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTWVzc2FnZSB0byBhIHBsYWluIEpTIG9iamVjdC5cbiAgICogQHJldHVybnMgUGxhaW4gSlMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgIGNvbnRlbnQ6IFsuLi50aGlzLmNvbnRlbnRdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgQ2FuZGlkYXRlIHtcbiAgY29uc3RydWN0b3IoY2FuZGlkYXRlLCByZXF1ZXN0KSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbmV3IE1lc3NhZ2UoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIHRoaXMuaW5kZXggPSBjYW5kaWRhdGUuaW5kZXg7XG4gICAgdGhpcy51c2FnZSA9IGNhbmRpZGF0ZS51c2FnZSB8fCB7fTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGNhbmRpZGF0ZS5maW5pc2hSZWFzb247XG4gICAgdGhpcy5maW5pc2hNZXNzYWdlID0gY2FuZGlkYXRlLmZpbmlzaE1lc3NhZ2UgfHwgXCJcIjtcbiAgICB0aGlzLmN1c3RvbSA9IGNhbmRpZGF0ZS5jdXN0b207XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogSWYgYSBjYW5kaWRhdGUncyBtZXNzYWdlIGNvbnRhaW5zIGEgYGRhdGFgIHBhcnQsIGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBgb3V0cHV0KClgXG4gICAqIG1ldGhvZCBleHRyYWN0cyB0aGUgZmlyc3QgdmFsaWQgSlNPTiBvYmplY3Qgb3IgYXJyYXkgZnJvbSB0aGUgdGV4dCBjb250YWluZWQgaW5cbiAgICogdGhlIGNhbmRpZGF0ZSdzIG1lc3NhZ2UgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBzdHJ1Y3R1cmVkIG91dHB1dCBjb250YWluZWQgaW4gdGhlIGNhbmRpZGF0ZS5cbiAgICovXG4gIG91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLm91dHB1dCgpO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGB0ZXh0YCBwYXJ0cyBwcmVzZW50IGluIHRoZSBjYW5kaWRhdGUncyBtZXNzYWdlIHdpdGggbm8gZGVsaW1pdGVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyBvZiBhbGwgY29uY2F0ZW5hdGVkIHRleHQgcGFydHMuXG4gICAqL1xuICB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudGV4dCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkZXRlY3RlZCBtZWRpYSBwYXJ0IGluIHRoZSBjYW5kaWRhdGUncyBtZXNzYWdlLiBVc2VmdWwgZm9yIGV4dHJhY3RpbmdcbiAgICogKGZvciBleGFtcGxlKSBhbiBpbWFnZSBmcm9tIGEgZ2VuZXJhdGlvbiBleHBlY3RlZCB0byBjcmVhdGUgb25lLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgZGV0ZWN0ZWQgYG1lZGlhYCBwYXJ0IGluIHRoZSBjYW5kaWRhdGUuXG4gICAqL1xuICBtZWRpYSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLm1lZGlhKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGRldGVjdGVkIGBkYXRhYCBwYXJ0IG9mIGEgY2FuZGlkYXRlJ3MgbWVzc2FnZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGBkYXRhYCBwYXJ0IGRldGVjdGVkIGluIHRoZSBjYW5kaWRhdGUgKGlmIGFueSkuXG4gICAqL1xuICBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UuZGF0YSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBjYW5kaWRhdGUuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBjYW5kaWRhdGUuXG4gICAqL1xuICB0b29sUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZS50b29sUmVxdWVzdHMoKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBjYW5kaWRhdGUgaGFzIG91dHB1dCB0aGF0IGNvbmZvcm1zIHRvIGEgcHJvdmlkZWQgc2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCBBIHJlcXVlc3QgY29udGFpbmluZyBvdXRwdXQgc2NoZW1hIHRvIHZhbGlkYXRlIGFnYWluc3QuIElmIG5vdCBwcm92aWRlZCwgdXNlcyByZXF1ZXN0IGVtYmVkZGVkIGluIGNhbmRpZGF0ZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBvdXRwdXQgbWF0Y2hlcyByZXF1ZXN0IHNjaGVtYSBvciBpZiBubyByZXF1ZXN0IHNjaGVtYSBpcyBwcm92aWRlZC5cbiAgICovXG4gIGhhc1ZhbGlkT3V0cHV0KHJlcXVlc3QpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBvID0gdGhpcy5vdXRwdXQoKTtcbiAgICBpZiAoIXJlcXVlc3QgJiYgIXRoaXMucmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgdmFsaWQgfSA9ICgwLCBpbXBvcnRfc2NoZW1hLnZhbGlkYXRlU2NoZW1hKShvLCB7XG4gICAgICBqc29uU2NoZW1hOiAoKF9hID0gcmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdC5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY2hlbWEpIHx8ICgoX2MgPSAoX2IgPSB0aGlzLnJlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zY2hlbWEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGlzIGNhbmRpZGF0ZSB0byB0aGUgbWVzc2FnZXMgYWxyZWFkeVxuICAgKiBwcmVzZW50IGluIHRoZSBnZW5lcmF0aW9uIHJlcXVlc3QuIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseVxuICAgKiBzZXJpYWxpemVkIHRvIEpTT04gZm9yIHBlcnNpc3RlbmNlIGluIGEgZGF0YWJhc2UuXG4gICAqIEByZXR1cm5zIEEgc2VyaWFsaXphYmxlIGxpc3Qgb2YgbWVzc2FnZXMgY29tcGF0aWJsZSB3aXRoIGBnZW5lcmF0ZSh7aGlzdG9yeX0pYC5cbiAgICovXG4gIHRvSGlzdG9yeSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3QpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgY29uc3RydWN0IGhpc3RvcnkgZm9yIGNhbmRpZGF0ZSB3aXRob3V0IHJlcXVlc3QgZGF0YS5cIlxuICAgICAgKTtcbiAgICByZXR1cm4gWy4uLihfYSA9IHRoaXMucmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2VzLCB0aGlzLm1lc3NhZ2UudG9KU09OKCldO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgQ2FuZGlkYXRlIHRvIGEgcGxhaW4gSlMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBQbGFpbiBKUyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgY2FuZGlkYXRlLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZS50b0pTT04oKSxcbiAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgdXNhZ2U6IHRoaXMudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IHRoaXMuZmluaXNoUmVhc29uLFxuICAgICAgZmluaXNoTWVzc2FnZTogdGhpcy5maW5pc2hNZXNzYWdlLFxuICAgICAgY3VzdG9tOiAhIXRoaXMuY3VzdG9tICYmICgoX2IgPSAoX2EgPSB0aGlzLmN1c3RvbSkudG9KU09OKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSkpIHx8IHRoaXMuY3VzdG9tXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgR2VuZXJhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBJZiB0aGUgc2VsZWN0ZWQgY2FuZGlkYXRlJ3MgbWVzc2FnZSBjb250YWlucyBhIGBkYXRhYCBwYXJ0LCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLFxuICAgKiB0aGUgYG91dHB1dCgpYCBtZXRob2QgZXh0cmFjdHMgdGhlIGZpcnN0IHZhbGlkIEpTT04gb2JqZWN0IG9yIGFycmF5IGZyb20gdGhlIHRleHRcbiAgICogY29udGFpbmVkIGluIHRoZSBzZWxlY3RlZCBjYW5kaWRhdGUncyBtZXNzYWdlIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGNhbmRpZGF0ZSBpbmRleCBmcm9tIHdoaWNoIHRvIGV4dHJhY3Qgb3V0cHV0LiBJZiBub3QgcHJvdmlkZWQsIGZpbmRzIGZpcnN0IGNhbmRpZGF0ZSB0aGF0IGNvbmZvcm1zIHRvIG91dHB1dCBzY2hlbWEuXG4gICAqIEByZXR1cm5zIFRoZSBzdHJ1Y3R1cmVkIG91dHB1dCBjb250YWluZWQgaW4gdGhlIHNlbGVjdGVkIGNhbmRpZGF0ZS5cbiAgICovXG4gIG91dHB1dChpbmRleCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmNhbmRpZGF0ZXMuZmluZCgoYzIpID0+IGMyLmhhc1ZhbGlkT3V0cHV0KHRoaXMucmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIChjID09IG51bGwgPyB2b2lkIDAgOiBjLm91dHB1dCgpKSB8fCAoKF9hID0gdGhpcy5jYW5kaWRhdGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub3V0cHV0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gKChfYiA9IHRoaXMuY2FuZGlkYXRlc1tpbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5vdXRwdXQoKSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCBgdGV4dGAgcGFydHMgcHJlc2VudCBpbiB0aGUgY2FuZGlkYXRlJ3MgbWVzc2FnZSB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBjYW5kaWRhdGUgaW5kZXggZnJvbSB3aGljaCB0byBleHRyYWN0IHRleHQsIGRlZmF1bHRzIHRvIGZpcnN0IGNhbmRpZGF0ZS5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCB0ZXh0IHBhcnRzLlxuICAgKi9cbiAgdGV4dChpbmRleCA9IDApIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNhbmRpZGF0ZXNbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCgpKSB8fCBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkZXRlY3RlZCBtZWRpYSBwYXJ0IGluIHRoZSBzZWxlY3RlZCBjYW5kaWRhdGUncyBtZXNzYWdlLiBVc2VmdWwgZm9yXG4gICAqIGV4dHJhY3RpbmcgKGZvciBleGFtcGxlKSBhbiBpbWFnZSBmcm9tIGEgZ2VuZXJhdGlvbiBleHBlY3RlZCB0byBjcmVhdGUgb25lLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGNhbmRpZGF0ZSBpbmRleCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgbWVkaWEsIGRlZmF1bHRzIHRvIGZpcnN0IGNhbmRpZGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGRldGVjdGVkIGBtZWRpYWAgcGFydCBpbiB0aGUgY2FuZGlkYXRlLlxuICAgKi9cbiAgbWVkaWEoaW5kZXggPSAwKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5jYW5kaWRhdGVzW2luZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1lZGlhKCkpIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGRldGVjdGVkIGBkYXRhYCBwYXJ0IG9mIHRoZSBzZWxlY3RlZCBjYW5kaWRhdGUncyBtZXNzYWdlLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGNhbmRpZGF0ZSBpbmRleCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgZGF0YSwgZGVmYXVsdHMgdG8gZmlyc3QgY2FuZGlkYXRlLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgYGRhdGFgIHBhcnQgZGV0ZWN0ZWQgaW4gdGhlIGNhbmRpZGF0ZSAoaWYgYW55KS5cbiAgICovXG4gIGRhdGEoaW5kZXggPSAwKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5jYW5kaWRhdGVzW2luZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRhdGEoKSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdG9vbCByZXF1ZXN0IGZvdW5kIGluIHRoZSBjYW5kaWRhdGUuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgY2FuZGlkYXRlIGluZGV4IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0b29sIHJlcXVlc3RzLCBkZWZhdWx0cyB0byBmaXJzdCBjYW5kaWRhdGUuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhlIGNhbmRpZGF0ZS5cbiAgICovXG4gIHRvb2xSZXF1ZXN0cyhpbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5jYW5kaWRhdGVzW2luZGV4XS50b29sUmVxdWVzdHMoKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIHNlbGVjdGVkIGNhbmRpZGF0ZSB0byB0aGUgbWVzc2FnZXMgYWxyZWFkeVxuICAgKiBwcmVzZW50IGluIHRoZSBnZW5lcmF0aW9uIHJlcXVlc3QuIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseVxuICAgKiBzZXJpYWxpemVkIHRvIEpTT04gZm9yIHBlcnNpc3RlbmNlIGluIGEgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgY2FuZGlkYXRlIGluZGV4IHRvIHV0aWxpemUgZHVyaW5nIGNvbnZlcnNpb24sIGRlZmF1bHRzIHRvIGZpcnN0IGNhbmRpZGF0ZS5cbiAgICogQHJldHVybnMgQSBzZXJpYWxpemFibGUgbGlzdCBvZiBtZXNzYWdlcyBjb21wYXRpYmxlIHdpdGggYGdlbmVyYXRlKHtoaXN0b3J5fSlgLlxuICAgKi9cbiAgdG9IaXN0b3J5KGluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLmNhbmRpZGF0ZXNbaW5kZXhdLnRvSGlzdG9yeSgpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCByZXF1ZXN0KSB7XG4gICAgdGhpcy5jYW5kaWRhdGVzID0gKHJlc3BvbnNlLmNhbmRpZGF0ZXMgfHwgW10pLm1hcChcbiAgICAgIChjYW5kaWRhdGUpID0+IG5ldyBDYW5kaWRhdGUoY2FuZGlkYXRlLCByZXF1ZXN0KVxuICAgICk7XG4gICAgdGhpcy51c2FnZSA9IHJlc3BvbnNlLnVzYWdlIHx8IHt9O1xuICAgIHRoaXMuY3VzdG9tID0gcmVzcG9uc2UuY3VzdG9tIHx8IHt9O1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmRpZGF0ZXM6IHRoaXMuY2FuZGlkYXRlcy5tYXAoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLnRvSlNPTigpKSxcbiAgICAgIHVzYWdlOiB0aGlzLnVzYWdlLFxuICAgICAgY3VzdG9tOiAoKF9iID0gKF9hID0gdGhpcy5jdXN0b20pLnRvSlNPTikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSB8fCB0aGlzLmN1c3RvbSxcbiAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdFxuICAgIH07XG4gIH1cbn1cbmNsYXNzIEdlbmVyYXRlUmVzcG9uc2VDaHVuayB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGFjY3VtdWxhdGVkQ2h1bmtzKSB7XG4gICAgdGhpcy5pbmRleCA9IGRhdGEuaW5kZXg7XG4gICAgdGhpcy5jb250ZW50ID0gZGF0YS5jb250ZW50IHx8IFtdO1xuICAgIHRoaXMuY3VzdG9tID0gZGF0YS5jdXN0b207XG4gICAgdGhpcy5hY2N1bXVsYXRlZENodW5rcyA9IGFjY3VtdWxhdGVkQ2h1bmtzO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYWxsIGB0ZXh0YCBwYXJ0cyBwcmVzZW50IGluIHRoZSBjaHVuayB3aXRoIG5vIGRlbGltaXRlci5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgb2YgYWxsIGNvbmNhdGVuYXRlZCB0ZXh0IHBhcnRzLlxuICAgKi9cbiAgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lm1hcCgocGFydCkgPT4gcGFydC50ZXh0IHx8IFwiXCIpLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1lZGlhIHBhcnQgZGV0ZWN0ZWQgaW4gdGhlIGNodW5rLiBVc2VmdWwgZm9yIGV4dHJhY3RpbmdcbiAgICogKGZvciBleGFtcGxlKSBhbiBpbWFnZSBmcm9tIGEgZ2VuZXJhdGlvbiBleHBlY3RlZCB0byBjcmVhdGUgb25lLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgZGV0ZWN0ZWQgYG1lZGlhYCBwYXJ0IGluIHRoZSBjaHVuay5cbiAgICovXG4gIG1lZGlhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuY29udGVudC5maW5kKChwYXJ0KSA9PiBwYXJ0Lm1lZGlhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1lZGlhKSB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkZXRlY3RlZCBgZGF0YWAgcGFydCBvZiBhIGNodW5rLlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgYGRhdGFgIHBhcnQgZGV0ZWN0ZWQgaW4gdGhlIGNodW5rIChpZiBhbnkpLlxuICAgKi9cbiAgZGF0YSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuY29udGVudC5maW5kKChwYXJ0KSA9PiBwYXJ0LmRhdGEpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdG9vbCByZXF1ZXN0IGZvdW5kIGluIHRoaXMgY2h1bmsuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCB0b29sIHJlcXVlc3QgZm91bmQgaW4gdGhpcyBjaHVuay5cbiAgICovXG4gIHRvb2xSZXF1ZXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihcbiAgICAgIChwYXJ0KSA9PiAhIXBhcnQudG9vbFJlcXVlc3RcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBleHRyYWN0IHRoZSBsb25nZXN0IHZhbGlkIEpTT04gc3Vic3RyaW5nIGZyb20gdGhlIGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICogQHJldHVybnMgVGhlIGxvbmdlc3QgdmFsaWQgSlNPTiBzdWJzdHJpbmcgZm91bmQgaW4gdGhlIGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICovXG4gIG91dHB1dCgpIHtcbiAgICBpZiAoIXRoaXMuYWNjdW11bGF0ZWRDaHVua3MpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBhY2N1bXVsYXRlZFRleHQgPSB0aGlzLmFjY3VtdWxhdGVkQ2h1bmtzLm1hcCgoY2h1bmspID0+IGNodW5rLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBwYXJ0LnRleHQgfHwgXCJcIikuam9pbihcIlwiKSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9leHRyYWN0LmV4dHJhY3RKc29uKShhY2N1bXVsYXRlZFRleHQsIGZhbHNlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgaW5kZXg6IHRoaXMuaW5kZXgsIGNvbnRlbnQ6IHRoaXMuY29udGVudCwgY3VzdG9tOiB0aGlzLmN1c3RvbSB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRSb2xlRnJvbVBhcnQocGFydCkge1xuICBpZiAocGFydC50b29sUmVxdWVzdCAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBcIm1vZGVsXCI7XG4gIGlmIChwYXJ0LnRvb2xSZXNwb25zZSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBcInRvb2xcIjtcbiAgaWYgKHBhcnQudGV4dCAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBcInVzZXJcIjtcbiAgaWYgKHBhcnQubWVkaWEgIT09IHZvaWQgMClcbiAgICByZXR1cm4gXCJ1c2VyXCI7XG4gIGlmIChwYXJ0LmRhdGEgIT09IHZvaWQgMClcbiAgICByZXR1cm4gXCJ1c2VyXCI7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY29nbml6ZWQgZmllbGRzIGluIGNvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBpbmZlclJvbGVGcm9tUGFydHMocGFydHMpIHtcbiAgY29uc3QgdW5pcXVlUm9sZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBjb25zdCByb2xlID0gZ2V0Um9sZUZyb21QYXJ0KHBhcnQpO1xuICAgIHVuaXF1ZVJvbGVzLmFkZChyb2xlKTtcbiAgICBpZiAodW5pcXVlUm9sZXMuc2l6ZSA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnRzIGNvbnRhaW4gbWl4ZWQgcm9sZXNcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZVJvbGVzKVswXTtcbn1cbmZ1bmN0aW9uIHRvR2VuZXJhdGVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHByb21wdE1lc3NhZ2UgPSB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBbXSB9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHByb21wdE1lc3NhZ2UuY29udGVudC5wdXNoKHsgdGV4dDogb3B0aW9ucy5wcm9tcHQgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvbXB0KSkge1xuICAgICAgcHJvbXB0TWVzc2FnZS5yb2xlID0gaW5mZXJSb2xlRnJvbVBhcnRzKG9wdGlvbnMucHJvbXB0KTtcbiAgICAgIHByb21wdE1lc3NhZ2UuY29udGVudC5wdXNoKC4uLm9wdGlvbnMucHJvbXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbXB0TWVzc2FnZS5yb2xlID0gaW5mZXJSb2xlRnJvbVBhcnRzKFtvcHRpb25zLnByb21wdF0pO1xuICAgICAgcHJvbXB0TWVzc2FnZS5jb250ZW50LnB1c2gob3B0aW9ucy5wcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFsuLi5vcHRpb25zLmhpc3RvcnkgfHwgW10sIHByb21wdE1lc3NhZ2VdO1xuICAgIGxldCB0b29scztcbiAgICBpZiAob3B0aW9ucy50b29scykge1xuICAgICAgdG9vbHMgPSB5aWVsZCAoMCwgaW1wb3J0X3Rvb2wucmVzb2x2ZVRvb2xzKShvcHRpb25zLnRvb2xzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0ge1xuICAgICAgbWVzc2FnZXMsXG4gICAgICBjYW5kaWRhdGVzOiBvcHRpb25zLmNhbmRpZGF0ZXMsXG4gICAgICBjb25maWc6IG9wdGlvbnMuY29uZmlnLFxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgdG9vbHM6ICh0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHMubWFwKCh0b29sKSA9PiAoMCwgaW1wb3J0X3Rvb2wudG9Ub29sRGVmaW5pdGlvbikodG9vbCkpKSB8fCBbXSxcbiAgICAgIG91dHB1dDoge1xuICAgICAgICBmb3JtYXQ6ICgoX2EgPSBvcHRpb25zLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgfHwgKCgoX2IgPSBvcHRpb25zLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNjaGVtYSkgfHwgKChfYyA9IG9wdGlvbnMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuanNvblNjaGVtYSkgPyBcImpzb25cIiA6IFwidGV4dFwiKSxcbiAgICAgICAgc2NoZW1hOiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgICAgICBzY2hlbWE6IChfZCA9IG9wdGlvbnMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2Quc2NoZW1hLFxuICAgICAgICAgIGpzb25TY2hlbWE6IChfZSA9IG9wdGlvbnMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2UuanNvblNjaGVtYVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFvdXQub3V0cHV0LnNjaGVtYSlcbiAgICAgIGRlbGV0ZSBvdXQub3V0cHV0LnNjaGVtYTtcbiAgICByZXR1cm4gb3V0O1xuICB9KTtcbn1cbmNvbnN0IGlzVmFsaWRDYW5kaWRhdGUgPSAoY2FuZGlkYXRlLCB0b29scykgPT4ge1xuICBjb25zdCB0b29sQ2FsbHMgPSBjYW5kaWRhdGUubWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAocGFydCkgPT4gISFwYXJ0LnRvb2xSZXF1ZXN0XG4gICk7XG4gIHJldHVybiB0b29sQ2FsbHMuZXZlcnkoKHRvb2xDYWxsKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRvb2wgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHMuZmluZChcbiAgICAgICh0b29sMikgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdG9vbDIuX19hY3Rpb24ubmFtZSA9PT0gKChfYTIgPSB0b29sQ2FsbC50b29sUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5uYW1lKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICghdG9vbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHZhbGlkIH0gPSAoMCwgaW1wb3J0X3NjaGVtYS52YWxpZGF0ZVNjaGVtYSkoKF9hID0gdG9vbENhbGwudG9vbFJlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbnB1dCwge1xuICAgICAgc2NoZW1hOiB0b29sLl9fYWN0aW9uLmlucHV0U2NoZW1hLFxuICAgICAganNvblNjaGVtYTogdG9vbC5fX2FjdGlvbi5pbnB1dEpzb25TY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVNb2RlbChvcHRpb25zKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIGlmICgoX2IgPSAoX2EgPSBpbXBvcnRfY29yZS5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZGVmYXVsdE1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gdHlwZW9mIGltcG9ydF9jb3JlLmNvbmZpZy5vcHRpb25zLmRlZmF1bHRNb2RlbC5uYW1lID09PSBcInN0cmluZ1wiID8gaW1wb3J0X2NvcmUuY29uZmlnLm9wdGlvbnMuZGVmYXVsdE1vZGVsLm5hbWUgOiBpbXBvcnRfY29yZS5jb25maWcub3B0aW9ucy5kZWZhdWx0TW9kZWwubmFtZS5uYW1lO1xuICAgICAgICBpZiAoKCFvcHRpb25zLmNvbmZpZyB8fCBPYmplY3Qua2V5cyhvcHRpb25zLmNvbmZpZykubGVuZ3RoID09PSAwKSAmJiBpbXBvcnRfY29yZS5jb25maWcub3B0aW9ucy5kZWZhdWx0TW9kZWwuY29uZmlnKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb25maWcgPSBpbXBvcnRfY29yZS5jb25maWcub3B0aW9ucy5kZWZhdWx0TW9kZWwuY29uZmlnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBtb2RlbC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbW9kZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9tb2RlbC8ke21vZGVsfWApO1xuICAgIH0gZWxzZSBpZiAobW9kZWwuaGFzT3duUHJvcGVydHkoXCJpbmZvXCIpKSB7XG4gICAgICBjb25zdCByZWYgPSBtb2RlbDtcbiAgICAgIHJldHVybiB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9tb2RlbC8ke3JlZi5uYW1lfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIE5vVmFsaWRDYW5kaWRhdGVzRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29yZS5HZW5raXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlc3BvbnNlLFxuICAgIGRldGFpbFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgc3RhdHVzOiBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkZXRhaWxcbiAgICB9KTtcbiAgICB0aGlzLmRldGFpbCA9IF9fc3ByZWFkVmFsdWVzKHsgcmVzcG9uc2UgfSwgZGV0YWlsKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGUob3B0aW9ucykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsID0geWllbGQgcmVzb2x2ZU1vZGVsKHJlc29sdmVkT3B0aW9ucyk7XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2RlbCAke0pTT04uc3RyaW5naWZ5KHJlc29sdmVkT3B0aW9ucy5tb2RlbCl9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBsZXQgdG9vbHM7XG4gICAgaWYgKChfYSA9IHJlc29sdmVkT3B0aW9ucy50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgaWYgKCEoKF9jID0gKF9iID0gbW9kZWwuX19hY3Rpb24ubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5tb2RlbC5zdXBwb3J0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRvb2xzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE1vZGVsICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2ZWRPcHRpb25zLm1vZGVsKX0gZG9lcyBub3Qgc3VwcG9ydCB0b29scywgYnV0IHNvbWUgdG9vbHMgd2VyZSBzdXBwbGllZCB0byBnZW5lcmF0ZSgpLiBQbGVhc2UgY2FsbCBnZW5lcmF0ZSgpIHdpdGhvdXQgdG9vbHMgaWYgeW91IHdvdWxkIGxpa2UgdG8gdXNlIHRoaXMgbW9kZWwuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdG9vbHMgPSB5aWVsZCAoMCwgaW1wb3J0X3Rvb2wucmVzb2x2ZVRvb2xzKShyZXNvbHZlZE9wdGlvbnMudG9vbHMpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0geWllbGQgdG9HZW5lcmF0ZVJlcXVlc3QocmVzb2x2ZWRPcHRpb25zKTtcbiAgICBjb25zdCBhY2N1bXVsYXRlZENodW5rcyA9IFtdO1xuICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgKDAsIGltcG9ydF9jb3JlLnJ1bldpdGhTdHJlYW1pbmdDYWxsYmFjaykoXG4gICAgICByZXNvbHZlZE9wdGlvbnMuc3RyZWFtaW5nQ2FsbGJhY2sgPyAoY2h1bmspID0+IHtcbiAgICAgICAgYWNjdW11bGF0ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuc3RyZWFtaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXNvbHZlZE9wdGlvbnMuc3RyZWFtaW5nQ2FsbGJhY2soXG4gICAgICAgICAgICBuZXcgR2VuZXJhdGVSZXNwb25zZUNodW5rKGNodW5rLCBhY2N1bXVsYXRlZENodW5rcylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IDogdm9pZCAwLFxuICAgICAgKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlUmVzcG9uc2UoeWllbGQgbW9kZWwocmVxdWVzdCksIHJlcXVlc3QpO1xuICAgICAgfSlcbiAgICApO1xuICAgIGlmICghcmVzcG9uc2UuY2FuZGlkYXRlcy5zb21lKFxuICAgICAgKGMpID0+IFtcInN0b3BcIiwgXCJsZW5ndGhcIl0uaW5jbHVkZXMoYy5maW5pc2hSZWFzb24pXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IE5vVmFsaWRDYW5kaWRhdGVzRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQWxsIGNhbmRpZGF0ZXMgcmV0dXJuZWQgZmluaXNoUmVhc29uIGlzc3VlczogJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5jYW5kaWRhdGVzLm1hcCgoYykgPT4gYy5maW5pc2hSZWFzb24pKX1gLFxuICAgICAgICByZXNwb25zZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoKF9kID0gcmVzb2x2ZWRPcHRpb25zLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNjaGVtYSkgfHwgKChfZSA9IHJlc29sdmVkT3B0aW9ucy5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfZS5qc29uU2NoZW1hKSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlRXJyb3JzID0gcmVzcG9uc2UuY2FuZGlkYXRlcy5tYXAoKGMpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgICBpZiAoYy50ZXh0KCkgPT09IFwiXCIgJiYgYy5kYXRhKCkgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgKDAsIGltcG9ydF9zY2hlbWEucGFyc2VTY2hlbWEpKGMub3V0cHV0KCksIHtcbiAgICAgICAgICAgIGpzb25TY2hlbWE6IChfYTIgPSByZXNvbHZlZE9wdGlvbnMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmpzb25TY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWE6IChfYjIgPSByZXNvbHZlZE9wdGlvbnMub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnNjaGVtYVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGNhbmRpZGF0ZUVycm9ycy5ldmVyeSgoYykgPT4gISFjKSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9WYWxpZENhbmRpZGF0ZXNFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYEdlbmVyYXRpb24gcmVzdWx0ZWQgaW4gbm8gY2FuZGlkYXRlcyBtYXRjaGluZyBwcm92aWRlZCBvdXRwdXQgc2NoZW1hLiR7Y2FuZGlkYXRlRXJyb3JzLm1hcCgoZSwgaSkgPT4gYFxuXG5DYW5kaWRhdGVbJHtpfV0gJHtlLnRvU3RyaW5nKCl9YCl9YCxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZUVycm9yc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzZWxlY3RlZDtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiByZXNwb25zZS5jYW5kaWRhdGVzKSB7XG4gICAgICBpZiAoaXNWYWxpZENhbmRpZGF0ZShjYW5kaWRhdGUsIHRvb2xzIHx8IFtdKSkge1xuICAgICAgICBzZWxlY3RlZCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIGNhbmRpZGF0ZXMgZm91bmRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRvb2xDYWxscyA9IHNlbGVjdGVkLm1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAocGFydCkgPT4gISFwYXJ0LnRvb2xSZXF1ZXN0XG4gICAgKTtcbiAgICBpZiAocmVzb2x2ZWRPcHRpb25zLnJldHVyblRvb2xSZXF1ZXN0cyB8fCB0b29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGNvbnN0IHRvb2xSZXNwb25zZXMgPSB5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgIHRvb2xDYWxscy5tYXAoKHBhcnQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKCFwYXJ0LnRvb2xSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRvb2wgcmVxdWVzdCBleHBlY3RlZCBidXQgbm90IHByb3ZpZGVkIGluIHRvb2wgcmVxdWVzdCBwYXJ0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2wgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHMuZmluZChcbiAgICAgICAgICAodG9vbDIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICByZXR1cm4gdG9vbDIuX19hY3Rpb24ubmFtZSA9PT0gKChfYTMgPSBwYXJ0LnRvb2xSZXF1ZXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJUb29sIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvb2xSZXNwb25zZToge1xuICAgICAgICAgICAgbmFtZTogcGFydC50b29sUmVxdWVzdC5uYW1lLFxuICAgICAgICAgICAgcmVmOiBwYXJ0LnRvb2xSZXF1ZXN0LnJlZixcbiAgICAgICAgICAgIG91dHB1dDogeWllbGQgdG9vbCgoX2EyID0gcGFydC50b29sUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pbnB1dClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSlcbiAgICApO1xuICAgIHJlc29sdmVkT3B0aW9ucy5oaXN0b3J5ID0gcmVxdWVzdC5tZXNzYWdlcztcbiAgICByZXNvbHZlZE9wdGlvbnMuaGlzdG9yeS5wdXNoKHNlbGVjdGVkLm1lc3NhZ2UpO1xuICAgIHJlc29sdmVkT3B0aW9ucy5wcm9tcHQgPSB0b29sUmVzcG9uc2VzO1xuICAgIHJldHVybiB5aWVsZCBnZW5lcmF0ZShyZXNvbHZlZE9wdGlvbnMpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlLCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiBbcmVzb2x2ZSwgcmVqZWN0XSA9IFtyZXMsIHJlal0pO1xuICByZXR1cm4geyByZXNvbHZlLCByZWplY3QsIHByb21pc2UgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3RyZWFtKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZmlyc3RDaHVua1NlbnQgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXG4gICAgICAoaW5pdGlhbFJlc29sdmUsIGluaXRpYWxSZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc29sdmU6IGZpbmFsUmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IGZpbmFsUmVqZWN0LFxuICAgICAgICAgIHByb21pc2U6IGZpbmFsUHJvbWlzZVxuICAgICAgICB9ID0gY3JlYXRlUHJvbWlzZSgpO1xuICAgICAgICBsZXQgcHJvdmlkZU5leHRDaHVuaywgbmV4dENodW5rO1xuICAgICAgICAoeyByZXNvbHZlOiBwcm92aWRlTmV4dENodW5rLCBwcm9taXNlOiBuZXh0Q2h1bmsgfSA9IGNyZWF0ZVByb21pc2UoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGNodW5rU3RyZWFtKCkge1xuICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0ID0geWllbGQgbmV3IF9fYXdhaXQobmV4dENodW5rKTtcbiAgICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB5aWVsZCBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2VuZXJhdGUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICAgIHN0cmVhbWluZ0NhbGxiYWNrOiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgZmlyc3RDaHVua1NlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICBwcm92aWRlTmV4dENodW5rKGNodW5rKTtcbiAgICAgICAgICAgICAgKHsgcmVzb2x2ZTogcHJvdmlkZU5leHRDaHVuaywgcHJvbWlzZTogbmV4dENodW5rIH0gPSBjcmVhdGVQcm9taXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHByb3ZpZGVOZXh0Q2h1bmsobnVsbCk7XG4gICAgICAgICAgICBmaW5hbFJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICghZmlyc3RDaHVua1NlbnQpIHtcbiAgICAgICAgICAgIGluaXRpYWxSZWplY3QoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3ZpZGVOZXh0Q2h1bmsobnVsbCk7XG4gICAgICAgICAgZmluYWxSZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFJlc29sdmUoe1xuICAgICAgICAgIHJlc3BvbnNlOiAoKSA9PiBmaW5hbFByb21pc2UsXG4gICAgICAgICAgc3RyZWFtOiBjaHVua1N0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDYW5kaWRhdGUsXG4gIEdlbmVyYXRlUmVzcG9uc2UsXG4gIEdlbmVyYXRlUmVzcG9uc2VDaHVuayxcbiAgTWVzc2FnZSxcbiAgTm9WYWxpZENhbmRpZGF0ZXNFcnJvcixcbiAgZ2VuZXJhdGUsXG4gIGdlbmVyYXRlU3RyZWFtLFxuICB0b0dlbmVyYXRlUmVxdWVzdFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js":
/*!*************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/model.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar model_exports = {};\n__export(model_exports, {\n  CandidateErrorSchema: () => CandidateErrorSchema,\n  CandidateSchema: () => CandidateSchema,\n  CustomPartSchema: () => CustomPartSchema,\n  DataPartSchema: () => DataPartSchema,\n  GenerateRequestSchema: () => GenerateRequestSchema,\n  GenerateResponseChunkSchema: () => GenerateResponseChunkSchema,\n  GenerateResponseSchema: () => GenerateResponseSchema,\n  GenerationCommonConfigSchema: () => GenerationCommonConfigSchema,\n  GenerationUsageSchema: () => GenerationUsageSchema,\n  MediaPartSchema: () => MediaPartSchema,\n  MessageSchema: () => MessageSchema,\n  ModelInfoSchema: () => ModelInfoSchema,\n  PartSchema: () => PartSchema,\n  RoleSchema: () => RoleSchema,\n  TextPartSchema: () => TextPartSchema,\n  ToolDefinitionSchema: () => ToolDefinitionSchema,\n  ToolRequestPartSchema: () => ToolRequestPartSchema,\n  ToolResponsePartSchema: () => ToolResponsePartSchema,\n  defineModel: () => defineModel,\n  getBasicUsageStats: () => getBasicUsageStats,\n  modelRef: () => modelRef\n});\nmodule.exports = __toCommonJS(model_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar clc = __toESM(__webpack_require__(/*! colorette */ \"(action-browser)/./node_modules/colorette/index.cjs\"));\nvar import_node_perf_hooks = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_middleware = __webpack_require__(/*! ./model/middleware.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js\");\nconst EmptyPartSchema = import_zod.z.object({\n  text: import_zod.z.never().optional(),\n  media: import_zod.z.never().optional(),\n  toolRequest: import_zod.z.never().optional(),\n  toolResponse: import_zod.z.never().optional(),\n  data: import_zod.z.unknown().optional(),\n  metadata: import_zod.z.record(import_zod.z.unknown()).optional(),\n  custom: import_zod.z.record(import_zod.z.unknown()).optional()\n});\nconst TextPartSchema = EmptyPartSchema.extend({\n  /** The text of the message. */\n  text: import_zod.z.string()\n});\nconst MediaPartSchema = EmptyPartSchema.extend({\n  media: import_zod.z.object({\n    /** The media content type. Inferred from data uri if not provided. */\n    contentType: import_zod.z.string().optional(),\n    /** A `data:` or `https:` uri containing the media content.  */\n    url: import_zod.z.string()\n  })\n});\nconst ToolRequestPartSchema = EmptyPartSchema.extend({\n  /** A request for a tool to be executed, usually provided by a model. */\n  toolRequest: import_zod.z.object({\n    /** The call id or reference for a specific request. */\n    ref: import_zod.z.string().optional(),\n    /** The name of the tool to call. */\n    name: import_zod.z.string(),\n    /** The input parameters for the tool, usually a JSON object. */\n    input: import_zod.z.unknown().optional()\n  })\n});\nconst ToolResponsePartSchema = EmptyPartSchema.extend({\n  /** A provided response to a tool call. */\n  toolResponse: import_zod.z.object({\n    /** The call id or reference for a specific request. */\n    ref: import_zod.z.string().optional(),\n    /** The name of the tool. */\n    name: import_zod.z.string(),\n    /** The output data returned from the tool, usually a JSON object. */\n    output: import_zod.z.unknown().optional()\n  })\n});\nconst DataPartSchema = EmptyPartSchema.extend({\n  data: import_zod.z.unknown()\n});\nconst CustomPartSchema = EmptyPartSchema.extend({\n  custom: import_zod.z.record(import_zod.z.any())\n});\nconst PartSchema = import_zod.z.union([\n  TextPartSchema,\n  MediaPartSchema,\n  ToolRequestPartSchema,\n  ToolResponsePartSchema,\n  DataPartSchema,\n  CustomPartSchema\n]);\nconst RoleSchema = import_zod.z.enum([\"system\", \"user\", \"model\", \"tool\"]);\nconst MessageSchema = import_zod.z.object({\n  role: RoleSchema,\n  content: import_zod.z.array(PartSchema),\n  metadata: import_zod.z.record(import_zod.z.unknown()).optional()\n});\nconst OutputFormatSchema = import_zod.z.enum([\"json\", \"text\", \"media\"]);\nconst ModelInfoSchema = import_zod.z.object({\n  /** Acceptable names for this model (e.g. different versions). */\n  versions: import_zod.z.array(import_zod.z.string()).optional(),\n  /** Friendly label for this model (e.g. \"Google AI - Gemini Pro\") */\n  label: import_zod.z.string().optional(),\n  /** Supported model capabilities. */\n  supports: import_zod.z.object({\n    /** Model can process historical messages passed with a prompt. */\n    multiturn: import_zod.z.boolean().optional(),\n    /** Model can process media as part of the prompt (multimodal input). */\n    media: import_zod.z.boolean().optional(),\n    /** Model can perform tool calls. */\n    tools: import_zod.z.boolean().optional(),\n    /** Model can accept messages with role \"system\". */\n    systemRole: import_zod.z.boolean().optional(),\n    /** Model can output this type of data. */\n    output: import_zod.z.array(OutputFormatSchema).optional(),\n    /** Model can natively support document-based context grounding. */\n    context: import_zod.z.boolean().optional()\n  }).optional(),\n  /** At which stage of development this model is.\n   * - `featured` models are recommended for general use.\n   * - `stable` models are well-tested and reliable.\n   * - `unstable` models are experimental and may change.\n   * - `legacy` models are no longer recommended for new projects.\n   * - `deprecated` models are deprecated by the provider and may be removed in future versions.\n   */\n  stage: import_zod.z.enum([\"featured\", \"stable\", \"unstable\", \"legacy\", \"deprecated\"]).optional()\n});\nconst ToolDefinitionSchema = import_zod.z.object({\n  name: import_zod.z.string(),\n  description: import_zod.z.string(),\n  inputSchema: import_zod.z.record(import_zod.z.any()).describe(\"Valid JSON Schema representing the input of the tool.\"),\n  outputSchema: import_zod.z.record(import_zod.z.any()).describe(\"Valid JSON Schema describing the output of the tool.\").optional()\n});\nconst GenerationCommonConfigSchema = import_zod.z.object({\n  /** A specific version of a model family, e.g. `gemini-1.0-pro-001` for the `gemini-1.0-pro` family. */\n  version: import_zod.z.string().optional(),\n  temperature: import_zod.z.number().optional(),\n  maxOutputTokens: import_zod.z.number().optional(),\n  topK: import_zod.z.number().optional(),\n  topP: import_zod.z.number().optional(),\n  stopSequences: import_zod.z.array(import_zod.z.string()).optional()\n});\nconst OutputConfigSchema = import_zod.z.object({\n  format: OutputFormatSchema.optional(),\n  schema: import_zod.z.record(import_zod.z.any()).optional()\n});\nconst GenerateRequestSchema = import_zod.z.object({\n  messages: import_zod.z.array(MessageSchema),\n  config: import_zod.z.any().optional(),\n  tools: import_zod.z.array(ToolDefinitionSchema).optional(),\n  output: OutputConfigSchema.optional(),\n  context: import_zod.z.array(import_document.DocumentDataSchema).optional(),\n  candidates: import_zod.z.number().optional()\n});\nconst GenerationUsageSchema = import_zod.z.object({\n  inputTokens: import_zod.z.number().optional(),\n  outputTokens: import_zod.z.number().optional(),\n  totalTokens: import_zod.z.number().optional(),\n  inputCharacters: import_zod.z.number().optional(),\n  outputCharacters: import_zod.z.number().optional(),\n  inputImages: import_zod.z.number().optional(),\n  outputImages: import_zod.z.number().optional(),\n  inputVideos: import_zod.z.number().optional(),\n  outputVideos: import_zod.z.number().optional(),\n  inputAudioFiles: import_zod.z.number().optional(),\n  outputAudioFiles: import_zod.z.number().optional(),\n  custom: import_zod.z.record(import_zod.z.number()).optional()\n});\nconst CandidateSchema = import_zod.z.object({\n  index: import_zod.z.number(),\n  message: MessageSchema,\n  usage: GenerationUsageSchema.optional(),\n  finishReason: import_zod.z.enum([\"stop\", \"length\", \"blocked\", \"other\", \"unknown\"]),\n  finishMessage: import_zod.z.string().optional(),\n  custom: import_zod.z.unknown()\n});\nconst CandidateErrorSchema = import_zod.z.object({\n  index: import_zod.z.number(),\n  code: import_zod.z.enum([\"blocked\", \"other\", \"unknown\"]),\n  message: import_zod.z.string().optional()\n});\nconst GenerateResponseSchema = import_zod.z.object({\n  candidates: import_zod.z.array(CandidateSchema),\n  latencyMs: import_zod.z.number().optional(),\n  usage: GenerationUsageSchema.optional(),\n  custom: import_zod.z.unknown(),\n  request: GenerateRequestSchema.optional()\n});\nconst GenerateResponseChunkSchema = import_zod.z.object({\n  /** The index of the candidate this chunk belongs to. */\n  index: import_zod.z.number(),\n  /** The chunk of content to stream right now. */\n  content: import_zod.z.array(PartSchema),\n  /** Model-specific extra information attached to this chunk. */\n  custom: import_zod.z.unknown().optional()\n});\nfunction defineModel(options, runner) {\n  var _a;\n  const label = options.label || options.name;\n  const middleware = [\n    ...options.use || [],\n    (0, import_middleware.validateSupport)(options)\n  ];\n  if (!((_a = options == null ? void 0 : options.supports) == null ? void 0 : _a.context))\n    middleware.push((0, import_middleware.augmentWithContext)());\n  middleware.push((0, import_middleware.conformOutput)());\n  const act = (0, import_core.defineAction)(\n    {\n      actionType: \"model\",\n      name: options.name,\n      description: label,\n      inputSchema: GenerateRequestSchema,\n      outputSchema: GenerateResponseSchema,\n      metadata: {\n        model: {\n          label,\n          customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0,\n          versions: options.versions,\n          supports: options.supports\n        }\n      },\n      use: middleware\n    },\n    (input) => {\n      const startTimeMs = import_node_perf_hooks.performance.now();\n      return runner(input, (0, import_core.getStreamingCallback)()).then((response) => {\n        const timedResponse = __spreadProps(__spreadValues({}, response), {\n          latencyMs: import_node_perf_hooks.performance.now() - startTimeMs\n        });\n        return timedResponse;\n      });\n    }\n  );\n  Object.assign(act, {\n    __configSchema: options.configSchema || import_zod.z.unknown()\n  });\n  return act;\n}\nfunction modelRef(options) {\n  var _a;\n  if (((_a = options.info) == null ? void 0 : _a.stage) === \"deprecated\") {\n    deprecateModel({ name: options.name });\n  }\n  return __spreadValues({}, options);\n}\nfunction deprecateModel(options) {\n  console.warn(\n    `${clc.bold(clc.yellow(\"Warning:\"))} Model '${options.name}' is deprecated and may be removed in a future release.`\n  );\n}\nfunction getBasicUsageStats(input, candidates) {\n  const inputCounts = getPartCounts(input.flatMap((md) => md.content));\n  const outputCounts = getPartCounts(\n    candidates.flatMap((c) => c.message.content)\n  );\n  return {\n    inputCharacters: inputCounts.characters,\n    inputImages: inputCounts.images,\n    inputVideos: inputCounts.videos,\n    inputAudioFiles: inputCounts.audio,\n    outputCharacters: outputCounts.characters,\n    outputImages: outputCounts.images,\n    outputVideos: outputCounts.videos,\n    outputAudioFiles: outputCounts.audio\n  };\n}\nfunction getPartCounts(parts) {\n  return parts.reduce(\n    (counts, part) => {\n      var _a, _b, _c, _d, _e, _f, _g;\n      return {\n        characters: counts.characters + (((_a = part.text) == null ? void 0 : _a.length) || 0),\n        images: counts.images + (((_c = (_b = part.media) == null ? void 0 : _b.contentType) == null ? void 0 : _c.startsWith(\"image\")) ? 1 : 0),\n        videos: counts.videos + (((_e = (_d = part.media) == null ? void 0 : _d.contentType) == null ? void 0 : _e.startsWith(\"video\")) ? 1 : 0),\n        audio: counts.audio + (((_g = (_f = part.media) == null ? void 0 : _f.contentType) == null ? void 0 : _g.startsWith(\"audio\")) ? 1 : 0)\n      };\n    },\n    { characters: 0, images: 0, videos: 0, audio: 0 }\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=model.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyx3Q0FBaUI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsMERBQUs7QUFDOUIsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWU7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMsb0dBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw4QkFBOEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtDQUFrQyxTQUFTLGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FzQkw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC5qcz82YzYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIG1vZGVsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1vZGVsX2V4cG9ydHMsIHtcbiAgQ2FuZGlkYXRlRXJyb3JTY2hlbWE6ICgpID0+IENhbmRpZGF0ZUVycm9yU2NoZW1hLFxuICBDYW5kaWRhdGVTY2hlbWE6ICgpID0+IENhbmRpZGF0ZVNjaGVtYSxcbiAgQ3VzdG9tUGFydFNjaGVtYTogKCkgPT4gQ3VzdG9tUGFydFNjaGVtYSxcbiAgRGF0YVBhcnRTY2hlbWE6ICgpID0+IERhdGFQYXJ0U2NoZW1hLFxuICBHZW5lcmF0ZVJlcXVlc3RTY2hlbWE6ICgpID0+IEdlbmVyYXRlUmVxdWVzdFNjaGVtYSxcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hOiAoKSA9PiBHZW5lcmF0ZVJlc3BvbnNlQ2h1bmtTY2hlbWEsXG4gIEdlbmVyYXRlUmVzcG9uc2VTY2hlbWE6ICgpID0+IEdlbmVyYXRlUmVzcG9uc2VTY2hlbWEsXG4gIEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWE6ICgpID0+IEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEsXG4gIEdlbmVyYXRpb25Vc2FnZVNjaGVtYTogKCkgPT4gR2VuZXJhdGlvblVzYWdlU2NoZW1hLFxuICBNZWRpYVBhcnRTY2hlbWE6ICgpID0+IE1lZGlhUGFydFNjaGVtYSxcbiAgTWVzc2FnZVNjaGVtYTogKCkgPT4gTWVzc2FnZVNjaGVtYSxcbiAgTW9kZWxJbmZvU2NoZW1hOiAoKSA9PiBNb2RlbEluZm9TY2hlbWEsXG4gIFBhcnRTY2hlbWE6ICgpID0+IFBhcnRTY2hlbWEsXG4gIFJvbGVTY2hlbWE6ICgpID0+IFJvbGVTY2hlbWEsXG4gIFRleHRQYXJ0U2NoZW1hOiAoKSA9PiBUZXh0UGFydFNjaGVtYSxcbiAgVG9vbERlZmluaXRpb25TY2hlbWE6ICgpID0+IFRvb2xEZWZpbml0aW9uU2NoZW1hLFxuICBUb29sUmVxdWVzdFBhcnRTY2hlbWE6ICgpID0+IFRvb2xSZXF1ZXN0UGFydFNjaGVtYSxcbiAgVG9vbFJlc3BvbnNlUGFydFNjaGVtYTogKCkgPT4gVG9vbFJlc3BvbnNlUGFydFNjaGVtYSxcbiAgZGVmaW5lTW9kZWw6ICgpID0+IGRlZmluZU1vZGVsLFxuICBnZXRCYXNpY1VzYWdlU3RhdHM6ICgpID0+IGdldEJhc2ljVXNhZ2VTdGF0cyxcbiAgbW9kZWxSZWY6ICgpID0+IG1vZGVsUmVmXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKG1vZGVsX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9zY2hlbWFcIik7XG52YXIgY2xjID0gX190b0VTTShyZXF1aXJlKFwiY29sb3JldHRlXCIpKTtcbnZhciBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzID0gcmVxdWlyZShcIm5vZGU6cGVyZl9ob29rc1wiKTtcbnZhciBpbXBvcnRfem9kID0gcmVxdWlyZShcInpvZFwiKTtcbnZhciBpbXBvcnRfZG9jdW1lbnQgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbnZhciBpbXBvcnRfbWlkZGxld2FyZSA9IHJlcXVpcmUoXCIuL21vZGVsL21pZGRsZXdhcmUuanNcIik7XG5jb25zdCBFbXB0eVBhcnRTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgdGV4dDogaW1wb3J0X3pvZC56Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgbWVkaWE6IGltcG9ydF96b2Quei5uZXZlcigpLm9wdGlvbmFsKCksXG4gIHRvb2xSZXF1ZXN0OiBpbXBvcnRfem9kLnoubmV2ZXIoKS5vcHRpb25hbCgpLFxuICB0b29sUmVzcG9uc2U6IGltcG9ydF96b2Quei5uZXZlcigpLm9wdGlvbmFsKCksXG4gIGRhdGE6IGltcG9ydF96b2Quei51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgbWV0YWRhdGE6IGltcG9ydF96b2Quei5yZWNvcmQoaW1wb3J0X3pvZC56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbiAgY3VzdG9tOiBpbXBvcnRfem9kLnoucmVjb3JkKGltcG9ydF96b2Quei51bmtub3duKCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVGV4dFBhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgLyoqIFRoZSB0ZXh0IG9mIHRoZSBtZXNzYWdlLiAqL1xuICB0ZXh0OiBpbXBvcnRfem9kLnouc3RyaW5nKClcbn0pO1xuY29uc3QgTWVkaWFQYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIG1lZGlhOiBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgICAvKiogVGhlIG1lZGlhIGNvbnRlbnQgdHlwZS4gSW5mZXJyZWQgZnJvbSBkYXRhIHVyaSBpZiBub3QgcHJvdmlkZWQuICovXG4gICAgY29udGVudFR5cGU6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIC8qKiBBIGBkYXRhOmAgb3IgYGh0dHBzOmAgdXJpIGNvbnRhaW5pbmcgdGhlIG1lZGlhIGNvbnRlbnQuICAqL1xuICAgIHVybDogaW1wb3J0X3pvZC56LnN0cmluZygpXG4gIH0pXG59KTtcbmNvbnN0IFRvb2xSZXF1ZXN0UGFydFNjaGVtYSA9IEVtcHR5UGFydFNjaGVtYS5leHRlbmQoe1xuICAvKiogQSByZXF1ZXN0IGZvciBhIHRvb2wgdG8gYmUgZXhlY3V0ZWQsIHVzdWFsbHkgcHJvdmlkZWQgYnkgYSBtb2RlbC4gKi9cbiAgdG9vbFJlcXVlc3Q6IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICAgIC8qKiBUaGUgY2FsbCBpZCBvciByZWZlcmVuY2UgZm9yIGEgc3BlY2lmaWMgcmVxdWVzdC4gKi9cbiAgICByZWY6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgdG9vbCB0byBjYWxsLiAqL1xuICAgIG5hbWU6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgICAvKiogVGhlIGlucHV0IHBhcmFtZXRlcnMgZm9yIHRoZSB0b29sLCB1c3VhbGx5IGEgSlNPTiBvYmplY3QuICovXG4gICAgaW5wdXQ6IGltcG9ydF96b2Quei51bmtub3duKCkub3B0aW9uYWwoKVxuICB9KVxufSk7XG5jb25zdCBUb29sUmVzcG9uc2VQYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIC8qKiBBIHByb3ZpZGVkIHJlc3BvbnNlIHRvIGEgdG9vbCBjYWxsLiAqL1xuICB0b29sUmVzcG9uc2U6IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICAgIC8qKiBUaGUgY2FsbCBpZCBvciByZWZlcmVuY2UgZm9yIGEgc3BlY2lmaWMgcmVxdWVzdC4gKi9cbiAgICByZWY6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgdG9vbC4gKi9cbiAgICBuYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gICAgLyoqIFRoZSBvdXRwdXQgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSB0b29sLCB1c3VhbGx5IGEgSlNPTiBvYmplY3QuICovXG4gICAgb3V0cHV0OiBpbXBvcnRfem9kLnoudW5rbm93bigpLm9wdGlvbmFsKClcbiAgfSlcbn0pO1xuY29uc3QgRGF0YVBhcnRTY2hlbWEgPSBFbXB0eVBhcnRTY2hlbWEuZXh0ZW5kKHtcbiAgZGF0YTogaW1wb3J0X3pvZC56LnVua25vd24oKVxufSk7XG5jb25zdCBDdXN0b21QYXJ0U2NoZW1hID0gRW1wdHlQYXJ0U2NoZW1hLmV4dGVuZCh7XG4gIGN1c3RvbTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouYW55KCkpXG59KTtcbmNvbnN0IFBhcnRTY2hlbWEgPSBpbXBvcnRfem9kLnoudW5pb24oW1xuICBUZXh0UGFydFNjaGVtYSxcbiAgTWVkaWFQYXJ0U2NoZW1hLFxuICBUb29sUmVxdWVzdFBhcnRTY2hlbWEsXG4gIFRvb2xSZXNwb25zZVBhcnRTY2hlbWEsXG4gIERhdGFQYXJ0U2NoZW1hLFxuICBDdXN0b21QYXJ0U2NoZW1hXG5dKTtcbmNvbnN0IFJvbGVTY2hlbWEgPSBpbXBvcnRfem9kLnouZW51bShbXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwibW9kZWxcIiwgXCJ0b29sXCJdKTtcbmNvbnN0IE1lc3NhZ2VTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgcm9sZTogUm9sZVNjaGVtYSxcbiAgY29udGVudDogaW1wb3J0X3pvZC56LmFycmF5KFBhcnRTY2hlbWEpLFxuICBtZXRhZGF0YTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnoudW5rbm93bigpKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IE91dHB1dEZvcm1hdFNjaGVtYSA9IGltcG9ydF96b2Quei5lbnVtKFtcImpzb25cIiwgXCJ0ZXh0XCIsIFwibWVkaWFcIl0pO1xuY29uc3QgTW9kZWxJbmZvU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIC8qKiBBY2NlcHRhYmxlIG5hbWVzIGZvciB0aGlzIG1vZGVsIChlLmcuIGRpZmZlcmVudCB2ZXJzaW9ucykuICovXG4gIHZlcnNpb25zOiBpbXBvcnRfem9kLnouYXJyYXkoaW1wb3J0X3pvZC56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAvKiogRnJpZW5kbHkgbGFiZWwgZm9yIHRoaXMgbW9kZWwgKGUuZy4gXCJHb29nbGUgQUkgLSBHZW1pbmkgUHJvXCIpICovXG4gIGxhYmVsOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgICAvKiogTW9kZWwgY2FuIHByb2Nlc3MgaGlzdG9yaWNhbCBtZXNzYWdlcyBwYXNzZWQgd2l0aCBhIHByb21wdC4gKi9cbiAgICBtdWx0aXR1cm46IGltcG9ydF96b2Quei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAvKiogTW9kZWwgY2FuIHByb2Nlc3MgbWVkaWEgYXMgcGFydCBvZiB0aGUgcHJvbXB0IChtdWx0aW1vZGFsIGlucHV0KS4gKi9cbiAgICBtZWRpYTogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gcGVyZm9ybSB0b29sIGNhbGxzLiAqL1xuICAgIHRvb2xzOiBpbXBvcnRfem9kLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgLyoqIE1vZGVsIGNhbiBhY2NlcHQgbWVzc2FnZXMgd2l0aCByb2xlIFwic3lzdGVtXCIuICovXG4gICAgc3lzdGVtUm9sZTogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBNb2RlbCBjYW4gb3V0cHV0IHRoaXMgdHlwZSBvZiBkYXRhLiAqL1xuICAgIG91dHB1dDogaW1wb3J0X3pvZC56LmFycmF5KE91dHB1dEZvcm1hdFNjaGVtYSkub3B0aW9uYWwoKSxcbiAgICAvKiogTW9kZWwgY2FuIG5hdGl2ZWx5IHN1cHBvcnQgZG9jdW1lbnQtYmFzZWQgY29udGV4dCBncm91bmRpbmcuICovXG4gICAgY29udGV4dDogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gIH0pLm9wdGlvbmFsKCksXG4gIC8qKiBBdCB3aGljaCBzdGFnZSBvZiBkZXZlbG9wbWVudCB0aGlzIG1vZGVsIGlzLlxuICAgKiAtIGBmZWF0dXJlZGAgbW9kZWxzIGFyZSByZWNvbW1lbmRlZCBmb3IgZ2VuZXJhbCB1c2UuXG4gICAqIC0gYHN0YWJsZWAgbW9kZWxzIGFyZSB3ZWxsLXRlc3RlZCBhbmQgcmVsaWFibGUuXG4gICAqIC0gYHVuc3RhYmxlYCBtb2RlbHMgYXJlIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICogLSBgbGVnYWN5YCBtb2RlbHMgYXJlIG5vIGxvbmdlciByZWNvbW1lbmRlZCBmb3IgbmV3IHByb2plY3RzLlxuICAgKiAtIGBkZXByZWNhdGVkYCBtb2RlbHMgYXJlIGRlcHJlY2F0ZWQgYnkgdGhlIHByb3ZpZGVyIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAqL1xuICBzdGFnZTogaW1wb3J0X3pvZC56LmVudW0oW1wiZmVhdHVyZWRcIiwgXCJzdGFibGVcIiwgXCJ1bnN0YWJsZVwiLCBcImxlZ2FjeVwiLCBcImRlcHJlY2F0ZWRcIl0pLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVG9vbERlZmluaXRpb25TY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBkZXNjcmlwdGlvbjogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBpbnB1dFNjaGVtYTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouYW55KCkpLmRlc2NyaWJlKFwiVmFsaWQgSlNPTiBTY2hlbWEgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBvZiB0aGUgdG9vbC5cIiksXG4gIG91dHB1dFNjaGVtYTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouYW55KCkpLmRlc2NyaWJlKFwiVmFsaWQgSlNPTiBTY2hlbWEgZGVzY3JpYmluZyB0aGUgb3V0cHV0IG9mIHRoZSB0b29sLlwiKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEdlbmVyYXRpb25Db21tb25Db25maWdTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgLyoqIEEgc3BlY2lmaWMgdmVyc2lvbiBvZiBhIG1vZGVsIGZhbWlseSwgZS5nLiBgZ2VtaW5pLTEuMC1wcm8tMDAxYCBmb3IgdGhlIGBnZW1pbmktMS4wLXByb2AgZmFtaWx5LiAqL1xuICB2ZXJzaW9uOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdGVtcGVyYXR1cmU6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBtYXhPdXRwdXRUb2tlbnM6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB0b3BLOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgdG9wUDogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIHN0b3BTZXF1ZW5jZXM6IGltcG9ydF96b2Quei5hcnJheShpbXBvcnRfem9kLnouc3RyaW5nKCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgT3V0cHV0Q29uZmlnU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGZvcm1hdDogT3V0cHV0Rm9ybWF0U2NoZW1hLm9wdGlvbmFsKCksXG4gIHNjaGVtYTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouYW55KCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgR2VuZXJhdGVSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIG1lc3NhZ2VzOiBpbXBvcnRfem9kLnouYXJyYXkoTWVzc2FnZVNjaGVtYSksXG4gIGNvbmZpZzogaW1wb3J0X3pvZC56LmFueSgpLm9wdGlvbmFsKCksXG4gIHRvb2xzOiBpbXBvcnRfem9kLnouYXJyYXkoVG9vbERlZmluaXRpb25TY2hlbWEpLm9wdGlvbmFsKCksXG4gIG91dHB1dDogT3V0cHV0Q29uZmlnU2NoZW1hLm9wdGlvbmFsKCksXG4gIGNvbnRleHQ6IGltcG9ydF96b2Quei5hcnJheShpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hKS5vcHRpb25hbCgpLFxuICBjYW5kaWRhdGVzOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBHZW5lcmF0aW9uVXNhZ2VTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgaW5wdXRUb2tlbnM6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBvdXRwdXRUb2tlbnM6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB0b3RhbFRva2VuczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGlucHV0Q2hhcmFjdGVyczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIG91dHB1dENoYXJhY3RlcnM6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBpbnB1dEltYWdlczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIG91dHB1dEltYWdlczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGlucHV0VmlkZW9zOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgb3V0cHV0VmlkZW9zOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgaW5wdXRBdWRpb0ZpbGVzOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgb3V0cHV0QXVkaW9GaWxlczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGN1c3RvbTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnoubnVtYmVyKCkpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgQ2FuZGlkYXRlU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGluZGV4OiBpbXBvcnRfem9kLnoubnVtYmVyKCksXG4gIG1lc3NhZ2U6IE1lc3NhZ2VTY2hlbWEsXG4gIHVzYWdlOiBHZW5lcmF0aW9uVXNhZ2VTY2hlbWEub3B0aW9uYWwoKSxcbiAgZmluaXNoUmVhc29uOiBpbXBvcnRfem9kLnouZW51bShbXCJzdG9wXCIsIFwibGVuZ3RoXCIsIFwiYmxvY2tlZFwiLCBcIm90aGVyXCIsIFwidW5rbm93blwiXSksXG4gIGZpbmlzaE1lc3NhZ2U6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBjdXN0b206IGltcG9ydF96b2Quei51bmtub3duKClcbn0pO1xuY29uc3QgQ2FuZGlkYXRlRXJyb3JTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgaW5kZXg6IGltcG9ydF96b2Quei5udW1iZXIoKSxcbiAgY29kZTogaW1wb3J0X3pvZC56LmVudW0oW1wiYmxvY2tlZFwiLCBcIm90aGVyXCIsIFwidW5rbm93blwiXSksXG4gIG1lc3NhZ2U6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IEdlbmVyYXRlUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgY2FuZGlkYXRlczogaW1wb3J0X3pvZC56LmFycmF5KENhbmRpZGF0ZVNjaGVtYSksXG4gIGxhdGVuY3lNczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIHVzYWdlOiBHZW5lcmF0aW9uVXNhZ2VTY2hlbWEub3B0aW9uYWwoKSxcbiAgY3VzdG9tOiBpbXBvcnRfem9kLnoudW5rbm93bigpLFxuICByZXF1ZXN0OiBHZW5lcmF0ZVJlcXVlc3RTY2hlbWEub3B0aW9uYWwoKVxufSk7XG5jb25zdCBHZW5lcmF0ZVJlc3BvbnNlQ2h1bmtTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgLyoqIFRoZSBpbmRleCBvZiB0aGUgY2FuZGlkYXRlIHRoaXMgY2h1bmsgYmVsb25ncyB0by4gKi9cbiAgaW5kZXg6IGltcG9ydF96b2Quei5udW1iZXIoKSxcbiAgLyoqIFRoZSBjaHVuayBvZiBjb250ZW50IHRvIHN0cmVhbSByaWdodCBub3cuICovXG4gIGNvbnRlbnQ6IGltcG9ydF96b2Quei5hcnJheShQYXJ0U2NoZW1hKSxcbiAgLyoqIE1vZGVsLXNwZWNpZmljIGV4dHJhIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIHRoaXMgY2h1bmsuICovXG4gIGN1c3RvbTogaW1wb3J0X3pvZC56LnVua25vd24oKS5vcHRpb25hbCgpXG59KTtcbmZ1bmN0aW9uIGRlZmluZU1vZGVsKG9wdGlvbnMsIHJ1bm5lcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCBvcHRpb25zLm5hbWU7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBbXG4gICAgLi4ub3B0aW9ucy51c2UgfHwgW10sXG4gICAgKDAsIGltcG9ydF9taWRkbGV3YXJlLnZhbGlkYXRlU3VwcG9ydCkob3B0aW9ucylcbiAgXTtcbiAgaWYgKCEoKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdXBwb3J0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRleHQpKVxuICAgIG1pZGRsZXdhcmUucHVzaCgoMCwgaW1wb3J0X21pZGRsZXdhcmUuYXVnbWVudFdpdGhDb250ZXh0KSgpKTtcbiAgbWlkZGxld2FyZS5wdXNoKCgwLCBpbXBvcnRfbWlkZGxld2FyZS5jb25mb3JtT3V0cHV0KSgpKTtcbiAgY29uc3QgYWN0ID0gKDAsIGltcG9ydF9jb3JlLmRlZmluZUFjdGlvbikoXG4gICAge1xuICAgICAgYWN0aW9uVHlwZTogXCJtb2RlbFwiLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IGxhYmVsLFxuICAgICAgaW5wdXRTY2hlbWE6IEdlbmVyYXRlUmVxdWVzdFNjaGVtYSxcbiAgICAgIG91dHB1dFNjaGVtYTogR2VuZXJhdGVSZXNwb25zZVNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgY3VzdG9tT3B0aW9uczogb3B0aW9ucy5jb25maWdTY2hlbWEgPyAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHsgc2NoZW1hOiBvcHRpb25zLmNvbmZpZ1NjaGVtYSB9KSA6IHZvaWQgMCxcbiAgICAgICAgICB2ZXJzaW9uczogb3B0aW9ucy52ZXJzaW9ucyxcbiAgICAgICAgICBzdXBwb3J0czogb3B0aW9ucy5zdXBwb3J0c1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlOiBtaWRkbGV3YXJlXG4gICAgfSxcbiAgICAoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZU1zID0gaW1wb3J0X25vZGVfcGVyZl9ob29rcy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHJldHVybiBydW5uZXIoaW5wdXQsICgwLCBpbXBvcnRfY29yZS5nZXRTdHJlYW1pbmdDYWxsYmFjaykoKSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgdGltZWRSZXNwb25zZSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3BvbnNlKSwge1xuICAgICAgICAgIGxhdGVuY3lNczogaW1wb3J0X25vZGVfcGVyZl9ob29rcy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZU1zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGltZWRSZXNwb25zZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbiAgT2JqZWN0LmFzc2lnbihhY3QsIHtcbiAgICBfX2NvbmZpZ1NjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgfHwgaW1wb3J0X3pvZC56LnVua25vd24oKVxuICB9KTtcbiAgcmV0dXJuIGFjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsUmVmKG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBpZiAoKChfYSA9IG9wdGlvbnMuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YWdlKSA9PT0gXCJkZXByZWNhdGVkXCIpIHtcbiAgICBkZXByZWNhdGVNb2RlbCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9KTtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlTW9kZWwob3B0aW9ucykge1xuICBjb25zb2xlLndhcm4oXG4gICAgYCR7Y2xjLmJvbGQoY2xjLnllbGxvdyhcIldhcm5pbmc6XCIpKX0gTW9kZWwgJyR7b3B0aW9ucy5uYW1lfScgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5gXG4gICk7XG59XG5mdW5jdGlvbiBnZXRCYXNpY1VzYWdlU3RhdHMoaW5wdXQsIGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgaW5wdXRDb3VudHMgPSBnZXRQYXJ0Q291bnRzKGlucHV0LmZsYXRNYXAoKG1kKSA9PiBtZC5jb250ZW50KSk7XG4gIGNvbnN0IG91dHB1dENvdW50cyA9IGdldFBhcnRDb3VudHMoXG4gICAgY2FuZGlkYXRlcy5mbGF0TWFwKChjKSA9PiBjLm1lc3NhZ2UuY29udGVudClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dENoYXJhY3RlcnM6IGlucHV0Q291bnRzLmNoYXJhY3RlcnMsXG4gICAgaW5wdXRJbWFnZXM6IGlucHV0Q291bnRzLmltYWdlcyxcbiAgICBpbnB1dFZpZGVvczogaW5wdXRDb3VudHMudmlkZW9zLFxuICAgIGlucHV0QXVkaW9GaWxlczogaW5wdXRDb3VudHMuYXVkaW8sXG4gICAgb3V0cHV0Q2hhcmFjdGVyczogb3V0cHV0Q291bnRzLmNoYXJhY3RlcnMsXG4gICAgb3V0cHV0SW1hZ2VzOiBvdXRwdXRDb3VudHMuaW1hZ2VzLFxuICAgIG91dHB1dFZpZGVvczogb3V0cHV0Q291bnRzLnZpZGVvcyxcbiAgICBvdXRwdXRBdWRpb0ZpbGVzOiBvdXRwdXRDb3VudHMuYXVkaW9cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcnRDb3VudHMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnJlZHVjZShcbiAgICAoY291bnRzLCBwYXJ0KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFyYWN0ZXJzOiBjb3VudHMuY2hhcmFjdGVycyArICgoKF9hID0gcGFydC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKSxcbiAgICAgICAgaW1hZ2VzOiBjb3VudHMuaW1hZ2VzICsgKCgoX2MgPSAoX2IgPSBwYXJ0Lm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdGFydHNXaXRoKFwiaW1hZ2VcIikpID8gMSA6IDApLFxuICAgICAgICB2aWRlb3M6IGNvdW50cy52aWRlb3MgKyAoKChfZSA9IChfZCA9IHBhcnQubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnN0YXJ0c1dpdGgoXCJ2aWRlb1wiKSkgPyAxIDogMCksXG4gICAgICAgIGF1ZGlvOiBjb3VudHMuYXVkaW8gKyAoKChfZyA9IChfZiA9IHBhcnQubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnN0YXJ0c1dpdGgoXCJhdWRpb1wiKSkgPyAxIDogMClcbiAgICAgIH07XG4gICAgfSxcbiAgICB7IGNoYXJhY3RlcnM6IDAsIGltYWdlczogMCwgdmlkZW9zOiAwLCBhdWRpbzogMCB9XG4gICk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FuZGlkYXRlRXJyb3JTY2hlbWEsXG4gIENhbmRpZGF0ZVNjaGVtYSxcbiAgQ3VzdG9tUGFydFNjaGVtYSxcbiAgRGF0YVBhcnRTY2hlbWEsXG4gIEdlbmVyYXRlUmVxdWVzdFNjaGVtYSxcbiAgR2VuZXJhdGVSZXNwb25zZUNodW5rU2NoZW1hLFxuICBHZW5lcmF0ZVJlc3BvbnNlU2NoZW1hLFxuICBHZW5lcmF0aW9uQ29tbW9uQ29uZmlnU2NoZW1hLFxuICBHZW5lcmF0aW9uVXNhZ2VTY2hlbWEsXG4gIE1lZGlhUGFydFNjaGVtYSxcbiAgTWVzc2FnZVNjaGVtYSxcbiAgTW9kZWxJbmZvU2NoZW1hLFxuICBQYXJ0U2NoZW1hLFxuICBSb2xlU2NoZW1hLFxuICBUZXh0UGFydFNjaGVtYSxcbiAgVG9vbERlZmluaXRpb25TY2hlbWEsXG4gIFRvb2xSZXF1ZXN0UGFydFNjaGVtYSxcbiAgVG9vbFJlc3BvbnNlUGFydFNjaGVtYSxcbiAgZGVmaW5lTW9kZWwsXG4gIGdldEJhc2ljVXNhZ2VTdGF0cyxcbiAgbW9kZWxSZWZcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js":
/*!************************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/model/middleware.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar middleware_exports = {};\n__export(middleware_exports, {\n  CONTEXT_PREFACE: () => CONTEXT_PREFACE,\n  augmentWithContext: () => augmentWithContext,\n  conformOutput: () => conformOutput,\n  downloadRequestMedia: () => downloadRequestMedia,\n  simulateSystemPrompt: () => simulateSystemPrompt,\n  validateSupport: () => validateSupport\n});\nmodule.exports = __toCommonJS(middleware_exports);\nvar import_document = __webpack_require__(/*! ../document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nfunction downloadRequestMedia(options) {\n  return (req, next) => __async(this, null, function* () {\n    const { default: fetch } = yield Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/fetch-blob\"), __webpack_require__.e(\"vendor-chunks/formdata-polyfill\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/node-domexception\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(action-browser)/./node_modules/node-fetch/src/index.js\"));\n    const newReq = __spreadProps(__spreadValues({}, req), {\n      messages: yield Promise.all(\n        req.messages.map((message) => __async(this, null, function* () {\n          const content = yield Promise.all(\n            message.content.map((part) => __async(this, null, function* () {\n              if (!part.media || !part.media.url.startsWith(\"http\") || (options == null ? void 0 : options.filter) && !(options == null ? void 0 : options.filter(part))) {\n                return part;\n              }\n              const response = yield fetch(part.media.url, {\n                size: options == null ? void 0 : options.maxBytes\n              });\n              if (response.status !== 200)\n                throw new Error(\n                  `HTTP error downloading media '${part.media.url}': ${yield response.text()}`\n                );\n              const contentType = part.media.contentType || response.headers.get(\"content-type\") || \"\";\n              return {\n                media: {\n                  contentType,\n                  url: `data:${contentType};base64,${Buffer.from(\n                    yield response.arrayBuffer()\n                  ).toString(\"base64\")}`\n                }\n              };\n            }))\n          );\n          return __spreadProps(__spreadValues({}, message), {\n            content\n          });\n        }))\n      )\n    });\n    return next(newReq);\n  });\n}\nfunction validateSupport(options) {\n  const supports = options.supports || {};\n  return (req, next) => __async(this, null, function* () {\n    var _a, _b, _c, _d;\n    function invalid(message) {\n      throw new Error(\n        `Model '${options.name}' does not support ${message}. Request: ${JSON.stringify(\n          req,\n          null,\n          2\n        )}`\n      );\n    }\n    if (supports.media === false && req.messages.some((message) => message.content.some((part) => part.media)))\n      invalid(\"media, but media was provided\");\n    if (supports.tools === false && ((_a = req.tools) == null ? void 0 : _a.length))\n      invalid(\"tool use, but tools were provided\");\n    if (supports.multiturn === false && req.messages.length > 1)\n      invalid(`multiple messages, but ${req.messages.length} were provided`);\n    if (typeof supports.output !== \"undefined\" && ((_b = req.output) == null ? void 0 : _b.format) && !supports.output.includes((_c = req.output) == null ? void 0 : _c.format))\n      invalid(`requested output format '${(_d = req.output) == null ? void 0 : _d.format}'`);\n    return next();\n  });\n}\nfunction lastUserMessage(messages) {\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (messages[i].role === \"user\") {\n      return messages[i];\n    }\n  }\n}\nfunction conformOutput() {\n  return (req, next) => __async(this, null, function* () {\n    var _a, _b;\n    const lastMessage = lastUserMessage(req.messages);\n    if (!lastMessage)\n      return next(req);\n    const outputPartIndex = lastMessage.content.findIndex(\n      (p) => {\n        var _a2;\n        return ((_a2 = p.metadata) == null ? void 0 : _a2.purpose) === \"output\";\n      }\n    );\n    const outputPart = outputPartIndex >= 0 ? lastMessage.content[outputPartIndex] : void 0;\n    if (!((_a = req.output) == null ? void 0 : _a.schema) || outputPart && !((_b = outputPart == null ? void 0 : outputPart.metadata) == null ? void 0 : _b.pending)) {\n      return next(req);\n    }\n    const instructions = `\n\nOutput should be in JSON format and conform to the following schema:\n\n\\`\\`\\`\n${JSON.stringify(req.output.schema)}\n\\`\\`\\`\n`;\n    if (outputPart) {\n      lastMessage.content[outputPartIndex] = __spreadProps(__spreadValues({}, outputPart), {\n        metadata: {\n          purpose: \"output\",\n          source: \"default\"\n        },\n        text: instructions\n      });\n    } else {\n      lastMessage == null ? void 0 : lastMessage.content.push({\n        text: instructions,\n        metadata: { purpose: \"output\", source: \"default\" }\n      });\n    }\n    return next(req);\n  });\n}\nfunction simulateSystemPrompt(options) {\n  const preface = (options == null ? void 0 : options.preface) || \"SYSTEM INSTRUCTIONS:\\n\";\n  const acknowledgement = (options == null ? void 0 : options.acknowledgement) || \"Understood.\";\n  return (req, next) => {\n    const messages = [...req.messages];\n    for (let i = 0; i < messages.length; i++) {\n      if (req.messages[i].role === \"system\") {\n        const systemPrompt = messages[i].content;\n        messages.splice(\n          i,\n          1,\n          { role: \"user\", content: [{ text: preface }, ...systemPrompt] },\n          { role: \"model\", content: [{ text: acknowledgement }] }\n        );\n        break;\n      }\n    }\n    return next(__spreadProps(__spreadValues({}, req), { messages }));\n  };\n}\nconst CONTEXT_PREFACE = \"\\n\\nUse the following information to complete your task:\\n\\n\";\nconst CONTEXT_ITEM_TEMPLATE = (d, index, options) => {\n  var _a, _b;\n  let out = \"- \";\n  if (options == null ? void 0 : options.citationKey) {\n    out += `[${d.metadata[options.citationKey]}]: `;\n  } else if ((options == null ? void 0 : options.citationKey) === void 0) {\n    out += `[${((_a = d.metadata) == null ? void 0 : _a[\"ref\"]) || ((_b = d.metadata) == null ? void 0 : _b[\"id\"]) || index}]: `;\n  }\n  out += d.text() + \"\\n\";\n  return out;\n};\nfunction augmentWithContext(options) {\n  const preface = typeof (options == null ? void 0 : options.preface) === \"undefined\" ? CONTEXT_PREFACE : options.preface;\n  const itemTemplate = (options == null ? void 0 : options.itemTemplate) || CONTEXT_ITEM_TEMPLATE;\n  return (req, next) => {\n    var _a, _b, _c;\n    if (!((_a = req.context) == null ? void 0 : _a.length))\n      return next(req);\n    const userMessage = lastUserMessage(req.messages);\n    if (!userMessage)\n      return next(req);\n    const contextPartIndex = userMessage == null ? void 0 : userMessage.content.findIndex(\n      (p) => {\n        var _a2;\n        return ((_a2 = p.metadata) == null ? void 0 : _a2.purpose) === \"context\";\n      }\n    );\n    const contextPart = contextPartIndex >= 0 && userMessage.content[contextPartIndex];\n    if (contextPart && !((_b = contextPart.metadata) == null ? void 0 : _b.pending)) {\n      return next(req);\n    }\n    let out = `${preface || \"\"}`;\n    (_c = req.context) == null ? void 0 : _c.forEach((d, i) => {\n      out += itemTemplate(new import_document.Document(d), i, options);\n    });\n    out += \"\\n\";\n    if (contextPartIndex >= 0) {\n      userMessage.content[contextPartIndex] = __spreadProps(__spreadValues({}, contextPart), {\n        text: out,\n        metadata: { purpose: \"context\" }\n      });\n    } else {\n      userMessage.content.push({ text: out, metadata: { purpose: \"context\" } });\n    }\n    return next(req);\n  };\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9tb2RlbC9taWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMscUZBQWdCO0FBQzlDO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixRQUFRLCtlQUFvQjtBQUN6RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtREFBbUQsZUFBZSxLQUFLLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWEsU0FBUztBQUNyRDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhLHFCQUFxQixRQUFRLGFBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBLDBDQUEwQywrQ0FBK0M7QUFDekY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsZUFBZSxvQkFBb0I7QUFDekUsWUFBWSwyQkFBMkIsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLElBQUk7QUFDSixlQUFlLDZHQUE2RztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxvQkFBb0I7QUFDcEIsT0FBTztBQUNQLE1BQU07QUFDTixpQ0FBaUMsdUJBQXVCLHNCQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvbW9kZWwvbWlkZGxld2FyZS5qcz8xMTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBtaWRkbGV3YXJlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1pZGRsZXdhcmVfZXhwb3J0cywge1xuICBDT05URVhUX1BSRUZBQ0U6ICgpID0+IENPTlRFWFRfUFJFRkFDRSxcbiAgYXVnbWVudFdpdGhDb250ZXh0OiAoKSA9PiBhdWdtZW50V2l0aENvbnRleHQsXG4gIGNvbmZvcm1PdXRwdXQ6ICgpID0+IGNvbmZvcm1PdXRwdXQsXG4gIGRvd25sb2FkUmVxdWVzdE1lZGlhOiAoKSA9PiBkb3dubG9hZFJlcXVlc3RNZWRpYSxcbiAgc2ltdWxhdGVTeXN0ZW1Qcm9tcHQ6ICgpID0+IHNpbXVsYXRlU3lzdGVtUHJvbXB0LFxuICB2YWxpZGF0ZVN1cHBvcnQ6ICgpID0+IHZhbGlkYXRlU3VwcG9ydFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhtaWRkbGV3YXJlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9kb2N1bWVudCA9IHJlcXVpcmUoXCIuLi9kb2N1bWVudC5qc1wiKTtcbmZ1bmN0aW9uIGRvd25sb2FkUmVxdWVzdE1lZGlhKG9wdGlvbnMpIHtcbiAgcmV0dXJuIChyZXEsIG5leHQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB7IGRlZmF1bHQ6IGZldGNoIH0gPSB5aWVsZCBpbXBvcnQoXCJub2RlLWZldGNoXCIpO1xuICAgIGNvbnN0IG5ld1JlcSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlcSksIHtcbiAgICAgIG1lc3NhZ2VzOiB5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVxLm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFwYXJ0Lm1lZGlhIHx8ICFwYXJ0Lm1lZGlhLnVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5maWx0ZXIpICYmICEob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5maWx0ZXIocGFydCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChwYXJ0Lm1lZGlhLnVybCwge1xuICAgICAgICAgICAgICAgIHNpemU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Qnl0ZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgSFRUUCBlcnJvciBkb3dubG9hZGluZyBtZWRpYSAnJHtwYXJ0Lm1lZGlhLnVybH0nOiAke3lpZWxkIHJlc3BvbnNlLnRleHQoKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJ0Lm1lZGlhLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsJHtCdWZmZXIuZnJvbShcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgICAgICAgICAgKS50b1N0cmluZyhcImJhc2U2NFwiKX1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWVzc2FnZSksIHtcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpXG4gICAgICApXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQobmV3UmVxKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN1cHBvcnQob3B0aW9ucykge1xuICBjb25zdCBzdXBwb3J0cyA9IG9wdGlvbnMuc3VwcG9ydHMgfHwge307XG4gIHJldHVybiAocmVxLCBuZXh0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGZ1bmN0aW9uIGludmFsaWQobWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTW9kZWwgJyR7b3B0aW9ucy5uYW1lfScgZG9lcyBub3Qgc3VwcG9ydCAke21lc3NhZ2V9LiBSZXF1ZXN0OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHJlcSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIDJcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMubWVkaWEgPT09IGZhbHNlICYmIHJlcS5tZXNzYWdlcy5zb21lKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQuc29tZSgocGFydCkgPT4gcGFydC5tZWRpYSkpKVxuICAgICAgaW52YWxpZChcIm1lZGlhLCBidXQgbWVkaWEgd2FzIHByb3ZpZGVkXCIpO1xuICAgIGlmIChzdXBwb3J0cy50b29scyA9PT0gZmFsc2UgJiYgKChfYSA9IHJlcS50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpXG4gICAgICBpbnZhbGlkKFwidG9vbCB1c2UsIGJ1dCB0b29scyB3ZXJlIHByb3ZpZGVkXCIpO1xuICAgIGlmIChzdXBwb3J0cy5tdWx0aXR1cm4gPT09IGZhbHNlICYmIHJlcS5tZXNzYWdlcy5sZW5ndGggPiAxKVxuICAgICAgaW52YWxpZChgbXVsdGlwbGUgbWVzc2FnZXMsIGJ1dCAke3JlcS5tZXNzYWdlcy5sZW5ndGh9IHdlcmUgcHJvdmlkZWRgKTtcbiAgICBpZiAodHlwZW9mIHN1cHBvcnRzLm91dHB1dCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9iID0gcmVxLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZvcm1hdCkgJiYgIXN1cHBvcnRzLm91dHB1dC5pbmNsdWRlcygoX2MgPSByZXEub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuZm9ybWF0KSlcbiAgICAgIGludmFsaWQoYHJlcXVlc3RlZCBvdXRwdXQgZm9ybWF0ICckeyhfZCA9IHJlcS5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5mb3JtYXR9J2ApO1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbGFzdFVzZXJNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChtZXNzYWdlc1tpXS5yb2xlID09PSBcInVzZXJcIikge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29uZm9ybU91dHB1dCgpIHtcbiAgcmV0dXJuIChyZXEsIG5leHQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbGFzdFVzZXJNZXNzYWdlKHJlcS5tZXNzYWdlcyk7XG4gICAgaWYgKCFsYXN0TWVzc2FnZSlcbiAgICAgIHJldHVybiBuZXh0KHJlcSk7XG4gICAgY29uc3Qgb3V0cHV0UGFydEluZGV4ID0gbGFzdE1lc3NhZ2UuY29udGVudC5maW5kSW5kZXgoXG4gICAgICAocCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKChfYTIgPSBwLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnB1cnBvc2UpID09PSBcIm91dHB1dFwiO1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0UGFydCA9IG91dHB1dFBhcnRJbmRleCA+PSAwID8gbGFzdE1lc3NhZ2UuY29udGVudFtvdXRwdXRQYXJ0SW5kZXhdIDogdm9pZCAwO1xuICAgIGlmICghKChfYSA9IHJlcS5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY2hlbWEpIHx8IG91dHB1dFBhcnQgJiYgISgoX2IgPSBvdXRwdXRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXRQYXJ0Lm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IucGVuZGluZykpIHtcbiAgICAgIHJldHVybiBuZXh0KHJlcSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGBcblxuT3V0cHV0IHNob3VsZCBiZSBpbiBKU09OIGZvcm1hdCBhbmQgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIHNjaGVtYTpcblxuXFxgXFxgXFxgXG4ke0pTT04uc3RyaW5naWZ5KHJlcS5vdXRwdXQuc2NoZW1hKX1cblxcYFxcYFxcYFxuYDtcbiAgICBpZiAob3V0cHV0UGFydCkge1xuICAgICAgbGFzdE1lc3NhZ2UuY29udGVudFtvdXRwdXRQYXJ0SW5kZXhdID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3V0cHV0UGFydCksIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBwdXJwb3NlOiBcIm91dHB1dFwiLFxuICAgICAgICAgIHNvdXJjZTogXCJkZWZhdWx0XCJcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogaW5zdHJ1Y3Rpb25zXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgIHRleHQ6IGluc3RydWN0aW9ucyxcbiAgICAgICAgbWV0YWRhdGE6IHsgcHVycG9zZTogXCJvdXRwdXRcIiwgc291cmNlOiBcImRlZmF1bHRcIiB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQocmVxKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaW11bGF0ZVN5c3RlbVByb21wdChvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZhY2UgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmYWNlKSB8fCBcIlNZU1RFTSBJTlNUUlVDVElPTlM6XFxuXCI7XG4gIGNvbnN0IGFja25vd2xlZGdlbWVudCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFja25vd2xlZGdlbWVudCkgfHwgXCJVbmRlcnN0b29kLlwiO1xuICByZXR1cm4gKHJlcSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gWy4uLnJlcS5tZXNzYWdlc107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlcS5tZXNzYWdlc1tpXS5yb2xlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IG1lc3NhZ2VzW2ldLmNvbnRlbnQ7XG4gICAgICAgIG1lc3NhZ2VzLnNwbGljZShcbiAgICAgICAgICBpLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogW3sgdGV4dDogcHJlZmFjZSB9LCAuLi5zeXN0ZW1Qcm9tcHRdIH0sXG4gICAgICAgICAgeyByb2xlOiBcIm1vZGVsXCIsIGNvbnRlbnQ6IFt7IHRleHQ6IGFja25vd2xlZGdlbWVudCB9XSB9XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXEpLCB7IG1lc3NhZ2VzIH0pKTtcbiAgfTtcbn1cbmNvbnN0IENPTlRFWFRfUFJFRkFDRSA9IFwiXFxuXFxuVXNlIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gdG8gY29tcGxldGUgeW91ciB0YXNrOlxcblxcblwiO1xuY29uc3QgQ09OVEVYVF9JVEVNX1RFTVBMQVRFID0gKGQsIGluZGV4LCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCBvdXQgPSBcIi0gXCI7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNpdGF0aW9uS2V5KSB7XG4gICAgb3V0ICs9IGBbJHtkLm1ldGFkYXRhW29wdGlvbnMuY2l0YXRpb25LZXldfV06IGA7XG4gIH0gZWxzZSBpZiAoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2l0YXRpb25LZXkpID09PSB2b2lkIDApIHtcbiAgICBvdXQgKz0gYFskeygoX2EgPSBkLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbXCJyZWZcIl0pIHx8ICgoX2IgPSBkLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2JbXCJpZFwiXSkgfHwgaW5kZXh9XTogYDtcbiAgfVxuICBvdXQgKz0gZC50ZXh0KCkgKyBcIlxcblwiO1xuICByZXR1cm4gb3V0O1xufTtcbmZ1bmN0aW9uIGF1Z21lbnRXaXRoQ29udGV4dChvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZhY2UgPSB0eXBlb2YgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlZmFjZSkgPT09IFwidW5kZWZpbmVkXCIgPyBDT05URVhUX1BSRUZBQ0UgOiBvcHRpb25zLnByZWZhY2U7XG4gIGNvbnN0IGl0ZW1UZW1wbGF0ZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLml0ZW1UZW1wbGF0ZSkgfHwgQ09OVEVYVF9JVEVNX1RFTVBMQVRFO1xuICByZXR1cm4gKHJlcSwgbmV4dCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICghKChfYSA9IHJlcS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSlcbiAgICAgIHJldHVybiBuZXh0KHJlcSk7XG4gICAgY29uc3QgdXNlck1lc3NhZ2UgPSBsYXN0VXNlck1lc3NhZ2UocmVxLm1lc3NhZ2VzKTtcbiAgICBpZiAoIXVzZXJNZXNzYWdlKVxuICAgICAgcmV0dXJuIG5leHQocmVxKTtcbiAgICBjb25zdCBjb250ZXh0UGFydEluZGV4ID0gdXNlck1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXJNZXNzYWdlLmNvbnRlbnQuZmluZEluZGV4KFxuICAgICAgKHApID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuICgoX2EyID0gcC5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wdXJwb3NlKSA9PT0gXCJjb250ZXh0XCI7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBjb250ZXh0UGFydCA9IGNvbnRleHRQYXJ0SW5kZXggPj0gMCAmJiB1c2VyTWVzc2FnZS5jb250ZW50W2NvbnRleHRQYXJ0SW5kZXhdO1xuICAgIGlmIChjb250ZXh0UGFydCAmJiAhKChfYiA9IGNvbnRleHRQYXJ0Lm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IucGVuZGluZykpIHtcbiAgICAgIHJldHVybiBuZXh0KHJlcSk7XG4gICAgfVxuICAgIGxldCBvdXQgPSBgJHtwcmVmYWNlIHx8IFwiXCJ9YDtcbiAgICAoX2MgPSByZXEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgIG91dCArPSBpdGVtVGVtcGxhdGUobmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChkKSwgaSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgaWYgKGNvbnRleHRQYXJ0SW5kZXggPj0gMCkge1xuICAgICAgdXNlck1lc3NhZ2UuY29udGVudFtjb250ZXh0UGFydEluZGV4XSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNvbnRleHRQYXJ0KSwge1xuICAgICAgICB0ZXh0OiBvdXQsXG4gICAgICAgIG1ldGFkYXRhOiB7IHB1cnBvc2U6IFwiY29udGV4dFwiIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyTWVzc2FnZS5jb250ZW50LnB1c2goeyB0ZXh0OiBvdXQsIG1ldGFkYXRhOiB7IHB1cnBvc2U6IFwiY29udGV4dFwiIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KHJlcSk7XG4gIH07XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ09OVEVYVF9QUkVGQUNFLFxuICBhdWdtZW50V2l0aENvbnRleHQsXG4gIGNvbmZvcm1PdXRwdXQsXG4gIGRvd25sb2FkUmVxdWVzdE1lZGlhLFxuICBzaW11bGF0ZVN5c3RlbVByb21wdCxcbiAgdmFsaWRhdGVTdXBwb3J0XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pZGRsZXdhcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js":
/*!**************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/prompt.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar prompt_exports = {};\n__export(prompt_exports, {\n  definePrompt: () => definePrompt,\n  isPrompt: () => isPrompt,\n  renderPrompt: () => renderPrompt\n});\nmodule.exports = __toCommonJS(prompt_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nfunction isPrompt(arg) {\n  var _a, _b;\n  return typeof arg === \"function\" && ((_b = (_a = arg.__action) == null ? void 0 : _a.metadata) == null ? void 0 : _b.type) === \"prompt\";\n}\nfunction definePrompt({\n  name,\n  description,\n  inputSchema,\n  inputJsonSchema,\n  metadata\n}, fn) {\n  const a = (0, import_core.defineAction)(\n    {\n      actionType: \"prompt\",\n      name,\n      description,\n      inputSchema,\n      inputJsonSchema,\n      metadata: __spreadProps(__spreadValues({}, metadata || { prompt: {} }), { type: \"prompt\" })\n    },\n    fn\n  );\n  return a;\n}\nfunction renderPrompt(params) {\n  return __async(this, null, function* () {\n    var _a, _b;\n    let prompt;\n    if (typeof params.prompt === \"string\") {\n      prompt = yield (0, import_registry.lookupAction)(`/prompt/${params.prompt}`);\n    } else {\n      prompt = params.prompt;\n    }\n    const rendered = yield prompt(\n      params.input\n    );\n    return {\n      model: params.model,\n      config: __spreadValues(__spreadValues({}, rendered.config || {}), params.config),\n      history: rendered.messages.slice(0, rendered.messages.length - 1),\n      prompt: rendered.messages[rendered.messages.length - 1].content,\n      context: params.context,\n      candidates: rendered.candidates || 1,\n      output: {\n        format: (_a = rendered.output) == null ? void 0 : _a.format,\n        schema: (_b = rendered.output) == null ? void 0 : _b.schema\n      },\n      tools: rendered.tools || []\n    };\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=prompt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9wcm9tcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLFlBQVksS0FBSyxnQkFBZ0I7QUFDaEcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvcHJvbXB0LmpzPzNjNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIHByb21wdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm9tcHRfZXhwb3J0cywge1xuICBkZWZpbmVQcm9tcHQ6ICgpID0+IGRlZmluZVByb21wdCxcbiAgaXNQcm9tcHQ6ICgpID0+IGlzUHJvbXB0LFxuICByZW5kZXJQcm9tcHQ6ICgpID0+IHJlbmRlclByb21wdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhwcm9tcHRfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlXCIpO1xudmFyIGltcG9ydF9yZWdpc3RyeSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvcmVnaXN0cnlcIik7XG5mdW5jdGlvbiBpc1Byb21wdChhcmcpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiAmJiAoKF9iID0gKF9hID0gYXJnLl9fYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJwcm9tcHRcIjtcbn1cbmZ1bmN0aW9uIGRlZmluZVByb21wdCh7XG4gIG5hbWUsXG4gIGRlc2NyaXB0aW9uLFxuICBpbnB1dFNjaGVtYSxcbiAgaW5wdXRKc29uU2NoZW1hLFxuICBtZXRhZGF0YVxufSwgZm4pIHtcbiAgY29uc3QgYSA9ICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwicHJvbXB0XCIsXG4gICAgICBuYW1lLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBpbnB1dFNjaGVtYSxcbiAgICAgIGlucHV0SnNvblNjaGVtYSxcbiAgICAgIG1ldGFkYXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhZGF0YSB8fCB7IHByb21wdDoge30gfSksIHsgdHlwZTogXCJwcm9tcHRcIiB9KVxuICAgIH0sXG4gICAgZm5cbiAgKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByZW5kZXJQcm9tcHQocGFyYW1zKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgcHJvbXB0O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcHJvbXB0ID0geWllbGQgKDAsIGltcG9ydF9yZWdpc3RyeS5sb29rdXBBY3Rpb24pKGAvcHJvbXB0LyR7cGFyYW1zLnByb21wdH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbXB0ID0gcGFyYW1zLnByb21wdDtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyZWQgPSB5aWVsZCBwcm9tcHQoXG4gICAgICBwYXJhbXMuaW5wdXRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgY29uZmlnOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVuZGVyZWQuY29uZmlnIHx8IHt9KSwgcGFyYW1zLmNvbmZpZyksXG4gICAgICBoaXN0b3J5OiByZW5kZXJlZC5tZXNzYWdlcy5zbGljZSgwLCByZW5kZXJlZC5tZXNzYWdlcy5sZW5ndGggLSAxKSxcbiAgICAgIHByb21wdDogcmVuZGVyZWQubWVzc2FnZXNbcmVuZGVyZWQubWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCxcbiAgICAgIGNvbnRleHQ6IHBhcmFtcy5jb250ZXh0LFxuICAgICAgY2FuZGlkYXRlczogcmVuZGVyZWQuY2FuZGlkYXRlcyB8fCAxLFxuICAgICAgb3V0cHV0OiB7XG4gICAgICAgIGZvcm1hdDogKF9hID0gcmVuZGVyZWQub3V0cHV0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9ybWF0LFxuICAgICAgICBzY2hlbWE6IChfYiA9IHJlbmRlcmVkLm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNjaGVtYVxuICAgICAgfSxcbiAgICAgIHRvb2xzOiByZW5kZXJlZC50b29scyB8fCBbXVxuICAgIH07XG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVByb21wdCxcbiAgaXNQcm9tcHQsXG4gIHJlbmRlclByb21wdFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9tcHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/retriever.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar retriever_exports = {};\n__export(retriever_exports, {\n  CommonRetrieverOptionsSchema: () => CommonRetrieverOptionsSchema,\n  Document: () => import_document2.Document,\n  DocumentDataSchema: () => import_document2.DocumentDataSchema,\n  IndexerInfoSchema: () => IndexerInfoSchema,\n  RetrieverInfoSchema: () => RetrieverInfoSchema,\n  defineIndexer: () => defineIndexer,\n  defineRetriever: () => defineRetriever,\n  defineSimpleRetriever: () => defineSimpleRetriever,\n  index: () => index,\n  indexerRef: () => indexerRef,\n  retrieve: () => retrieve,\n  retrieverRef: () => retrieverRef\n});\nmodule.exports = __toCommonJS(retriever_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nvar import_document = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nvar import_document2 = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/document.js\");\nconst RetrieverRequestSchema = z.object({\n  query: import_document.DocumentDataSchema,\n  options: z.any().optional()\n});\nconst RetrieverResponseSchema = z.object({\n  documents: z.array(import_document.DocumentDataSchema)\n  // TODO: stats, etc.\n});\nconst IndexerRequestSchema = z.object({\n  documents: z.array(import_document.DocumentDataSchema),\n  options: z.any().optional()\n});\nconst RetrieverInfoSchema = z.object({\n  label: z.string().optional(),\n  /** Supported model capabilities. */\n  supports: z.object({\n    /** Model can process media as part of the prompt (multimodal input). */\n    media: z.boolean().optional()\n  }).optional()\n});\nfunction retrieverWithMetadata(retriever, configSchema) {\n  const withMeta = retriever;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction indexerWithMetadata(indexer, configSchema) {\n  const withMeta = indexer;\n  withMeta.__configSchema = configSchema;\n  return withMeta;\n}\nfunction defineRetriever(options, runner) {\n  const retriever = (0, import_core.defineAction)(\n    {\n      actionType: \"retriever\",\n      name: options.name,\n      inputSchema: options.configSchema ? RetrieverRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : RetrieverRequestSchema,\n      outputSchema: RetrieverResponseSchema,\n      metadata: {\n        type: \"retriever\",\n        info: options.info\n      }\n    },\n    (i) => runner(new import_document.Document(i.query), i.options)\n  );\n  const rwm = retrieverWithMetadata(\n    retriever,\n    options.configSchema\n  );\n  return rwm;\n}\nfunction defineIndexer(options, runner) {\n  const indexer = (0, import_core.defineAction)(\n    {\n      actionType: \"indexer\",\n      name: options.name,\n      inputSchema: options.configSchema ? IndexerRequestSchema.extend({\n        options: options.configSchema.optional()\n      }) : IndexerRequestSchema,\n      outputSchema: z.void(),\n      metadata: {\n        type: \"indexer\",\n        embedderInfo: options.embedderInfo\n      }\n    },\n    (i) => runner(\n      i.documents.map((dd) => new import_document.Document(dd)),\n      i.options\n    )\n  );\n  const iwm = indexerWithMetadata(\n    indexer,\n    options.configSchema\n  );\n  return iwm;\n}\nfunction retrieve(params) {\n  return __async(this, null, function* () {\n    let retriever;\n    if (typeof params.retriever === \"string\") {\n      retriever = yield (0, import_registry.lookupAction)(`/retriever/${params.retriever}`);\n    } else if (Object.hasOwnProperty.call(params.retriever, \"info\")) {\n      retriever = yield (0, import_registry.lookupAction)(`/retriever/${params.retriever.name}`);\n    } else {\n      retriever = params.retriever;\n    }\n    if (!retriever) {\n      throw new Error(\"Unable to resolve the retriever\");\n    }\n    const response = yield retriever({\n      query: typeof params.query === \"string\" ? import_document.Document.fromText(params.query) : params.query,\n      options: params.options\n    });\n    return response.documents.map((d) => new import_document.Document(d));\n  });\n}\nfunction index(params) {\n  return __async(this, null, function* () {\n    let indexer;\n    if (typeof params.indexer === \"string\") {\n      indexer = yield (0, import_registry.lookupAction)(`/indexer/${params.indexer}`);\n    } else if (Object.hasOwnProperty.call(params.indexer, \"info\")) {\n      indexer = yield (0, import_registry.lookupAction)(`/indexer/${params.indexer.name}`);\n    } else {\n      indexer = params.indexer;\n    }\n    if (!indexer) {\n      throw new Error(\"Unable to utilize the provided indexer\");\n    }\n    return yield indexer({\n      documents: params.documents,\n      options: params.options\n    });\n  });\n}\nconst CommonRetrieverOptionsSchema = z.object({\n  k: z.number().describe(\"Number of documents to retrieve\").optional()\n});\nfunction retrieverRef(options) {\n  return __spreadValues({}, options);\n}\nconst IndexerInfoSchema = RetrieverInfoSchema;\nfunction indexerRef(options) {\n  return __spreadValues({}, options);\n}\nfunction itemToDocument(item, options) {\n  if (!item)\n    throw new import_core.GenkitError({\n      status: \"INVALID_ARGUMENT\",\n      message: `Items returned from simple retriever must be non-null.`\n    });\n  if (typeof item === \"string\")\n    return import_document.Document.fromText(item);\n  if (typeof options.content === \"function\") {\n    const transformed = options.content(item);\n    return typeof transformed === \"string\" ? import_document.Document.fromText(transformed) : new import_document.Document({ content: transformed });\n  }\n  if (typeof options.content === \"string\" && typeof item === \"object\")\n    return import_document.Document.fromText(item[options.content]);\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: `Cannot convert item to document without content option. Item: ${JSON.stringify(item)}`\n  });\n}\nfunction itemToMetadata(item, options) {\n  if (typeof item === \"string\")\n    return void 0;\n  if (Array.isArray(options.metadata) && typeof item === \"object\") {\n    const out = {};\n    options.metadata.forEach((key) => out[key] = item[key]);\n  }\n  if (typeof options.metadata === \"function\")\n    return options.metadata(item);\n  if (!options.metadata && typeof item === \"object\") {\n    const out = __spreadValues({}, item);\n    if (typeof options.content === \"string\")\n      delete out[options.content];\n    return out;\n  }\n  throw new import_core.GenkitError({\n    status: \"INVALID_ARGUMENT\",\n    message: `Unable to extract metadata from item with supplied options. Item: ${JSON.stringify(item)}`\n  });\n}\nfunction defineSimpleRetriever(options, handler) {\n  return defineRetriever(\n    {\n      name: options.name,\n      configSchema: options.configSchema\n    },\n    (query, config) => __async(this, null, function* () {\n      const result = yield handler(query, config);\n      return {\n        documents: result.map((item) => {\n          const doc = itemToDocument(item, options);\n          if (typeof item !== \"string\")\n            doc.metadata = itemToMetadata(item, options);\n          return doc;\n        })\n      };\n    })\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=retriever.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9yZXRyaWV2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLDBEQUFLO0FBQzdCLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekYsTUFBTTtBQUNOLHdFQUF3RSxzQkFBc0I7QUFDOUYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GLE1BQU07QUFDTixvRUFBb0Usb0JBQW9CO0FBQ3hGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxzQkFBc0I7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBcUI7QUFDbkcsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHFCQUFxQjtBQUN2RyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQWFMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvcmV0cmlldmVyLmpzPzFkZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciByZXRyaWV2ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmV0cmlldmVyX2V4cG9ydHMsIHtcbiAgQ29tbW9uUmV0cmlldmVyT3B0aW9uc1NjaGVtYTogKCkgPT4gQ29tbW9uUmV0cmlldmVyT3B0aW9uc1NjaGVtYSxcbiAgRG9jdW1lbnQ6ICgpID0+IGltcG9ydF9kb2N1bWVudDIuRG9jdW1lbnQsXG4gIERvY3VtZW50RGF0YVNjaGVtYTogKCkgPT4gaW1wb3J0X2RvY3VtZW50Mi5Eb2N1bWVudERhdGFTY2hlbWEsXG4gIEluZGV4ZXJJbmZvU2NoZW1hOiAoKSA9PiBJbmRleGVySW5mb1NjaGVtYSxcbiAgUmV0cmlldmVySW5mb1NjaGVtYTogKCkgPT4gUmV0cmlldmVySW5mb1NjaGVtYSxcbiAgZGVmaW5lSW5kZXhlcjogKCkgPT4gZGVmaW5lSW5kZXhlcixcbiAgZGVmaW5lUmV0cmlldmVyOiAoKSA9PiBkZWZpbmVSZXRyaWV2ZXIsXG4gIGRlZmluZVNpbXBsZVJldHJpZXZlcjogKCkgPT4gZGVmaW5lU2ltcGxlUmV0cmlldmVyLFxuICBpbmRleDogKCkgPT4gaW5kZXgsXG4gIGluZGV4ZXJSZWY6ICgpID0+IGluZGV4ZXJSZWYsXG4gIHJldHJpZXZlOiAoKSA9PiByZXRyaWV2ZSxcbiAgcmV0cmlldmVyUmVmOiAoKSA9PiByZXRyaWV2ZXJSZWZcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocmV0cmlldmVyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfcmVnaXN0cnkgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlL3JlZ2lzdHJ5XCIpO1xudmFyIHogPSBfX3RvRVNNKHJlcXVpcmUoXCJ6b2RcIikpO1xudmFyIGltcG9ydF9kb2N1bWVudCA9IHJlcXVpcmUoXCIuL2RvY3VtZW50LmpzXCIpO1xudmFyIGltcG9ydF9kb2N1bWVudDIgPSByZXF1aXJlKFwiLi9kb2N1bWVudC5qc1wiKTtcbmNvbnN0IFJldHJpZXZlclJlcXVlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHF1ZXJ5OiBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hLFxuICBvcHRpb25zOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgUmV0cmlldmVyUmVzcG9uc2VTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRvY3VtZW50czogei5hcnJheShpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnREYXRhU2NoZW1hKVxuICAvLyBUT0RPOiBzdGF0cywgZXRjLlxufSk7XG5jb25zdCBJbmRleGVyUmVxdWVzdFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgZG9jdW1lbnRzOiB6LmFycmF5KGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudERhdGFTY2hlbWEpLFxuICBvcHRpb25zOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgUmV0cmlldmVySW5mb1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgbGFiZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgLyoqIFN1cHBvcnRlZCBtb2RlbCBjYXBhYmlsaXRpZXMuICovXG4gIHN1cHBvcnRzOiB6Lm9iamVjdCh7XG4gICAgLyoqIE1vZGVsIGNhbiBwcm9jZXNzIG1lZGlhIGFzIHBhcnQgb2YgdGhlIHByb21wdCAobXVsdGltb2RhbCBpbnB1dCkuICovXG4gICAgbWVkaWE6IHouYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKVxufSk7XG5mdW5jdGlvbiByZXRyaWV2ZXJXaXRoTWV0YWRhdGEocmV0cmlldmVyLCBjb25maWdTY2hlbWEpIHtcbiAgY29uc3Qgd2l0aE1ldGEgPSByZXRyaWV2ZXI7XG4gIHdpdGhNZXRhLl9fY29uZmlnU2NoZW1hID0gY29uZmlnU2NoZW1hO1xuICByZXR1cm4gd2l0aE1ldGE7XG59XG5mdW5jdGlvbiBpbmRleGVyV2l0aE1ldGFkYXRhKGluZGV4ZXIsIGNvbmZpZ1NjaGVtYSkge1xuICBjb25zdCB3aXRoTWV0YSA9IGluZGV4ZXI7XG4gIHdpdGhNZXRhLl9fY29uZmlnU2NoZW1hID0gY29uZmlnU2NoZW1hO1xuICByZXR1cm4gd2l0aE1ldGE7XG59XG5mdW5jdGlvbiBkZWZpbmVSZXRyaWV2ZXIob3B0aW9ucywgcnVubmVyKSB7XG4gIGNvbnN0IHJldHJpZXZlciA9ICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwicmV0cmlldmVyXCIsXG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBpbnB1dFNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgPyBSZXRyaWV2ZXJSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMuY29uZmlnU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pIDogUmV0cmlldmVyUmVxdWVzdFNjaGVtYSxcbiAgICAgIG91dHB1dFNjaGVtYTogUmV0cmlldmVyUmVzcG9uc2VTY2hlbWEsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB0eXBlOiBcInJldHJpZXZlclwiLFxuICAgICAgICBpbmZvOiBvcHRpb25zLmluZm9cbiAgICAgIH1cbiAgICB9LFxuICAgIChpKSA9PiBydW5uZXIobmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChpLnF1ZXJ5KSwgaS5vcHRpb25zKVxuICApO1xuICBjb25zdCByd20gPSByZXRyaWV2ZXJXaXRoTWV0YWRhdGEoXG4gICAgcmV0cmlldmVyLFxuICAgIG9wdGlvbnMuY29uZmlnU2NoZW1hXG4gICk7XG4gIHJldHVybiByd207XG59XG5mdW5jdGlvbiBkZWZpbmVJbmRleGVyKG9wdGlvbnMsIHJ1bm5lcikge1xuICBjb25zdCBpbmRleGVyID0gKDAsIGltcG9ydF9jb3JlLmRlZmluZUFjdGlvbikoXG4gICAge1xuICAgICAgYWN0aW9uVHlwZTogXCJpbmRleGVyXCIsXG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBpbnB1dFNjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWEgPyBJbmRleGVyUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLmNvbmZpZ1NjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSA6IEluZGV4ZXJSZXF1ZXN0U2NoZW1hLFxuICAgICAgb3V0cHV0U2NoZW1hOiB6LnZvaWQoKSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwiaW5kZXhlclwiLFxuICAgICAgICBlbWJlZGRlckluZm86IG9wdGlvbnMuZW1iZWRkZXJJbmZvXG4gICAgICB9XG4gICAgfSxcbiAgICAoaSkgPT4gcnVubmVyKFxuICAgICAgaS5kb2N1bWVudHMubWFwKChkZCkgPT4gbmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChkZCkpLFxuICAgICAgaS5vcHRpb25zXG4gICAgKVxuICApO1xuICBjb25zdCBpd20gPSBpbmRleGVyV2l0aE1ldGFkYXRhKFxuICAgIGluZGV4ZXIsXG4gICAgb3B0aW9ucy5jb25maWdTY2hlbWFcbiAgKTtcbiAgcmV0dXJuIGl3bTtcbn1cbmZ1bmN0aW9uIHJldHJpZXZlKHBhcmFtcykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCByZXRyaWV2ZXI7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucmV0cmlldmVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXRyaWV2ZXIgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9yZXRyaWV2ZXIvJHtwYXJhbXMucmV0cmlldmVyfWApO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLnJldHJpZXZlciwgXCJpbmZvXCIpKSB7XG4gICAgICByZXRyaWV2ZXIgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9yZXRyaWV2ZXIvJHtwYXJhbXMucmV0cmlldmVyLm5hbWV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHJpZXZlciA9IHBhcmFtcy5yZXRyaWV2ZXI7XG4gICAgfVxuICAgIGlmICghcmV0cmlldmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSB0aGUgcmV0cmlldmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJldHJpZXZlcih7XG4gICAgICBxdWVyeTogdHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIiA/IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudC5mcm9tVGV4dChwYXJhbXMucXVlcnkpIDogcGFyYW1zLnF1ZXJ5LFxuICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZG9jdW1lbnRzLm1hcCgoZCkgPT4gbmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudChkKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5kZXgocGFyYW1zKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGluZGV4ZXI7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuaW5kZXhlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhlciA9IHlpZWxkICgwLCBpbXBvcnRfcmVnaXN0cnkubG9va3VwQWN0aW9uKShgL2luZGV4ZXIvJHtwYXJhbXMuaW5kZXhlcn1gKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcy5pbmRleGVyLCBcImluZm9cIikpIHtcbiAgICAgIGluZGV4ZXIgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC9pbmRleGVyLyR7cGFyYW1zLmluZGV4ZXIubmFtZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhlciA9IHBhcmFtcy5pbmRleGVyO1xuICAgIH1cbiAgICBpZiAoIWluZGV4ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB1dGlsaXplIHRoZSBwcm92aWRlZCBpbmRleGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4geWllbGQgaW5kZXhlcih7XG4gICAgICBkb2N1bWVudHM6IHBhcmFtcy5kb2N1bWVudHMsXG4gICAgICBvcHRpb25zOiBwYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IENvbW1vblJldHJpZXZlck9wdGlvbnNTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGs6IHoubnVtYmVyKCkuZGVzY3JpYmUoXCJOdW1iZXIgb2YgZG9jdW1lbnRzIHRvIHJldHJpZXZlXCIpLm9wdGlvbmFsKClcbn0pO1xuZnVuY3Rpb24gcmV0cmlldmVyUmVmKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbn1cbmNvbnN0IEluZGV4ZXJJbmZvU2NoZW1hID0gUmV0cmlldmVySW5mb1NjaGVtYTtcbmZ1bmN0aW9uIGluZGV4ZXJSZWYob3B0aW9ucykge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXRlbVRvRG9jdW1lbnQoaXRlbSwgb3B0aW9ucykge1xuICBpZiAoIWl0ZW0pXG4gICAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICAgIHN0YXR1czogXCJJTlZBTElEX0FSR1VNRU5UXCIsXG4gICAgICBtZXNzYWdlOiBgSXRlbXMgcmV0dXJuZWQgZnJvbSBzaW1wbGUgcmV0cmlldmVyIG11c3QgYmUgbm9uLW51bGwuYFxuICAgIH0pO1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudC5mcm9tVGV4dChpdGVtKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gb3B0aW9ucy5jb250ZW50KGl0ZW0pO1xuICAgIHJldHVybiB0eXBlb2YgdHJhbnNmb3JtZWQgPT09IFwic3RyaW5nXCIgPyBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQuZnJvbVRleHQodHJhbnNmb3JtZWQpIDogbmV3IGltcG9ydF9kb2N1bWVudC5Eb2N1bWVudCh7IGNvbnRlbnQ6IHRyYW5zZm9ybWVkIH0pO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBpbXBvcnRfZG9jdW1lbnQuRG9jdW1lbnQuZnJvbVRleHQoaXRlbVtvcHRpb25zLmNvbnRlbnRdKTtcbiAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29udmVydCBpdGVtIHRvIGRvY3VtZW50IHdpdGhvdXQgY29udGVudCBvcHRpb24uIEl0ZW06ICR7SlNPTi5zdHJpbmdpZnkoaXRlbSl9YFxuICB9KTtcbn1cbmZ1bmN0aW9uIGl0ZW1Ub01ldGFkYXRhKGl0ZW0sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMubWV0YWRhdGEpICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKChrZXkpID0+IG91dFtrZXldID0gaXRlbVtrZXldKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gb3B0aW9ucy5tZXRhZGF0YShpdGVtKTtcbiAgaWYgKCFvcHRpb25zLm1ldGFkYXRhICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3Qgb3V0ID0gX19zcHJlYWRWYWx1ZXMoe30sIGl0ZW0pO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgICAgZGVsZXRlIG91dFtvcHRpb25zLmNvbnRlbnRdO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdGhyb3cgbmV3IGltcG9ydF9jb3JlLkdlbmtpdEVycm9yKHtcbiAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgIG1lc3NhZ2U6IGBVbmFibGUgdG8gZXh0cmFjdCBtZXRhZGF0YSBmcm9tIGl0ZW0gd2l0aCBzdXBwbGllZCBvcHRpb25zLiBJdGVtOiAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfWBcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVTaW1wbGVSZXRyaWV2ZXIob3B0aW9ucywgaGFuZGxlcikge1xuICByZXR1cm4gZGVmaW5lUmV0cmlldmVyKFxuICAgIHtcbiAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgIGNvbmZpZ1NjaGVtYTogb3B0aW9ucy5jb25maWdTY2hlbWFcbiAgICB9LFxuICAgIChxdWVyeSwgY29uZmlnKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBoYW5kbGVyKHF1ZXJ5LCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9jdW1lbnRzOiByZXN1bHQubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jID0gaXRlbVRvRG9jdW1lbnQoaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZG9jLm1ldGFkYXRhID0gaXRlbVRvTWV0YWRhdGEoaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDb21tb25SZXRyaWV2ZXJPcHRpb25zU2NoZW1hLFxuICBEb2N1bWVudCxcbiAgRG9jdW1lbnREYXRhU2NoZW1hLFxuICBJbmRleGVySW5mb1NjaGVtYSxcbiAgUmV0cmlldmVySW5mb1NjaGVtYSxcbiAgZGVmaW5lSW5kZXhlcixcbiAgZGVmaW5lUmV0cmlldmVyLFxuICBkZWZpbmVTaW1wbGVSZXRyaWV2ZXIsXG4gIGluZGV4LFxuICBpbmRleGVyUmVmLFxuICByZXRyaWV2ZSxcbiAgcmV0cmlldmVyUmVmXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJpZXZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js":
/*!************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/tool.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar tool_exports = {};\n__export(tool_exports, {\n  asTool: () => asTool,\n  defineTool: () => defineTool,\n  resolveTools: () => resolveTools,\n  toToolDefinition: () => toToolDefinition\n});\nmodule.exports = __toCommonJS(tool_exports);\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_registry = __webpack_require__(/*! @genkit-ai/core/registry */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! @genkit-ai/core/tracing */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nfunction asTool(action) {\n  var _a, _b;\n  if (((_b = (_a = action.__action) == null ? void 0 : _a.metadata) == null ? void 0 : _b.type) === \"tool\") {\n    return action;\n  }\n  const fn = (input) => {\n    (0, import_tracing.setCustomMetadataAttributes)({ subtype: \"tool\" });\n    return action(input);\n  };\n  fn.__action = __spreadProps(__spreadValues({}, action.__action), {\n    metadata: __spreadProps(__spreadValues({}, action.__action.metadata), { type: \"tool\" })\n  });\n  return fn;\n}\nfunction resolveTools() {\n  return __async(this, arguments, function* (tools = []) {\n    return yield Promise.all(\n      tools.map((ref) => __async(this, null, function* () {\n        if (typeof ref === \"string\") {\n          const tool = yield (0, import_registry.lookupAction)(`/tool/${ref}`);\n          if (!tool) {\n            throw new Error(`Tool ${ref} not found`);\n          }\n          return tool;\n        } else if (ref.__action) {\n          return asTool(ref);\n        } else if (ref.name) {\n          const tool = yield (0, import_registry.lookupAction)(`/tool/${ref.name}`);\n          if (!tool) {\n            throw new Error(`Tool ${ref} not found`);\n          }\n        }\n        throw new Error(\"Tools must be strings, tool definitions, or actions.\");\n      }))\n    );\n  });\n}\nfunction toToolDefinition(tool) {\n  return {\n    name: tool.__action.name,\n    description: tool.__action.description || \"\",\n    outputSchema: (0, import_schema.toJsonSchema)({\n      schema: tool.__action.outputSchema,\n      jsonSchema: tool.__action.outputJsonSchema\n    }),\n    inputSchema: (0, import_schema.toJsonSchema)({\n      schema: tool.__action.inputSchema,\n      jsonSchema: tool.__action.inputJsonSchema\n    })\n  };\n}\nfunction defineTool({\n  name,\n  description,\n  inputSchema,\n  inputJsonSchema,\n  outputSchema,\n  outputJsonSchema,\n  metadata\n}, fn) {\n  const a = (0, import_core.defineAction)(\n    {\n      actionType: \"tool\",\n      name,\n      description,\n      inputSchema,\n      inputJsonSchema,\n      outputSchema,\n      outputJsonSchema,\n      metadata: __spreadProps(__spreadValues({}, metadata || {}), { type: \"tool\" })\n    },\n    (i) => fn(i)\n  );\n  return a;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=tool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi90b29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFpQjtBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsNkNBQTZDLCtCQUErQixjQUFjO0FBQzFGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxJQUFJO0FBQzVFO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVix3RUFBd0UsU0FBUztBQUNqRjtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLEtBQUssY0FBYztBQUNsRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FLTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvYWkvbGliL3Rvb2wuanM/MjQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgdG9vbF9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0b29sX2V4cG9ydHMsIHtcbiAgYXNUb29sOiAoKSA9PiBhc1Rvb2wsXG4gIGRlZmluZVRvb2w6ICgpID0+IGRlZmluZVRvb2wsXG4gIHJlc29sdmVUb29sczogKCkgPT4gcmVzb2x2ZVRvb2xzLFxuICB0b1Rvb2xEZWZpbml0aW9uOiAoKSA9PiB0b1Rvb2xEZWZpbml0aW9uXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHRvb2xfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9jb3JlXCIpO1xudmFyIGltcG9ydF9yZWdpc3RyeSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvcmVnaXN0cnlcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2NvcmUvc2NoZW1hXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS90cmFjaW5nXCIpO1xuZnVuY3Rpb24gYXNUb29sKGFjdGlvbikge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoKChfYiA9IChfYSA9IGFjdGlvbi5fX2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IudHlwZSkgPT09IFwidG9vbFwiKSB7XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICBjb25zdCBmbiA9IChpbnB1dCkgPT4ge1xuICAgICgwLCBpbXBvcnRfdHJhY2luZy5zZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZXMpKHsgc3VidHlwZTogXCJ0b29sXCIgfSk7XG4gICAgcmV0dXJuIGFjdGlvbihpbnB1dCk7XG4gIH07XG4gIGZuLl9fYWN0aW9uID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWN0aW9uLl9fYWN0aW9uKSwge1xuICAgIG1ldGFkYXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhY3Rpb24uX19hY3Rpb24ubWV0YWRhdGEpLCB7IHR5cGU6IFwidG9vbFwiIH0pXG4gIH0pO1xuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiByZXNvbHZlVG9vbHMoKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICh0b29scyA9IFtdKSB7XG4gICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKFxuICAgICAgdG9vbHMubWFwKChyZWYpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCB0b29sID0geWllbGQgKDAsIGltcG9ydF9yZWdpc3RyeS5sb29rdXBBY3Rpb24pKGAvdG9vbC8ke3JlZn1gKTtcbiAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCAke3JlZn0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZi5fX2FjdGlvbikge1xuICAgICAgICAgIHJldHVybiBhc1Rvb2wocmVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWYubmFtZSkge1xuICAgICAgICAgIGNvbnN0IHRvb2wgPSB5aWVsZCAoMCwgaW1wb3J0X3JlZ2lzdHJ5Lmxvb2t1cEFjdGlvbikoYC90b29sLyR7cmVmLm5hbWV9YCk7XG4gICAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgJHtyZWZ9IG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29scyBtdXN0IGJlIHN0cmluZ3MsIHRvb2wgZGVmaW5pdGlvbnMsIG9yIGFjdGlvbnMuXCIpO1xuICAgICAgfSkpXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1Rvb2xEZWZpbml0aW9uKHRvb2wpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB0b29sLl9fYWN0aW9uLm5hbWUsXG4gICAgZGVzY3JpcHRpb246IHRvb2wuX19hY3Rpb24uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICBvdXRwdXRTY2hlbWE6ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoe1xuICAgICAgc2NoZW1hOiB0b29sLl9fYWN0aW9uLm91dHB1dFNjaGVtYSxcbiAgICAgIGpzb25TY2hlbWE6IHRvb2wuX19hY3Rpb24ub3V0cHV0SnNvblNjaGVtYVxuICAgIH0pLFxuICAgIGlucHV0U2NoZW1hOiAoMCwgaW1wb3J0X3NjaGVtYS50b0pzb25TY2hlbWEpKHtcbiAgICAgIHNjaGVtYTogdG9vbC5fX2FjdGlvbi5pbnB1dFNjaGVtYSxcbiAgICAgIGpzb25TY2hlbWE6IHRvb2wuX19hY3Rpb24uaW5wdXRKc29uU2NoZW1hXG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZVRvb2woe1xuICBuYW1lLFxuICBkZXNjcmlwdGlvbixcbiAgaW5wdXRTY2hlbWEsXG4gIGlucHV0SnNvblNjaGVtYSxcbiAgb3V0cHV0U2NoZW1hLFxuICBvdXRwdXRKc29uU2NoZW1hLFxuICBtZXRhZGF0YVxufSwgZm4pIHtcbiAgY29uc3QgYSA9ICgwLCBpbXBvcnRfY29yZS5kZWZpbmVBY3Rpb24pKFxuICAgIHtcbiAgICAgIGFjdGlvblR5cGU6IFwidG9vbFwiLFxuICAgICAgbmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgaW5wdXRTY2hlbWEsXG4gICAgICBpbnB1dEpzb25TY2hlbWEsXG4gICAgICBvdXRwdXRTY2hlbWEsXG4gICAgICBvdXRwdXRKc29uU2NoZW1hLFxuICAgICAgbWV0YWRhdGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGFkYXRhIHx8IHt9KSwgeyB0eXBlOiBcInRvb2xcIiB9KVxuICAgIH0sXG4gICAgKGkpID0+IGZuKGkpXG4gICk7XG4gIHJldHVybiBhO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzVG9vbCxcbiAgZGVmaW5lVG9vbCxcbiAgcmVzb2x2ZVRvb2xzLFxuICB0b1Rvb2xEZWZpbml0aW9uXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js":
/*!*************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/types.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  CommonLlmOptions: () => CommonLlmOptions,\n  LlmResponseSchema: () => LlmResponseSchema,\n  LlmStatsSchema: () => LlmStatsSchema,\n  ModelIdSchema: () => ModelIdSchema,\n  ToolCallSchema: () => ToolCallSchema,\n  ToolSchema: () => ToolSchema,\n  toToolWireFormat: () => toToolWireFormat\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_schema = __webpack_require__(/*! @genkit-ai/core/schema */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nconst ModelIdSchema = import_zod.z.object({\n  modelProvider: import_zod.z.string().readonly(),\n  modelName: import_zod.z.string().readonly()\n});\nconst LlmStatsSchema = import_zod.z.object({\n  latencyMs: import_zod.z.number().optional(),\n  inputTokenCount: import_zod.z.number().optional(),\n  outputTokenCount: import_zod.z.number().optional()\n});\nconst ToolSchema = import_zod.z.object({\n  name: import_zod.z.string(),\n  description: import_zod.z.string().optional(),\n  schema: import_zod.z.any()\n});\nconst ToolCallSchema = import_zod.z.object({\n  toolName: import_zod.z.string(),\n  arguments: import_zod.z.any()\n});\nconst LlmResponseSchema = import_zod.z.object({\n  completion: import_zod.z.string(),\n  toolCalls: import_zod.z.array(ToolCallSchema).optional(),\n  stats: LlmStatsSchema\n});\nfunction toToolWireFormat(actions) {\n  if (!actions)\n    return void 0;\n  return actions.map((a) => {\n    return {\n      name: a.__action.name,\n      description: a.__action.description,\n      schema: {\n        input: (0, import_schema.toJsonSchema)({\n          schema: a.__action.inputSchema,\n          jsonSchema: a.__action.inputJsonSchema\n        }),\n        output: (0, import_schema.toJsonSchema)({\n          schema: a.__action.outputSchema,\n          jsonSchema: a.__action.outputJsonSchema\n        })\n      }\n    };\n  });\n}\nconst CommonLlmOptions = import_zod.z.object({\n  temperature: import_zod.z.number().optional(),\n  topK: import_zod.z.number().optional(),\n  topP: import_zod.z.number().optional()\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQywwREFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sQ0FRTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvYWkvbGliL3R5cGVzLmpzPzllM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHR5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHR5cGVzX2V4cG9ydHMsIHtcbiAgQ29tbW9uTGxtT3B0aW9uczogKCkgPT4gQ29tbW9uTGxtT3B0aW9ucyxcbiAgTGxtUmVzcG9uc2VTY2hlbWE6ICgpID0+IExsbVJlc3BvbnNlU2NoZW1hLFxuICBMbG1TdGF0c1NjaGVtYTogKCkgPT4gTGxtU3RhdHNTY2hlbWEsXG4gIE1vZGVsSWRTY2hlbWE6ICgpID0+IE1vZGVsSWRTY2hlbWEsXG4gIFRvb2xDYWxsU2NoZW1hOiAoKSA9PiBUb29sQ2FsbFNjaGVtYSxcbiAgVG9vbFNjaGVtYTogKCkgPT4gVG9vbFNjaGVtYSxcbiAgdG9Ub29sV2lyZUZvcm1hdDogKCkgPT4gdG9Ub29sV2lyZUZvcm1hdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh0eXBlc19leHBvcnRzKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZS9zY2hlbWFcIik7XG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBNb2RlbElkU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIG1vZGVsUHJvdmlkZXI6IGltcG9ydF96b2Quei5zdHJpbmcoKS5yZWFkb25seSgpLFxuICBtb2RlbE5hbWU6IGltcG9ydF96b2Quei5zdHJpbmcoKS5yZWFkb25seSgpXG59KTtcbmNvbnN0IExsbVN0YXRzU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGxhdGVuY3lNczogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIGlucHV0VG9rZW5Db3VudDogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIG91dHB1dFRva2VuQ291bnQ6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFRvb2xTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBkZXNjcmlwdGlvbjogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHNjaGVtYTogaW1wb3J0X3pvZC56LmFueSgpXG59KTtcbmNvbnN0IFRvb2xDYWxsU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHRvb2xOYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIGFyZ3VtZW50czogaW1wb3J0X3pvZC56LmFueSgpXG59KTtcbmNvbnN0IExsbVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGNvbXBsZXRpb246IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgdG9vbENhbGxzOiBpbXBvcnRfem9kLnouYXJyYXkoVG9vbENhbGxTY2hlbWEpLm9wdGlvbmFsKCksXG4gIHN0YXRzOiBMbG1TdGF0c1NjaGVtYVxufSk7XG5mdW5jdGlvbiB0b1Rvb2xXaXJlRm9ybWF0KGFjdGlvbnMpIHtcbiAgaWYgKCFhY3Rpb25zKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBhY3Rpb25zLm1hcCgoYSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhLl9fYWN0aW9uLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogYS5fX2FjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgIHNjaGVtYToge1xuICAgICAgICBpbnB1dDogKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICAgICAgc2NoZW1hOiBhLl9fYWN0aW9uLmlucHV0U2NoZW1hLFxuICAgICAgICAgIGpzb25TY2hlbWE6IGEuX19hY3Rpb24uaW5wdXRKc29uU2NoZW1hXG4gICAgICAgIH0pLFxuICAgICAgICBvdXRwdXQ6ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoe1xuICAgICAgICAgIHNjaGVtYTogYS5fX2FjdGlvbi5vdXRwdXRTY2hlbWEsXG4gICAgICAgICAganNvblNjaGVtYTogYS5fX2FjdGlvbi5vdXRwdXRKc29uU2NoZW1hXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5jb25zdCBDb21tb25MbG1PcHRpb25zID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHRlbXBlcmF0dXJlOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgdG9wSzogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIHRvcFA6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpXG59KTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDb21tb25MbG1PcHRpb25zLFxuICBMbG1SZXNwb25zZVNjaGVtYSxcbiAgTGxtU3RhdHNTY2hlbWEsXG4gIE1vZGVsSWRTY2hlbWEsXG4gIFRvb2xDYWxsU2NoZW1hLFxuICBUb29sU2NoZW1hLFxuICB0b1Rvb2xXaXJlRm9ybWF0XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/__codegen/version.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar version_exports = {};\n__export(version_exports, {\n  version: () => version\n});\nmodule.exports = __toCommonJS(version_exports);\nconst version = \"0.5.17\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL19fY29kZWdlbi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvX19jb2RlZ2VuL3ZlcnNpb24uanM/ZDFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgdmVyc2lvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh2ZXJzaW9uX2V4cG9ydHMsIHtcbiAgdmVyc2lvbjogKCkgPT4gdmVyc2lvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh2ZXJzaW9uX2V4cG9ydHMpO1xuY29uc3QgdmVyc2lvbiA9IFwiMC41LjE3XCI7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/action.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/action.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar action_exports = {};\n__export(action_exports, {\n  JSONSchema7: () => import_json_schema.JSONSchema7,\n  Status: () => import_statusTypes.Status,\n  StatusCodes: () => import_statusTypes.StatusCodes,\n  StatusSchema: () => import_statusTypes.StatusSchema,\n  action: () => action,\n  actionWithMiddleware: () => actionWithMiddleware,\n  defineAction: () => defineAction,\n  getStreamingCallback: () => getStreamingCallback,\n  runWithStreamingCallback: () => runWithStreamingCallback\n});\nmodule.exports = __toCommonJS(action_exports);\nvar import_json_schema = __webpack_require__(/*! json-schema */ \"(action-browser)/./node_modules/json-schema/lib/validate.js\");\nvar import_node_async_hooks = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nvar import_registry = __webpack_require__(/*! ./registry.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_statusTypes = __webpack_require__(/*! ./statusTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js\");\nfunction actionWithMiddleware(action2, middleware) {\n  const wrapped = (req) => __async(this, null, function* () {\n    const dispatch = (index, req2) => __async(this, null, function* () {\n      if (index === middleware.length) {\n        return yield action2(req2);\n      }\n      const currentMiddleware = middleware[index];\n      return currentMiddleware(\n        req2,\n        (modifiedReq) => __async(this, null, function* () {\n          return dispatch(index + 1, modifiedReq || req2);\n        })\n      );\n    });\n    return yield dispatch(0, req);\n  });\n  wrapped.__action = action2.__action;\n  return wrapped;\n}\nfunction action(config, fn) {\n  const actionName = typeof config.name === \"string\" ? validateActionName(config.name) : `${validatePluginName(config.name.pluginId)}/${validateActionId(config.name.actionId)}`;\n  const actionFn = (input) => __async(this, null, function* () {\n    input = (0, import_schema.parseSchema)(input, {\n      schema: config.inputSchema,\n      jsonSchema: config.inputJsonSchema\n    });\n    let output = yield (0, import_tracing.runInNewSpan)(\n      {\n        metadata: {\n          name: actionName\n        },\n        labels: {\n          [import_tracing.SPAN_TYPE_ATTR]: \"action\"\n        }\n      },\n      (metadata) => __async(this, null, function* () {\n        metadata.name = actionName;\n        metadata.input = input;\n        const output2 = yield fn(input);\n        metadata.output = JSON.stringify(output2);\n        return output2;\n      })\n    );\n    output = (0, import_schema.parseSchema)(output, {\n      schema: config.outputSchema,\n      jsonSchema: config.outputJsonSchema\n    });\n    return output;\n  });\n  actionFn.__action = {\n    name: actionName,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    inputJsonSchema: config.inputJsonSchema,\n    outputSchema: config.outputSchema,\n    outputJsonSchema: config.outputJsonSchema,\n    metadata: config.metadata\n  };\n  if (config.use) {\n    return actionWithMiddleware(actionFn, config.use);\n  }\n  return actionFn;\n}\nfunction validateActionName(name) {\n  if (name.includes(\"/\")) {\n    validatePluginName(name.split(\"/\", 1)[0]);\n    validateActionId(name.substring(name.indexOf(\"/\") + 1));\n  }\n  return name;\n}\nfunction validatePluginName(pluginId) {\n  if (!(0, import_registry.lookupPlugin)(pluginId)) {\n    throw new Error(\n      `Unable to find plugin name used in the action name: ${pluginId}`\n    );\n  }\n  return pluginId;\n}\nfunction validateActionId(actionId) {\n  if (actionId.includes(\"/\")) {\n    throw new Error(`Action name must not include slashes (/): ${actionId}`);\n  }\n  return actionId;\n}\nfunction defineAction(config, fn) {\n  const act = action(config, (i) => {\n    (0, import_tracing.setCustomMetadataAttributes)({ subtype: config.actionType });\n    return fn(i);\n  });\n  act.__action.actionType = config.actionType;\n  (0, import_registry.registerAction)(config.actionType, act);\n  return act;\n}\nconst streamingAls = new import_node_async_hooks.AsyncLocalStorage();\nconst sentinelNoopCallback = () => null;\nfunction runWithStreamingCallback(streamingCallback, fn) {\n  return streamingAls.run(streamingCallback || sentinelNoopCallback, fn);\n}\nfunction getStreamingCallback() {\n  const cb = streamingAls.getStore();\n  if (cb === sentinelNoopCallback) {\n    return void 0;\n  }\n  return cb;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=action.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsZ0ZBQWE7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsMENBQWtCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLHNGQUFlO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFjO0FBQzNDLHlCQUF5QixtQkFBTyxDQUFDLDRGQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlDQUF5QyxHQUFHLHVDQUF1QztBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBVUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2FjdGlvbi5qcz8yMzFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgYWN0aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFjdGlvbl9leHBvcnRzLCB7XG4gIEpTT05TY2hlbWE3OiAoKSA9PiBpbXBvcnRfanNvbl9zY2hlbWEuSlNPTlNjaGVtYTcsXG4gIFN0YXR1czogKCkgPT4gaW1wb3J0X3N0YXR1c1R5cGVzLlN0YXR1cyxcbiAgU3RhdHVzQ29kZXM6ICgpID0+IGltcG9ydF9zdGF0dXNUeXBlcy5TdGF0dXNDb2RlcyxcbiAgU3RhdHVzU2NoZW1hOiAoKSA9PiBpbXBvcnRfc3RhdHVzVHlwZXMuU3RhdHVzU2NoZW1hLFxuICBhY3Rpb246ICgpID0+IGFjdGlvbixcbiAgYWN0aW9uV2l0aE1pZGRsZXdhcmU6ICgpID0+IGFjdGlvbldpdGhNaWRkbGV3YXJlLFxuICBkZWZpbmVBY3Rpb246ICgpID0+IGRlZmluZUFjdGlvbixcbiAgZ2V0U3RyZWFtaW5nQ2FsbGJhY2s6ICgpID0+IGdldFN0cmVhbWluZ0NhbGxiYWNrLFxuICBydW5XaXRoU3RyZWFtaW5nQ2FsbGJhY2s6ICgpID0+IHJ1bldpdGhTdHJlYW1pbmdDYWxsYmFja1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhhY3Rpb25fZXhwb3J0cyk7XG52YXIgaW1wb3J0X2pzb25fc2NoZW1hID0gcmVxdWlyZShcImpzb24tc2NoZW1hXCIpO1xudmFyIGltcG9ydF9ub2RlX2FzeW5jX2hvb2tzID0gcmVxdWlyZShcIm5vZGU6YXN5bmNfaG9va3NcIik7XG52YXIgaW1wb3J0X3JlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vcmVnaXN0cnkuanNcIik7XG52YXIgaW1wb3J0X3NjaGVtYSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbnZhciBpbXBvcnRfdHJhY2luZyA9IHJlcXVpcmUoXCIuL3RyYWNpbmcuanNcIik7XG52YXIgaW1wb3J0X3N0YXR1c1R5cGVzID0gcmVxdWlyZShcIi4vc3RhdHVzVHlwZXMuanNcIik7XG5mdW5jdGlvbiBhY3Rpb25XaXRoTWlkZGxld2FyZShhY3Rpb24yLCBtaWRkbGV3YXJlKSB7XG4gIGNvbnN0IHdyYXBwZWQgPSAocmVxKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoaW5kZXgsIHJlcTIpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gbWlkZGxld2FyZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGFjdGlvbjIocmVxMik7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50TWlkZGxld2FyZSA9IG1pZGRsZXdhcmVbaW5kZXhdO1xuICAgICAgcmV0dXJuIGN1cnJlbnRNaWRkbGV3YXJlKFxuICAgICAgICByZXEyLFxuICAgICAgICAobW9kaWZpZWRSZXEpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goaW5kZXggKyAxLCBtb2RpZmllZFJlcSB8fCByZXEyKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHlpZWxkIGRpc3BhdGNoKDAsIHJlcSk7XG4gIH0pO1xuICB3cmFwcGVkLl9fYWN0aW9uID0gYWN0aW9uMi5fX2FjdGlvbjtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5mdW5jdGlvbiBhY3Rpb24oY29uZmlnLCBmbikge1xuICBjb25zdCBhY3Rpb25OYW1lID0gdHlwZW9mIGNvbmZpZy5uYW1lID09PSBcInN0cmluZ1wiID8gdmFsaWRhdGVBY3Rpb25OYW1lKGNvbmZpZy5uYW1lKSA6IGAke3ZhbGlkYXRlUGx1Z2luTmFtZShjb25maWcubmFtZS5wbHVnaW5JZCl9LyR7dmFsaWRhdGVBY3Rpb25JZChjb25maWcubmFtZS5hY3Rpb25JZCl9YDtcbiAgY29uc3QgYWN0aW9uRm4gPSAoaW5wdXQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpbnB1dCA9ICgwLCBpbXBvcnRfc2NoZW1hLnBhcnNlU2NoZW1hKShpbnB1dCwge1xuICAgICAgc2NoZW1hOiBjb25maWcuaW5wdXRTY2hlbWEsXG4gICAgICBqc29uU2NoZW1hOiBjb25maWcuaW5wdXRKc29uU2NoZW1hXG4gICAgfSk7XG4gICAgbGV0IG91dHB1dCA9IHlpZWxkICgwLCBpbXBvcnRfdHJhY2luZy5ydW5Jbk5ld1NwYW4pKFxuICAgICAge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIG5hbWU6IGFjdGlvbk5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgW2ltcG9ydF90cmFjaW5nLlNQQU5fVFlQRV9BVFRSXTogXCJhY3Rpb25cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKG1ldGFkYXRhKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIG1ldGFkYXRhLm5hbWUgPSBhY3Rpb25OYW1lO1xuICAgICAgICBtZXRhZGF0YS5pbnB1dCA9IGlucHV0O1xuICAgICAgICBjb25zdCBvdXRwdXQyID0geWllbGQgZm4oaW5wdXQpO1xuICAgICAgICBtZXRhZGF0YS5vdXRwdXQgPSBKU09OLnN0cmluZ2lmeShvdXRwdXQyKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDI7XG4gICAgICB9KVxuICAgICk7XG4gICAgb3V0cHV0ID0gKDAsIGltcG9ydF9zY2hlbWEucGFyc2VTY2hlbWEpKG91dHB1dCwge1xuICAgICAgc2NoZW1hOiBjb25maWcub3V0cHV0U2NoZW1hLFxuICAgICAganNvblNjaGVtYTogY29uZmlnLm91dHB1dEpzb25TY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcbiAgYWN0aW9uRm4uX19hY3Rpb24gPSB7XG4gICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICBkZXNjcmlwdGlvbjogY29uZmlnLmRlc2NyaXB0aW9uLFxuICAgIGlucHV0U2NoZW1hOiBjb25maWcuaW5wdXRTY2hlbWEsXG4gICAgaW5wdXRKc29uU2NoZW1hOiBjb25maWcuaW5wdXRKc29uU2NoZW1hLFxuICAgIG91dHB1dFNjaGVtYTogY29uZmlnLm91dHB1dFNjaGVtYSxcbiAgICBvdXRwdXRKc29uU2NoZW1hOiBjb25maWcub3V0cHV0SnNvblNjaGVtYSxcbiAgICBtZXRhZGF0YTogY29uZmlnLm1ldGFkYXRhXG4gIH07XG4gIGlmIChjb25maWcudXNlKSB7XG4gICAgcmV0dXJuIGFjdGlvbldpdGhNaWRkbGV3YXJlKGFjdGlvbkZuLCBjb25maWcudXNlKTtcbiAgfVxuICByZXR1cm4gYWN0aW9uRm47XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFjdGlvbk5hbWUobmFtZSkge1xuICBpZiAobmFtZS5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICB2YWxpZGF0ZVBsdWdpbk5hbWUobmFtZS5zcGxpdChcIi9cIiwgMSlbMF0pO1xuICAgIHZhbGlkYXRlQWN0aW9uSWQobmFtZS5zdWJzdHJpbmcobmFtZS5pbmRleE9mKFwiL1wiKSArIDEpKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGx1Z2luTmFtZShwbHVnaW5JZCkge1xuICBpZiAoISgwLCBpbXBvcnRfcmVnaXN0cnkubG9va3VwUGx1Z2luKShwbHVnaW5JZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5hYmxlIHRvIGZpbmQgcGx1Z2luIG5hbWUgdXNlZCBpbiB0aGUgYWN0aW9uIG5hbWU6ICR7cGx1Z2luSWR9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHBsdWdpbklkO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpb25JZChhY3Rpb25JZCkge1xuICBpZiAoYWN0aW9uSWQuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gbmFtZSBtdXN0IG5vdCBpbmNsdWRlIHNsYXNoZXMgKC8pOiAke2FjdGlvbklkfWApO1xuICB9XG4gIHJldHVybiBhY3Rpb25JZDtcbn1cbmZ1bmN0aW9uIGRlZmluZUFjdGlvbihjb25maWcsIGZuKSB7XG4gIGNvbnN0IGFjdCA9IGFjdGlvbihjb25maWcsIChpKSA9PiB7XG4gICAgKDAsIGltcG9ydF90cmFjaW5nLnNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlcykoeyBzdWJ0eXBlOiBjb25maWcuYWN0aW9uVHlwZSB9KTtcbiAgICByZXR1cm4gZm4oaSk7XG4gIH0pO1xuICBhY3QuX19hY3Rpb24uYWN0aW9uVHlwZSA9IGNvbmZpZy5hY3Rpb25UeXBlO1xuICAoMCwgaW1wb3J0X3JlZ2lzdHJ5LnJlZ2lzdGVyQWN0aW9uKShjb25maWcuYWN0aW9uVHlwZSwgYWN0KTtcbiAgcmV0dXJuIGFjdDtcbn1cbmNvbnN0IHN0cmVhbWluZ0FscyA9IG5ldyBpbXBvcnRfbm9kZV9hc3luY19ob29rcy5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuY29uc3Qgc2VudGluZWxOb29wQ2FsbGJhY2sgPSAoKSA9PiBudWxsO1xuZnVuY3Rpb24gcnVuV2l0aFN0cmVhbWluZ0NhbGxiYWNrKHN0cmVhbWluZ0NhbGxiYWNrLCBmbikge1xuICByZXR1cm4gc3RyZWFtaW5nQWxzLnJ1bihzdHJlYW1pbmdDYWxsYmFjayB8fCBzZW50aW5lbE5vb3BDYWxsYmFjaywgZm4pO1xufVxuZnVuY3Rpb24gZ2V0U3RyZWFtaW5nQ2FsbGJhY2soKSB7XG4gIGNvbnN0IGNiID0gc3RyZWFtaW5nQWxzLmdldFN0b3JlKCk7XG4gIGlmIChjYiA9PT0gc2VudGluZWxOb29wQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBjYjtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBKU09OU2NoZW1hNyxcbiAgU3RhdHVzLFxuICBTdGF0dXNDb2RlcyxcbiAgU3RhdHVzU2NoZW1hLFxuICBhY3Rpb24sXG4gIGFjdGlvbldpdGhNaWRkbGV3YXJlLFxuICBkZWZpbmVBY3Rpb24sXG4gIGdldFN0cmVhbWluZ0NhbGxiYWNrLFxuICBydW5XaXRoU3RyZWFtaW5nQ2FsbGJhY2tcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/config.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/config.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar config_exports = {};\n__export(config_exports, {\n  __hardResetConfigForTesting: () => __hardResetConfigForTesting,\n  config: () => config,\n  configureGenkit: () => configureGenkit,\n  getCurrentEnv: () => getCurrentEnv,\n  initializeGenkit: () => initializeGenkit,\n  isDevEnv: () => isDevEnv\n});\nmodule.exports = __toCommonJS(config_exports);\nvar import_fs = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_localFileFlowStateStore = __webpack_require__(/*! ./localFileFlowStateStore.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/localFileFlowStateStore.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar registry = __toESM(__webpack_require__(/*! ./registry.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\"));\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nvar import_localFileTraceStore = __webpack_require__(/*! ./tracing/localFileTraceStore.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/localFileTraceStore.js\");\n__reExport(config_exports, __webpack_require__(/*! ./plugin.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js\"), module.exports);\nlet config;\nclass Config {\n  constructor(options) {\n    this.configuredEnvs = /* @__PURE__ */ new Set([\"dev\"]);\n    this.options = options;\n    this.telemetryConfig = () => __async(this, null, function* () {\n      return {\n        getConfig() {\n          return {};\n        }\n      };\n    });\n    this.configure();\n  }\n  /**\n   * Returns a flow state store instance for the running environment.\n   * If no store is configured, will throw an error.\n   */\n  getFlowStateStore() {\n    return __async(this, null, function* () {\n      const flowStateStore = yield registry.lookupFlowStateStore(getCurrentEnv());\n      if (!flowStateStore) {\n        throw new Error(\"No flow store is configured.\");\n      }\n      return flowStateStore;\n    });\n  }\n  /**\n   * Returns a trace store instance for the running environment.\n   * If no store is configured, will return undefined.\n   */\n  getTraceStore() {\n    return __async(this, null, function* () {\n      return yield registry.lookupTraceStore(getCurrentEnv());\n    });\n  }\n  /**\n   * Returns the configuration for exporting Telemetry data for the current\n   * environment.\n   */\n  getTelemetryConfig() {\n    return this.telemetryConfig();\n  }\n  /**\n   * Configures the system.\n   */\n  configure() {\n    var _a, _b, _c;\n    if (this.options.logLevel) {\n      import_logging.logger.setLogLevel(this.options.logLevel);\n    }\n    (_a = this.options.plugins) == null ? void 0 : _a.forEach((plugin) => {\n      import_logging.logger.debug(`Registering plugin ${plugin.name}...`);\n      registry.registerPluginProvider(plugin.name, {\n        name: plugin.name,\n        initializer() {\n          return __async(this, null, function* () {\n            import_logging.logger.info(`Initializing plugin ${plugin.name}:`);\n            return yield plugin.initializer();\n          });\n        }\n      });\n    });\n    if ((_b = this.options.telemetry) == null ? void 0 : _b.logger) {\n      const loggerPluginName = this.options.telemetry.logger;\n      import_logging.logger.debug(\"Registering logging exporters...\");\n      import_logging.logger.debug(`  - all environments: ${loggerPluginName}`);\n      this.loggerConfig = () => __async(this, null, function* () {\n        return this.resolveLoggerConfig(loggerPluginName);\n      });\n    }\n    if ((_c = this.options.telemetry) == null ? void 0 : _c.instrumentation) {\n      const telemetryPluginName = this.options.telemetry.instrumentation;\n      import_logging.logger.debug(\"Registering telemetry exporters...\");\n      import_logging.logger.debug(`  - all environments: ${telemetryPluginName}`);\n      this.telemetryConfig = () => __async(this, null, function* () {\n        return this.resolveTelemetryConfig(telemetryPluginName);\n      });\n    }\n    import_logging.logger.debug(\"Registering flow state stores...\");\n    if (isDevEnv()) {\n      registry.registerFlowStateStore(\n        \"dev\",\n        () => __async(this, null, function* () {\n          return new import_localFileFlowStateStore.LocalFileFlowStateStore();\n        })\n      );\n      import_logging.logger.debug(\"Registered dev flow state store.\");\n    }\n    if (this.options.flowStateStore) {\n      const flowStorePluginName = this.options.flowStateStore;\n      import_logging.logger.debug(`  - prod: ${flowStorePluginName}`);\n      this.configuredEnvs.add(\"prod\");\n      registry.registerFlowStateStore(\n        \"prod\",\n        () => this.resolveFlowStateStore(flowStorePluginName)\n      );\n    }\n    import_logging.logger.debug(\"Registering trace stores...\");\n    if (isDevEnv()) {\n      registry.registerTraceStore(\"dev\", () => __async(this, null, function* () {\n        return new import_localFileTraceStore.LocalFileTraceStore();\n      }));\n      import_logging.logger.debug(\"Registered dev trace store.\");\n    }\n    if (this.options.traceStore) {\n      const traceStorePluginName = this.options.traceStore;\n      import_logging.logger.debug(`  - prod: ${traceStorePluginName}`);\n      this.configuredEnvs.add(\"prod\");\n      registry.registerTraceStore(\n        \"prod\",\n        () => this.resolveTraceStore(traceStorePluginName)\n      );\n      if (isDevEnv()) {\n        import_logging.logger.info(\n          \"In dev mode `traceStore` is defaulted to local file store.\"\n        );\n      }\n    } else {\n      import_logging.logger.info(\n        \"`traceStore` is not specified in the config; Traces are not going to be persisted in prod.\"\n      );\n    }\n  }\n  /**\n   * Sets up the tracing and logging as configured.\n   *\n   * Note: the logging configuration must come after tracing has been enabled to\n   * ensure that all tracing instrumentations are applied.\n   * See limitations described here:\n   * https://github.com/open-telemetry/opentelemetry-js/tree/main/experimental/packages/opentelemetry-instrumentation#limitations\n   */\n  setupTracingAndLogging() {\n    return __async(this, null, function* () {\n      if (this.options.enableTracingAndMetrics) {\n        (0, import_tracing.enableTracingAndMetrics)(\n          yield this.getTelemetryConfig(),\n          yield this.getTraceStore()\n        );\n      }\n      if (this.loggerConfig) {\n        import_logging.logger.init(yield this.loggerConfig());\n      }\n    });\n  }\n  /**\n   * Resolves flow state store provided by the specified plugin.\n   */\n  resolveFlowStateStore(pluginName) {\n    return __async(this, null, function* () {\n      let flowStoreId;\n      if (pluginName.includes(\"/\")) {\n        const tokens = pluginName.split(\"/\", 2);\n        pluginName = tokens[0];\n        flowStoreId = tokens[1];\n      }\n      const plugin = yield registry.initializePlugin(pluginName);\n      let provider = plugin == null ? void 0 : plugin.flowStateStore;\n      if (!provider) {\n        throw new Error(\n          \"Unable to resolve provided `flowStateStore` for plugin: \" + pluginName\n        );\n      }\n      if (!Array.isArray(provider)) {\n        provider = [provider];\n      }\n      if (provider.length === 1 && !flowStoreId) {\n        return provider[0].value;\n      }\n      if (provider.length > 1 && !flowStoreId) {\n        throw new Error(\n          `Plugin ${pluginName} provides more than one flow state store implementation (${provider.map((p2) => p2.id).join(\", \")}), please specify the flow state store id (e.g. \"${pluginName}/${provider[0].id}\")`\n        );\n      }\n      const p = provider.find((p2) => p2.id === flowStoreId);\n      if (!p) {\n        throw new Error(\n          `Plugin ${pluginName} does not provide flow state store ${flowStoreId}`\n        );\n      }\n      return p.value;\n    });\n  }\n  /**\n   * Resolves trace store provided by the specified plugin.\n   */\n  resolveTraceStore(pluginName) {\n    return __async(this, null, function* () {\n      let traceStoreId;\n      if (pluginName.includes(\"/\")) {\n        const tokens = pluginName.split(\"/\", 2);\n        pluginName = tokens[0];\n        traceStoreId = tokens[1];\n      }\n      const plugin = yield registry.initializePlugin(pluginName);\n      let provider = plugin == null ? void 0 : plugin.traceStore;\n      if (!provider) {\n        throw new Error(\n          \"Unable to resolve provided `traceStore` for plugin: \" + pluginName\n        );\n      }\n      if (!Array.isArray(provider)) {\n        provider = [provider];\n      }\n      if (provider.length === 1 && !traceStoreId) {\n        return provider[0].value;\n      }\n      if (provider.length > 1 && !traceStoreId) {\n        throw new Error(\n          `Plugin ${pluginName} provides more than one trace store implementation (${provider.map((p2) => p2.id).join(\", \")}), please specify the trace store id (e.g. \"${pluginName}/${provider[0].id}\")`\n        );\n      }\n      const p = provider.find((p2) => p2.id === traceStoreId);\n      if (!p) {\n        throw new Error(\n          `Plugin ${pluginName} does not provide trace store ${traceStoreId}`\n        );\n      }\n      return p.value;\n    });\n  }\n  /**\n   * Resolves the telemetry configuration provided by the specified plugin.\n   */\n  resolveTelemetryConfig(pluginName) {\n    return __async(this, null, function* () {\n      var _a;\n      const plugin = yield registry.initializePlugin(pluginName);\n      const provider = (_a = plugin == null ? void 0 : plugin.telemetry) == null ? void 0 : _a.instrumentation;\n      if (!provider) {\n        throw new Error(\n          \"Unable to resolve provider `telemetry.instrumentation` for plugin: \" + pluginName\n        );\n      }\n      return provider.value;\n    });\n  }\n  /**\n   * Resolves the logging configuration provided by the specified plugin.\n   */\n  resolveLoggerConfig(pluginName) {\n    return __async(this, null, function* () {\n      var _a;\n      const plugin = yield registry.initializePlugin(pluginName);\n      const provider = (_a = plugin == null ? void 0 : plugin.telemetry) == null ? void 0 : _a.logger;\n      if (!provider) {\n        throw new Error(\n          \"Unable to resolve provider `telemetry.logger` for plugin: \" + pluginName\n        );\n      }\n      return provider.value;\n    });\n  }\n}\nfunction configureGenkit(options) {\n  if (config) {\n    import_logging.logger.warn(\"configureGenkit was already called\");\n  }\n  config = new Config(options);\n  config.setupTracingAndLogging();\n  return config;\n}\nfunction initializeGenkit(cfg) {\n  if (config || cfg) {\n    return;\n  }\n  const configPath = findGenkitConfig();\n  if (!configPath) {\n    throw Error(\n      \"Unable to find genkit.config.js in any of the parent directories.\"\n    );\n  }\n  __webpack_require__(\"(action-browser)/./node_modules/@genkit-ai/core/lib sync recursive\")(configPath);\n}\nfunction getCurrentEnv() {\n  return process.env.GENKIT_ENV || \"prod\";\n}\nfunction isDevEnv() {\n  return getCurrentEnv() === \"dev\";\n}\nfunction findGenkitConfig() {\n  var _a;\n  let current = (_a = __webpack_require__(\"(action-browser)/./node_modules/@genkit-ai/core/lib sync recursive\") == null ? void 0 : __webpack_require__.c[__webpack_require__.s]) == null ? void 0 : _a.filename;\n  if (!current) {\n    throw new Error(\"Unable to resolve package root.\");\n  }\n  while (import_path.default.resolve(current, \"..\") !== current) {\n    if (import_fs.default.existsSync(import_path.default.resolve(current, \"genkit.config.js\"))) {\n      return import_path.default.resolve(current, \"genkit.config.js\");\n    }\n    current = import_path.default.resolve(current, \"..\");\n  }\n  return void 0;\n}\nfunction __hardResetConfigForTesting() {\n  config = void 0;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsY0FBSTtBQUNwQywwQkFBMEIsbUJBQU8sQ0FBQyxrQkFBTTtBQUN4QyxxQ0FBcUMsbUJBQU8sQ0FBQyxvSEFBOEI7QUFDM0UscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWU7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsNEhBQWtDO0FBQzNFLDJCQUEyQixtQkFBTyxDQUFDLGtGQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9CQUFvQjtBQUMvRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFxQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSwwREFBMEQsdUNBQXVDLG1EQUFtRCxXQUFXLEdBQUcsZUFBZTtBQUNqTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksb0NBQW9DLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLHFEQUFxRCx1Q0FBdUMsOENBQThDLFdBQVcsR0FBRyxlQUFlO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSwrQkFBK0IsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwRkFBUSxVQUFVLENBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlGQUFPLG9CQUFvQiw0Q0FBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBUUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2NvbmZpZy5qcz85NWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kLCBzZWNvbmRUYXJnZXQpID0+IChfX2NvcHlQcm9wcyh0YXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpLCBzZWNvbmRUYXJnZXQgJiYgX19jb3B5UHJvcHMoc2Vjb25kVGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSk7XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGNvbmZpZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25maWdfZXhwb3J0cywge1xuICBfX2hhcmRSZXNldENvbmZpZ0ZvclRlc3Rpbmc6ICgpID0+IF9faGFyZFJlc2V0Q29uZmlnRm9yVGVzdGluZyxcbiAgY29uZmlnOiAoKSA9PiBjb25maWcsXG4gIGNvbmZpZ3VyZUdlbmtpdDogKCkgPT4gY29uZmlndXJlR2Vua2l0LFxuICBnZXRDdXJyZW50RW52OiAoKSA9PiBnZXRDdXJyZW50RW52LFxuICBpbml0aWFsaXplR2Vua2l0OiAoKSA9PiBpbml0aWFsaXplR2Vua2l0LFxuICBpc0RldkVudjogKCkgPT4gaXNEZXZFbnZcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoY29uZmlnX2V4cG9ydHMpO1xudmFyIGltcG9ydF9mcyA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfcGF0aCA9IF9fdG9FU00ocmVxdWlyZShcInBhdGhcIikpO1xudmFyIGltcG9ydF9sb2NhbEZpbGVGbG93U3RhdGVTdG9yZSA9IHJlcXVpcmUoXCIuL2xvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlLmpzXCIpO1xudmFyIGltcG9ydF9sb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZy5qc1wiKTtcbnZhciByZWdpc3RyeSA9IF9fdG9FU00ocmVxdWlyZShcIi4vcmVnaXN0cnkuanNcIikpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIi4vdHJhY2luZy5qc1wiKTtcbnZhciBpbXBvcnRfbG9jYWxGaWxlVHJhY2VTdG9yZSA9IHJlcXVpcmUoXCIuL3RyYWNpbmcvbG9jYWxGaWxlVHJhY2VTdG9yZS5qc1wiKTtcbl9fcmVFeHBvcnQoY29uZmlnX2V4cG9ydHMsIHJlcXVpcmUoXCIuL3BsdWdpbi5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xubGV0IGNvbmZpZztcbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZ3VyZWRFbnZzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGV2XCJdKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudGVsZW1ldHJ5Q29uZmlnID0gKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxvdyBzdGF0ZSBzdG9yZSBpbnN0YW5jZSBmb3IgdGhlIHJ1bm5pbmcgZW52aXJvbm1lbnQuXG4gICAqIElmIG5vIHN0b3JlIGlzIGNvbmZpZ3VyZWQsIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqL1xuICBnZXRGbG93U3RhdGVTdG9yZSgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZmxvd1N0YXRlU3RvcmUgPSB5aWVsZCByZWdpc3RyeS5sb29rdXBGbG93U3RhdGVTdG9yZShnZXRDdXJyZW50RW52KCkpO1xuICAgICAgaWYgKCFmbG93U3RhdGVTdG9yZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmbG93IHN0b3JlIGlzIGNvbmZpZ3VyZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsb3dTdGF0ZVN0b3JlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdHJhY2Ugc3RvcmUgaW5zdGFuY2UgZm9yIHRoZSBydW5uaW5nIGVudmlyb25tZW50LlxuICAgKiBJZiBubyBzdG9yZSBpcyBjb25maWd1cmVkLCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG4gICAqL1xuICBnZXRUcmFjZVN0b3JlKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgcmVnaXN0cnkubG9va3VwVHJhY2VTdG9yZShnZXRDdXJyZW50RW52KCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb25maWd1cmF0aW9uIGZvciBleHBvcnRpbmcgVGVsZW1ldHJ5IGRhdGEgZm9yIHRoZSBjdXJyZW50XG4gICAqIGVudmlyb25tZW50LlxuICAgKi9cbiAgZ2V0VGVsZW1ldHJ5Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLnRlbGVtZXRyeUNvbmZpZygpO1xuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSBzeXN0ZW0uXG4gICAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dMZXZlbCkge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLnNldExvZ0xldmVsKHRoaXMub3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgfVxuICAgIChfYSA9IHRoaXMub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoYFJlZ2lzdGVyaW5nIHBsdWdpbiAke3BsdWdpbi5uYW1lfS4uLmApO1xuICAgICAgcmVnaXN0cnkucmVnaXN0ZXJQbHVnaW5Qcm92aWRlcihwbHVnaW4ubmFtZSwge1xuICAgICAgICBuYW1lOiBwbHVnaW4ubmFtZSxcbiAgICAgICAgaW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5pbmZvKGBJbml0aWFsaXppbmcgcGx1Z2luICR7cGx1Z2luLm5hbWV9OmApO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBsdWdpbi5pbml0aWFsaXplcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoKF9iID0gdGhpcy5vcHRpb25zLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmxvZ2dlcikge1xuICAgICAgY29uc3QgbG9nZ2VyUGx1Z2luTmFtZSA9IHRoaXMub3B0aW9ucy50ZWxlbWV0cnkubG9nZ2VyO1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgbG9nZ2luZyBleHBvcnRlcnMuLi5cIik7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoYCAgLSBhbGwgZW52aXJvbm1lbnRzOiAke2xvZ2dlclBsdWdpbk5hbWV9YCk7XG4gICAgICB0aGlzLmxvZ2dlckNvbmZpZyA9ICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUxvZ2dlckNvbmZpZyhsb2dnZXJQbHVnaW5OYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKF9jID0gdGhpcy5vcHRpb25zLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmluc3RydW1lbnRhdGlvbikge1xuICAgICAgY29uc3QgdGVsZW1ldHJ5UGx1Z2luTmFtZSA9IHRoaXMub3B0aW9ucy50ZWxlbWV0cnkuaW5zdHJ1bWVudGF0aW9uO1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgdGVsZW1ldHJ5IGV4cG9ydGVycy4uLlwiKTtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhgICAtIGFsbCBlbnZpcm9ubWVudHM6ICR7dGVsZW1ldHJ5UGx1Z2luTmFtZX1gKTtcbiAgICAgIHRoaXMudGVsZW1ldHJ5Q29uZmlnID0gKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlVGVsZW1ldHJ5Q29uZmlnKHRlbGVtZXRyeVBsdWdpbk5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIlJlZ2lzdGVyaW5nIGZsb3cgc3RhdGUgc3RvcmVzLi4uXCIpO1xuICAgIGlmIChpc0RldkVudigpKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RlckZsb3dTdGF0ZVN0b3JlKFxuICAgICAgICBcImRldlwiLFxuICAgICAgICAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBpbXBvcnRfbG9jYWxGaWxlRmxvd1N0YXRlU3RvcmUuTG9jYWxGaWxlRmxvd1N0YXRlU3RvcmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmVkIGRldiBmbG93IHN0YXRlIHN0b3JlLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mbG93U3RhdGVTdG9yZSkge1xuICAgICAgY29uc3QgZmxvd1N0b3JlUGx1Z2luTmFtZSA9IHRoaXMub3B0aW9ucy5mbG93U3RhdGVTdG9yZTtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhgICAtIHByb2Q6ICR7Zmxvd1N0b3JlUGx1Z2luTmFtZX1gKTtcbiAgICAgIHRoaXMuY29uZmlndXJlZEVudnMuYWRkKFwicHJvZFwiKTtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyRmxvd1N0YXRlU3RvcmUoXG4gICAgICAgIFwicHJvZFwiLFxuICAgICAgICAoKSA9PiB0aGlzLnJlc29sdmVGbG93U3RhdGVTdG9yZShmbG93U3RvcmVQbHVnaW5OYW1lKVxuICAgICAgKTtcbiAgICB9XG4gICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgdHJhY2Ugc3RvcmVzLi4uXCIpO1xuICAgIGlmIChpc0RldkVudigpKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RlclRyYWNlU3RvcmUoXCJkZXZcIiwgKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IGltcG9ydF9sb2NhbEZpbGVUcmFjZVN0b3JlLkxvY2FsRmlsZVRyYWNlU3RvcmUoKTtcbiAgICAgIH0pKTtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIlJlZ2lzdGVyZWQgZGV2IHRyYWNlIHN0b3JlLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFjZVN0b3JlKSB7XG4gICAgICBjb25zdCB0cmFjZVN0b3JlUGx1Z2luTmFtZSA9IHRoaXMub3B0aW9ucy50cmFjZVN0b3JlO1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGAgIC0gcHJvZDogJHt0cmFjZVN0b3JlUGx1Z2luTmFtZX1gKTtcbiAgICAgIHRoaXMuY29uZmlndXJlZEVudnMuYWRkKFwicHJvZFwiKTtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyVHJhY2VTdG9yZShcbiAgICAgICAgXCJwcm9kXCIsXG4gICAgICAgICgpID0+IHRoaXMucmVzb2x2ZVRyYWNlU3RvcmUodHJhY2VTdG9yZVBsdWdpbk5hbWUpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGV2RW52KCkpIHtcbiAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmluZm8oXG4gICAgICAgICAgXCJJbiBkZXYgbW9kZSBgdHJhY2VTdG9yZWAgaXMgZGVmYXVsdGVkIHRvIGxvY2FsIGZpbGUgc3RvcmUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmluZm8oXG4gICAgICAgIFwiYHRyYWNlU3RvcmVgIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZzsgVHJhY2VzIGFyZSBub3QgZ29pbmcgdG8gYmUgcGVyc2lzdGVkIGluIHByb2QuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSB0cmFjaW5nIGFuZCBsb2dnaW5nIGFzIGNvbmZpZ3VyZWQuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24gbXVzdCBjb21lIGFmdGVyIHRyYWNpbmcgaGFzIGJlZW4gZW5hYmxlZCB0b1xuICAgKiBlbnN1cmUgdGhhdCBhbGwgdHJhY2luZyBpbnN0cnVtZW50YXRpb25zIGFyZSBhcHBsaWVkLlxuICAgKiBTZWUgbGltaXRhdGlvbnMgZGVzY3JpYmVkIGhlcmU6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWpzL3RyZWUvbWFpbi9leHBlcmltZW50YWwvcGFja2FnZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24jbGltaXRhdGlvbnNcbiAgICovXG4gIHNldHVwVHJhY2luZ0FuZExvZ2dpbmcoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlVHJhY2luZ0FuZE1ldHJpY3MpIHtcbiAgICAgICAgKDAsIGltcG9ydF90cmFjaW5nLmVuYWJsZVRyYWNpbmdBbmRNZXRyaWNzKShcbiAgICAgICAgICB5aWVsZCB0aGlzLmdldFRlbGVtZXRyeUNvbmZpZygpLFxuICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0VHJhY2VTdG9yZSgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sb2dnZXJDb25maWcpIHtcbiAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmluaXQoeWllbGQgdGhpcy5sb2dnZXJDb25maWcoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGZsb3cgc3RhdGUgc3RvcmUgcHJvdmlkZWQgYnkgdGhlIHNwZWNpZmllZCBwbHVnaW4uXG4gICAqL1xuICByZXNvbHZlRmxvd1N0YXRlU3RvcmUocGx1Z2luTmFtZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgZmxvd1N0b3JlSWQ7XG4gICAgICBpZiAocGx1Z2luTmFtZS5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gcGx1Z2luTmFtZS5zcGxpdChcIi9cIiwgMik7XG4gICAgICAgIHBsdWdpbk5hbWUgPSB0b2tlbnNbMF07XG4gICAgICAgIGZsb3dTdG9yZUlkID0gdG9rZW5zWzFdO1xuICAgICAgfVxuICAgICAgY29uc3QgcGx1Z2luID0geWllbGQgcmVnaXN0cnkuaW5pdGlhbGl6ZVBsdWdpbihwbHVnaW5OYW1lKTtcbiAgICAgIGxldCBwcm92aWRlciA9IHBsdWdpbiA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luLmZsb3dTdGF0ZVN0b3JlO1xuICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbmFibGUgdG8gcmVzb2x2ZSBwcm92aWRlZCBgZmxvd1N0YXRlU3RvcmVgIGZvciBwbHVnaW46IFwiICsgcGx1Z2luTmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICBwcm92aWRlciA9IFtwcm92aWRlcl07XG4gICAgICB9XG4gICAgICBpZiAocHJvdmlkZXIubGVuZ3RoID09PSAxICYmICFmbG93U3RvcmVJZCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJbMF0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvdmlkZXIubGVuZ3RoID4gMSAmJiAhZmxvd1N0b3JlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQbHVnaW4gJHtwbHVnaW5OYW1lfSBwcm92aWRlcyBtb3JlIHRoYW4gb25lIGZsb3cgc3RhdGUgc3RvcmUgaW1wbGVtZW50YXRpb24gKCR7cHJvdmlkZXIubWFwKChwMikgPT4gcDIuaWQpLmpvaW4oXCIsIFwiKX0pLCBwbGVhc2Ugc3BlY2lmeSB0aGUgZmxvdyBzdGF0ZSBzdG9yZSBpZCAoZS5nLiBcIiR7cGx1Z2luTmFtZX0vJHtwcm92aWRlclswXS5pZH1cIilgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gcHJvdmlkZXIuZmluZCgocDIpID0+IHAyLmlkID09PSBmbG93U3RvcmVJZCk7XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQbHVnaW4gJHtwbHVnaW5OYW1lfSBkb2VzIG5vdCBwcm92aWRlIGZsb3cgc3RhdGUgc3RvcmUgJHtmbG93U3RvcmVJZH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgdHJhY2Ugc3RvcmUgcHJvdmlkZWQgYnkgdGhlIHNwZWNpZmllZCBwbHVnaW4uXG4gICAqL1xuICByZXNvbHZlVHJhY2VTdG9yZShwbHVnaW5OYW1lKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCB0cmFjZVN0b3JlSWQ7XG4gICAgICBpZiAocGx1Z2luTmFtZS5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gcGx1Z2luTmFtZS5zcGxpdChcIi9cIiwgMik7XG4gICAgICAgIHBsdWdpbk5hbWUgPSB0b2tlbnNbMF07XG4gICAgICAgIHRyYWNlU3RvcmVJZCA9IHRva2Vuc1sxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsdWdpbiA9IHlpZWxkIHJlZ2lzdHJ5LmluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgICBsZXQgcHJvdmlkZXIgPSBwbHVnaW4gPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbi50cmFjZVN0b3JlO1xuICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbmFibGUgdG8gcmVzb2x2ZSBwcm92aWRlZCBgdHJhY2VTdG9yZWAgZm9yIHBsdWdpbjogXCIgKyBwbHVnaW5OYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgIHByb3ZpZGVyID0gW3Byb3ZpZGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm92aWRlci5sZW5ndGggPT09IDEgJiYgIXRyYWNlU3RvcmVJZCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJbMF0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvdmlkZXIubGVuZ3RoID4gMSAmJiAhdHJhY2VTdG9yZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGx1Z2luICR7cGx1Z2luTmFtZX0gcHJvdmlkZXMgbW9yZSB0aGFuIG9uZSB0cmFjZSBzdG9yZSBpbXBsZW1lbnRhdGlvbiAoJHtwcm92aWRlci5tYXAoKHAyKSA9PiBwMi5pZCkuam9pbihcIiwgXCIpfSksIHBsZWFzZSBzcGVjaWZ5IHRoZSB0cmFjZSBzdG9yZSBpZCAoZS5nLiBcIiR7cGx1Z2luTmFtZX0vJHtwcm92aWRlclswXS5pZH1cIilgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gcHJvdmlkZXIuZmluZCgocDIpID0+IHAyLmlkID09PSB0cmFjZVN0b3JlSWQpO1xuICAgICAgaWYgKCFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGx1Z2luICR7cGx1Z2luTmFtZX0gZG9lcyBub3QgcHJvdmlkZSB0cmFjZSBzdG9yZSAke3RyYWNlU3RvcmVJZH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHRlbGVtZXRyeSBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQgcGx1Z2luLlxuICAgKi9cbiAgcmVzb2x2ZVRlbGVtZXRyeUNvbmZpZyhwbHVnaW5OYW1lKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHlpZWxkIHJlZ2lzdHJ5LmluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IChfYSA9IHBsdWdpbiA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluc3RydW1lbnRhdGlvbjtcbiAgICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5hYmxlIHRvIHJlc29sdmUgcHJvdmlkZXIgYHRlbGVtZXRyeS5pbnN0cnVtZW50YXRpb25gIGZvciBwbHVnaW46IFwiICsgcGx1Z2luTmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3ZpZGVyLnZhbHVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgbG9nZ2luZyBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQgcGx1Z2luLlxuICAgKi9cbiAgcmVzb2x2ZUxvZ2dlckNvbmZpZyhwbHVnaW5OYW1lKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHlpZWxkIHJlZ2lzdHJ5LmluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IChfYSA9IHBsdWdpbiA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxvZ2dlcjtcbiAgICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5hYmxlIHRvIHJlc29sdmUgcHJvdmlkZXIgYHRlbGVtZXRyeS5sb2dnZXJgIGZvciBwbHVnaW46IFwiICsgcGx1Z2luTmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3ZpZGVyLnZhbHVlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb25maWd1cmVHZW5raXQob3B0aW9ucykge1xuICBpZiAoY29uZmlnKSB7XG4gICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLndhcm4oXCJjb25maWd1cmVHZW5raXQgd2FzIGFscmVhZHkgY2FsbGVkXCIpO1xuICB9XG4gIGNvbmZpZyA9IG5ldyBDb25maWcob3B0aW9ucyk7XG4gIGNvbmZpZy5zZXR1cFRyYWNpbmdBbmRMb2dnaW5nKCk7XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplR2Vua2l0KGNmZykge1xuICBpZiAoY29uZmlnIHx8IGNmZykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25maWdQYXRoID0gZmluZEdlbmtpdENvbmZpZygpO1xuICBpZiAoIWNvbmZpZ1BhdGgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiVW5hYmxlIHRvIGZpbmQgZ2Vua2l0LmNvbmZpZy5qcyBpbiBhbnkgb2YgdGhlIHBhcmVudCBkaXJlY3Rvcmllcy5cIlxuICAgICk7XG4gIH1cbiAgcmVxdWlyZShjb25maWdQYXRoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRFbnYoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5HRU5LSVRfRU5WIHx8IFwicHJvZFwiO1xufVxuZnVuY3Rpb24gaXNEZXZFbnYoKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RW52KCkgPT09IFwiZGV2XCI7XG59XG5mdW5jdGlvbiBmaW5kR2Vua2l0Q29uZmlnKCkge1xuICB2YXIgX2E7XG4gIGxldCBjdXJyZW50ID0gKF9hID0gcmVxdWlyZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWlyZS5tYWluKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlsZW5hbWU7XG4gIGlmICghY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIHBhY2thZ2Ugcm9vdC5cIik7XG4gIH1cbiAgd2hpbGUgKGltcG9ydF9wYXRoLmRlZmF1bHQucmVzb2x2ZShjdXJyZW50LCBcIi4uXCIpICE9PSBjdXJyZW50KSB7XG4gICAgaWYgKGltcG9ydF9mcy5kZWZhdWx0LmV4aXN0c1N5bmMoaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKGN1cnJlbnQsIFwiZ2Vua2l0LmNvbmZpZy5qc1wiKSkpIHtcbiAgICAgIHJldHVybiBpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUoY3VycmVudCwgXCJnZW5raXQuY29uZmlnLmpzXCIpO1xuICAgIH1cbiAgICBjdXJyZW50ID0gaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKGN1cnJlbnQsIFwiLi5cIik7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIF9faGFyZFJlc2V0Q29uZmlnRm9yVGVzdGluZygpIHtcbiAgY29uZmlnID0gdm9pZCAwO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIF9faGFyZFJlc2V0Q29uZmlnRm9yVGVzdGluZyxcbiAgY29uZmlnLFxuICBjb25maWd1cmVHZW5raXQsXG4gIGdldEN1cnJlbnRFbnYsXG4gIGluaXRpYWxpemVHZW5raXQsXG4gIGlzRGV2RW52LFxuICAuLi5yZXF1aXJlKFwiLi9wbHVnaW4uanNcIilcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/config.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/error.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/error.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar error_exports = {};\n__export(error_exports, {\n  GenkitError: () => GenkitError\n});\nmodule.exports = __toCommonJS(error_exports);\nclass GenkitError extends Error {\n  constructor({\n    status,\n    message,\n    detail,\n    source\n  }) {\n    super(`${source ? `${source}: ` : \"\"}${status}: ${message}`);\n    this.status = status;\n    this.detail = detail;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsWUFBWSxPQUFPLFNBQVMsRUFBRSxPQUFPLElBQUksUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi9lcnJvci5qcz9kYzkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBlcnJvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChlcnJvcl9leHBvcnRzLCB7XG4gIEdlbmtpdEVycm9yOiAoKSA9PiBHZW5raXRFcnJvclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhlcnJvcl9leHBvcnRzKTtcbmNsYXNzIEdlbmtpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RhdHVzLFxuICAgIG1lc3NhZ2UsXG4gICAgZGV0YWlsLFxuICAgIHNvdXJjZVxuICB9KSB7XG4gICAgc3VwZXIoYCR7c291cmNlID8gYCR7c291cmNlfTogYCA6IFwiXCJ9JHtzdGF0dXN9OiAke21lc3NhZ2V9YCk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWwgPSBkZXRhaWw7XG4gIH1cbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBHZW5raXRFcnJvclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/flowTypes.js":
/*!*******************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/flowTypes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar flowTypes_exports = {};\n__export(flowTypes_exports, {\n  FlowErrorSchema: () => FlowErrorSchema,\n  FlowResponseSchema: () => FlowResponseSchema,\n  FlowResultSchema: () => FlowResultSchema,\n  FlowStateExecutionSchema: () => FlowStateExecutionSchema,\n  FlowStateSchema: () => FlowStateSchema,\n  OperationSchema: () => OperationSchema\n});\nmodule.exports = __toCommonJS(flowTypes_exports);\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nconst FlowStateExecutionSchema = import_zod.z.object({\n  startTime: import_zod.z.number().optional().describe(\"start time in milliseconds since the epoch\"),\n  endTime: import_zod.z.number().optional().describe(\"end time in milliseconds since the epoch\"),\n  traceIds: import_zod.z.array(import_zod.z.string())\n});\nconst FlowResponseSchema = import_zod.z.object({\n  response: import_zod.z.unknown().nullable()\n});\nconst FlowErrorSchema = import_zod.z.object({\n  error: import_zod.z.string().optional(),\n  stacktrace: import_zod.z.string().optional()\n});\nconst FlowResultSchema = FlowResponseSchema.and(FlowErrorSchema);\nconst OperationSchema = import_zod.z.object({\n  name: import_zod.z.string().describe(\n    \"server-assigned name, which is only unique within the same service that originally returns it.\"\n  ),\n  metadata: import_zod.z.any().optional().describe(\n    \"Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time.\"\n  ),\n  done: import_zod.z.boolean().optional().default(false).describe(\n    \"If the value is false, it means the operation is still in progress. If true, the operation is completed, and either error or response is available.\"\n  ),\n  result: FlowResultSchema.optional(),\n  blockedOnStep: import_zod.z.object({\n    name: import_zod.z.string(),\n    schema: import_zod.z.string().optional()\n  }).optional()\n});\nconst FlowStateSchema = import_zod.z.object({\n  name: import_zod.z.string().optional(),\n  flowId: import_zod.z.string(),\n  input: import_zod.z.unknown(),\n  startTime: import_zod.z.number().describe(\"start time in milliseconds since the epoch\"),\n  cache: import_zod.z.record(\n    import_zod.z.string(),\n    import_zod.z.object({\n      value: import_zod.z.any().optional(),\n      empty: import_zod.z.literal(true).optional()\n    })\n  ),\n  eventsTriggered: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),\n  blockedOnStep: import_zod.z.object({\n    name: import_zod.z.string(),\n    schema: import_zod.z.string().optional()\n  }).nullable(),\n  operation: OperationSchema,\n  traceContext: import_zod.z.string().optional(),\n  executions: import_zod.z.array(FlowStateExecutionSchema)\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=flowTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2Zsb3dUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwREFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsTUFBTSxDQU9MO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi9mbG93VHlwZXMuanM/YzkyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgZmxvd1R5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZsb3dUeXBlc19leHBvcnRzLCB7XG4gIEZsb3dFcnJvclNjaGVtYTogKCkgPT4gRmxvd0Vycm9yU2NoZW1hLFxuICBGbG93UmVzcG9uc2VTY2hlbWE6ICgpID0+IEZsb3dSZXNwb25zZVNjaGVtYSxcbiAgRmxvd1Jlc3VsdFNjaGVtYTogKCkgPT4gRmxvd1Jlc3VsdFNjaGVtYSxcbiAgRmxvd1N0YXRlRXhlY3V0aW9uU2NoZW1hOiAoKSA9PiBGbG93U3RhdGVFeGVjdXRpb25TY2hlbWEsXG4gIEZsb3dTdGF0ZVNjaGVtYTogKCkgPT4gRmxvd1N0YXRlU2NoZW1hLFxuICBPcGVyYXRpb25TY2hlbWE6ICgpID0+IE9wZXJhdGlvblNjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhmbG93VHlwZXNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBGbG93U3RhdGVFeGVjdXRpb25TY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgc3RhcnRUaW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcInN0YXJ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFwiKSxcbiAgZW5kVGltZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJlbmQgdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXCIpLFxuICB0cmFjZUlkczogaW1wb3J0X3pvZC56LmFycmF5KGltcG9ydF96b2Quei5zdHJpbmcoKSlcbn0pO1xuY29uc3QgRmxvd1Jlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHJlc3BvbnNlOiBpbXBvcnRfem9kLnoudW5rbm93bigpLm51bGxhYmxlKClcbn0pO1xuY29uc3QgRmxvd0Vycm9yU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGVycm9yOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc3RhY2t0cmFjZTogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgRmxvd1Jlc3VsdFNjaGVtYSA9IEZsb3dSZXNwb25zZVNjaGVtYS5hbmQoRmxvd0Vycm9yU2NoZW1hKTtcbmNvbnN0IE9wZXJhdGlvblNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBuYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCkuZGVzY3JpYmUoXG4gICAgXCJzZXJ2ZXItYXNzaWduZWQgbmFtZSwgd2hpY2ggaXMgb25seSB1bmlxdWUgd2l0aGluIHRoZSBzYW1lIHNlcnZpY2UgdGhhdCBvcmlnaW5hbGx5IHJldHVybnMgaXQuXCJcbiAgKSxcbiAgbWV0YWRhdGE6IGltcG9ydF96b2Quei5hbnkoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiU2VydmljZS1zcGVjaWZpYyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wZXJhdGlvbi4gSXQgdHlwaWNhbGx5IGNvbnRhaW5zIHByb2dyZXNzIGluZm9ybWF0aW9uIGFuZCBjb21tb24gbWV0YWRhdGEgc3VjaCBhcyBjcmVhdGUgdGltZS5cIlxuICApLFxuICBkb25lOiBpbXBvcnRfem9kLnouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSkuZGVzY3JpYmUoXG4gICAgXCJJZiB0aGUgdmFsdWUgaXMgZmFsc2UsIGl0IG1lYW5zIHRoZSBvcGVyYXRpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuIElmIHRydWUsIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGVkLCBhbmQgZWl0aGVyIGVycm9yIG9yIHJlc3BvbnNlIGlzIGF2YWlsYWJsZS5cIlxuICApLFxuICByZXN1bHQ6IEZsb3dSZXN1bHRTY2hlbWEub3B0aW9uYWwoKSxcbiAgYmxvY2tlZE9uU3RlcDogaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gICAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICAgIHNjaGVtYTogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBGbG93U3RhdGVTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGZsb3dJZDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBpbnB1dDogaW1wb3J0X3pvZC56LnVua25vd24oKSxcbiAgc3RhcnRUaW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCkuZGVzY3JpYmUoXCJzdGFydCB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcIiksXG4gIGNhY2hlOiBpbXBvcnRfem9kLnoucmVjb3JkKFxuICAgIGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgICBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgICAgIHZhbHVlOiBpbXBvcnRfem9kLnouYW55KCkub3B0aW9uYWwoKSxcbiAgICAgIGVtcHR5OiBpbXBvcnRfem9kLnoubGl0ZXJhbCh0cnVlKS5vcHRpb25hbCgpXG4gICAgfSlcbiAgKSxcbiAgZXZlbnRzVHJpZ2dlcmVkOiBpbXBvcnRfem9kLnoucmVjb3JkKGltcG9ydF96b2Quei5zdHJpbmcoKSwgaW1wb3J0X3pvZC56LmFueSgpKSxcbiAgYmxvY2tlZE9uU3RlcDogaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gICAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICAgIHNjaGVtYTogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSkubnVsbGFibGUoKSxcbiAgb3BlcmF0aW9uOiBPcGVyYXRpb25TY2hlbWEsXG4gIHRyYWNlQ29udGV4dDogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4ZWN1dGlvbnM6IGltcG9ydF96b2Quei5hcnJheShGbG93U3RhdGVFeGVjdXRpb25TY2hlbWEpXG59KTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBGbG93RXJyb3JTY2hlbWEsXG4gIEZsb3dSZXNwb25zZVNjaGVtYSxcbiAgRmxvd1Jlc3VsdFNjaGVtYSxcbiAgRmxvd1N0YXRlRXhlY3V0aW9uU2NoZW1hLFxuICBGbG93U3RhdGVTY2hlbWEsXG4gIE9wZXJhdGlvblNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbG93VHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/flowTypes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar src_exports = {};\n__export(src_exports, {\n  GENKIT_CLIENT_HEADER: () => GENKIT_CLIENT_HEADER,\n  GENKIT_VERSION: () => GENKIT_VERSION,\n  GenkitError: () => import_error.GenkitError,\n  defineJsonSchema: () => import_schema.defineJsonSchema,\n  defineSchema: () => import_schema.defineSchema\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_version = __webpack_require__(/*! ./__codegen/version.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js\");\n__reExport(src_exports, __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\"), module.exports);\n__reExport(src_exports, __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/config.js\"), module.exports);\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\n__reExport(src_exports, __webpack_require__(/*! ./flowTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/flowTypes.js\"), module.exports);\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\n__reExport(src_exports, __webpack_require__(/*! ./telemetryTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js\"), module.exports);\nconst GENKIT_VERSION = import_version.version;\nconst GENKIT_CLIENT_HEADER = `genkit-node/${GENKIT_VERSION} gl-node/${process.versions.node}`;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUF3QjtBQUNyRCx3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3JEO0FBQ0EsNENBQTRDLGdCQUFnQixVQUFVLHNCQUFzQjtBQUM1RjtBQUNBLE1BQU0sQ0FVTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvaW5kZXguanM/Nzc4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBHRU5LSVRfQ0xJRU5UX0hFQURFUjogKCkgPT4gR0VOS0lUX0NMSUVOVF9IRUFERVIsXG4gIEdFTktJVF9WRVJTSU9OOiAoKSA9PiBHRU5LSVRfVkVSU0lPTixcbiAgR2Vua2l0RXJyb3I6ICgpID0+IGltcG9ydF9lcnJvci5HZW5raXRFcnJvcixcbiAgZGVmaW5lSnNvblNjaGVtYTogKCkgPT4gaW1wb3J0X3NjaGVtYS5kZWZpbmVKc29uU2NoZW1hLFxuICBkZWZpbmVTY2hlbWE6ICgpID0+IGltcG9ydF9zY2hlbWEuZGVmaW5lU2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcbnZhciBpbXBvcnRfdmVyc2lvbiA9IHJlcXVpcmUoXCIuL19fY29kZWdlbi92ZXJzaW9uLmpzXCIpO1xuX19yZUV4cG9ydChzcmNfZXhwb3J0cywgcmVxdWlyZShcIi4vYWN0aW9uLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG5fX3JlRXhwb3J0KHNyY19leHBvcnRzLCByZXF1aXJlKFwiLi9jb25maWcuanNcIiksIG1vZHVsZS5leHBvcnRzKTtcbnZhciBpbXBvcnRfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvci5qc1wiKTtcbl9fcmVFeHBvcnQoc3JjX2V4cG9ydHMsIHJlcXVpcmUoXCIuL2Zsb3dUeXBlcy5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xudmFyIGltcG9ydF9zY2hlbWEgPSByZXF1aXJlKFwiLi9zY2hlbWEuanNcIik7XG5fX3JlRXhwb3J0KHNyY19leHBvcnRzLCByZXF1aXJlKFwiLi90ZWxlbWV0cnlUeXBlcy5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuY29uc3QgR0VOS0lUX1ZFUlNJT04gPSBpbXBvcnRfdmVyc2lvbi52ZXJzaW9uO1xuY29uc3QgR0VOS0lUX0NMSUVOVF9IRUFERVIgPSBgZ2Vua2l0LW5vZGUvJHtHRU5LSVRfVkVSU0lPTn0gZ2wtbm9kZS8ke3Byb2Nlc3MudmVyc2lvbnMubm9kZX1gO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdFTktJVF9DTElFTlRfSEVBREVSLFxuICBHRU5LSVRfVkVSU0lPTixcbiAgR2Vua2l0RXJyb3IsXG4gIGRlZmluZUpzb25TY2hlbWEsXG4gIGRlZmluZVNjaGVtYSxcbiAgLi4ucmVxdWlyZShcIi4vYWN0aW9uLmpzXCIpLFxuICAuLi5yZXF1aXJlKFwiLi9jb25maWcuanNcIiksXG4gIC4uLnJlcXVpcmUoXCIuL2Zsb3dUeXBlcy5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vdGVsZW1ldHJ5VHlwZXMuanNcIilcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/localFileFlowStateStore.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/localFileFlowStateStore.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar localFileFlowStateStore_exports = {};\n__export(localFileFlowStateStore_exports, {\n  LocalFileFlowStateStore: () => LocalFileFlowStateStore\n});\nmodule.exports = __toCommonJS(localFileFlowStateStore_exports);\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_fs = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_os = __toESM(__webpack_require__(/*! os */ \"os\"));\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_flowTypes = __webpack_require__(/*! ./flowTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/flowTypes.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nclass LocalFileFlowStateStore {\n  constructor() {\n    var _a;\n    const rootHash = import_crypto.default.createHash(\"md5\").update(((_a = __webpack_require__(\"(action-browser)/./node_modules/@genkit-ai/core/lib sync recursive\") == null ? void 0 : __webpack_require__.c[__webpack_require__.s]) == null ? void 0 : _a.filename) || \"unknown\").digest(\"hex\");\n    this.storeRoot = import_path.default.resolve(import_os.default.tmpdir(), `.genkit/${rootHash}/flows`);\n    import_fs.default.mkdirSync(this.storeRoot, { recursive: true });\n    import_logging.logger.info(\"Using DevFlowStateStore. Root: \" + this.storeRoot);\n  }\n  load(id) {\n    return __async(this, null, function* () {\n      const filePath = import_path.default.resolve(this.storeRoot, `${id}`);\n      if (!import_fs.default.existsSync(filePath)) {\n        return void 0;\n      }\n      const data = import_fs.default.readFileSync(filePath, \"utf8\");\n      return import_flowTypes.FlowStateSchema.parse(JSON.parse(data));\n    });\n  }\n  save(id, state) {\n    return __async(this, null, function* () {\n      import_logging.logger.debug(\"save flow state \" + id);\n      import_fs.default.writeFileSync(\n        import_path.default.resolve(this.storeRoot, `${id}`),\n        JSON.stringify(state)\n      );\n    });\n  }\n  list(query) {\n    return __async(this, null, function* () {\n      const files = import_fs.default.readdirSync(this.storeRoot);\n      files.sort((a, b) => {\n        return import_fs.default.statSync(import_path.default.resolve(this.storeRoot, `${b}`)).mtime.getTime() - import_fs.default.statSync(import_path.default.resolve(this.storeRoot, `${a}`)).mtime.getTime();\n      });\n      const startFrom = (query == null ? void 0 : query.continuationToken) ? parseInt(query == null ? void 0 : query.continuationToken) : 0;\n      const stopAt = startFrom + ((query == null ? void 0 : query.limit) || 10);\n      const flowStates = files.slice(startFrom, stopAt).map((id) => {\n        const filePath = import_path.default.resolve(this.storeRoot, `${id}`);\n        const data = import_fs.default.readFileSync(filePath, \"utf8\");\n        return import_flowTypes.FlowStateSchema.parse(JSON.parse(data));\n      });\n      return {\n        flowStates,\n        continuationToken: files.length > stopAt ? stopAt.toString() : void 0\n      };\n    });\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=localFileFlowStateStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2xvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDLHdCQUF3QixtQkFBTyxDQUFDLGNBQUk7QUFDcEMsMEJBQTBCLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx5RkFBTyxvQkFBb0IsNENBQVk7QUFDbEgsd0ZBQXdGLFNBQVM7QUFDakcsa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxHQUFHO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixFQUFFLGdHQUFnRyxFQUFFO0FBQzdMLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRztBQUMzRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvbG9jYWxGaWxlRmxvd1N0YXRlU3RvcmUuanM/NzQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGxvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlX2V4cG9ydHMsIHtcbiAgTG9jYWxGaWxlRmxvd1N0YXRlU3RvcmU6ICgpID0+IExvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGxvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9jcnlwdG8gPSBfX3RvRVNNKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xudmFyIGltcG9ydF9mcyA9IF9fdG9FU00ocmVxdWlyZShcImZzXCIpKTtcbnZhciBpbXBvcnRfb3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJvc1wiKSk7XG52YXIgaW1wb3J0X3BhdGggPSBfX3RvRVNNKHJlcXVpcmUoXCJwYXRoXCIpKTtcbnZhciBpbXBvcnRfZmxvd1R5cGVzID0gcmVxdWlyZShcIi4vZmxvd1R5cGVzLmpzXCIpO1xudmFyIGltcG9ydF9sb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZy5qc1wiKTtcbmNsYXNzIExvY2FsRmlsZUZsb3dTdGF0ZVN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJvb3RIYXNoID0gaW1wb3J0X2NyeXB0by5kZWZhdWx0LmNyZWF0ZUhhc2goXCJtZDVcIikudXBkYXRlKCgoX2EgPSByZXF1aXJlID09IG51bGwgPyB2b2lkIDAgOiByZXF1aXJlLm1haW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5maWxlbmFtZSkgfHwgXCJ1bmtub3duXCIpLmRpZ2VzdChcImhleFwiKTtcbiAgICB0aGlzLnN0b3JlUm9vdCA9IGltcG9ydF9wYXRoLmRlZmF1bHQucmVzb2x2ZShpbXBvcnRfb3MuZGVmYXVsdC50bXBkaXIoKSwgYC5nZW5raXQvJHtyb290SGFzaH0vZmxvd3NgKTtcbiAgICBpbXBvcnRfZnMuZGVmYXVsdC5ta2RpclN5bmModGhpcy5zdG9yZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5pbmZvKFwiVXNpbmcgRGV2Rmxvd1N0YXRlU3RvcmUuIFJvb3Q6IFwiICsgdGhpcy5zdG9yZVJvb3QpO1xuICB9XG4gIGxvYWQoaWQpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5zdG9yZVJvb3QsIGAke2lkfWApO1xuICAgICAgaWYgKCFpbXBvcnRfZnMuZGVmYXVsdC5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGltcG9ydF9mcy5kZWZhdWx0LnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGY4XCIpO1xuICAgICAgcmV0dXJuIGltcG9ydF9mbG93VHlwZXMuRmxvd1N0YXRlU2NoZW1hLnBhcnNlKEpTT04ucGFyc2UoZGF0YSkpO1xuICAgIH0pO1xuICB9XG4gIHNhdmUoaWQsIHN0YXRlKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcInNhdmUgZmxvdyBzdGF0ZSBcIiArIGlkKTtcbiAgICAgIGltcG9ydF9mcy5kZWZhdWx0LndyaXRlRmlsZVN5bmMoXG4gICAgICAgIGltcG9ydF9wYXRoLmRlZmF1bHQucmVzb2x2ZSh0aGlzLnN0b3JlUm9vdCwgYCR7aWR9YCksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHN0YXRlKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBsaXN0KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gaW1wb3J0X2ZzLmRlZmF1bHQucmVhZGRpclN5bmModGhpcy5zdG9yZVJvb3QpO1xuICAgICAgZmlsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gaW1wb3J0X2ZzLmRlZmF1bHQuc3RhdFN5bmMoaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKHRoaXMuc3RvcmVSb290LCBgJHtifWApKS5tdGltZS5nZXRUaW1lKCkgLSBpbXBvcnRfZnMuZGVmYXVsdC5zdGF0U3luYyhpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5zdG9yZVJvb3QsIGAke2F9YCkpLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhcnRGcm9tID0gKHF1ZXJ5ID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeS5jb250aW51YXRpb25Ub2tlbikgPyBwYXJzZUludChxdWVyeSA9PSBudWxsID8gdm9pZCAwIDogcXVlcnkuY29udGludWF0aW9uVG9rZW4pIDogMDtcbiAgICAgIGNvbnN0IHN0b3BBdCA9IHN0YXJ0RnJvbSArICgocXVlcnkgPT0gbnVsbCA/IHZvaWQgMCA6IHF1ZXJ5LmxpbWl0KSB8fCAxMCk7XG4gICAgICBjb25zdCBmbG93U3RhdGVzID0gZmlsZXMuc2xpY2Uoc3RhcnRGcm9tLCBzdG9wQXQpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5zdG9yZVJvb3QsIGAke2lkfWApO1xuICAgICAgICBjb25zdCBkYXRhID0gaW1wb3J0X2ZzLmRlZmF1bHQucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBcInV0ZjhcIik7XG4gICAgICAgIHJldHVybiBpbXBvcnRfZmxvd1R5cGVzLkZsb3dTdGF0ZVNjaGVtYS5wYXJzZShKU09OLnBhcnNlKGRhdGEpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmxvd1N0YXRlcyxcbiAgICAgICAgY29udGludWF0aW9uVG9rZW46IGZpbGVzLmxlbmd0aCA+IHN0b3BBdCA/IHN0b3BBdC50b1N0cmluZygpIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTG9jYWxGaWxlRmxvd1N0YXRlU3RvcmVcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxGaWxlRmxvd1N0YXRlU3RvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/localFileFlowStateStore.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/logging.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar logging_exports = {};\n__export(logging_exports, {\n  logger: () => logger\n});\nmodule.exports = __toCommonJS(logging_exports);\nconst LOG_LEVELS = [\"debug\", \"info\", \"warn\", \"error\"];\nclass Logger {\n  constructor() {\n    this.defaultLogger = {\n      shouldLog(targetLevel) {\n        return LOG_LEVELS.indexOf(this.level) <= LOG_LEVELS.indexOf(targetLevel);\n      },\n      debug(...args) {\n        this.shouldLog(\"debug\") && console.debug(...args);\n      },\n      info(...args) {\n        this.shouldLog(\"info\") && console.info(...args);\n      },\n      warn(...args) {\n        this.shouldLog(\"warn\") && console.warn(...args);\n      },\n      error(...args) {\n        this.shouldLog(\"error\") && console.error(...args);\n      },\n      level: \"info\"\n    };\n    this.logger = this.defaultLogger;\n  }\n  init(config) {\n    return __async(this, null, function* () {\n      this.logger = yield config.getLogger(process.env.GENKIT_ENV || \"prod\");\n    });\n  }\n  info(...args) {\n    this.logger.info.apply(this.logger, args);\n  }\n  debug(...args) {\n    this.logger.debug.apply(this.logger, args);\n  }\n  error(...args) {\n    this.logger.error.apply(this.logger, args);\n  }\n  warn(...args) {\n    this.logger.warn.apply(this.logger, args);\n  }\n  setLogLevel(level) {\n    this.logger.level = level;\n  }\n  logStructured(msg, metadata) {\n    this.logger.info(msg, metadata);\n  }\n  logStructuredError(msg, metadata) {\n    this.logger.error(msg, metadata);\n  }\n}\nconst logger = new Logger();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2xvZ2dpbmcuanM/NDMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGxvZ2dpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobG9nZ2luZ19leHBvcnRzLCB7XG4gIGxvZ2dlcjogKCkgPT4gbG9nZ2VyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGxvZ2dpbmdfZXhwb3J0cyk7XG5jb25zdCBMT0dfTEVWRUxTID0gW1wiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZWZhdWx0TG9nZ2VyID0ge1xuICAgICAgc2hvdWxkTG9nKHRhcmdldExldmVsKSB7XG4gICAgICAgIHJldHVybiBMT0dfTEVWRUxTLmluZGV4T2YodGhpcy5sZXZlbCkgPD0gTE9HX0xFVkVMUy5pbmRleE9mKHRhcmdldExldmVsKTtcbiAgICAgIH0sXG4gICAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkTG9nKFwiZGVidWdcIikgJiYgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaG91bGRMb2coXCJpbmZvXCIpICYmIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaG91bGRMb2coXCJ3YXJuXCIpICYmIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkTG9nKFwiZXJyb3JcIikgJiYgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBsZXZlbDogXCJpbmZvXCJcbiAgICB9O1xuICAgIHRoaXMubG9nZ2VyID0gdGhpcy5kZWZhdWx0TG9nZ2VyO1xuICB9XG4gIGluaXQoY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nZ2VyID0geWllbGQgY29uZmlnLmdldExvZ2dlcihwcm9jZXNzLmVudi5HRU5LSVRfRU5WIHx8IFwicHJvZFwiKTtcbiAgICB9KTtcbiAgfVxuICBpbmZvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvLmFwcGx5KHRoaXMubG9nZ2VyLCBhcmdzKTtcbiAgfVxuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcuYXBwbHkodGhpcy5sb2dnZXIsIGFyZ3MpO1xuICB9XG4gIGVycm9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvci5hcHBseSh0aGlzLmxvZ2dlciwgYXJncyk7XG4gIH1cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgdGhpcy5sb2dnZXIud2Fybi5hcHBseSh0aGlzLmxvZ2dlciwgYXJncyk7XG4gIH1cbiAgc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sZXZlbCA9IGxldmVsO1xuICB9XG4gIGxvZ1N0cnVjdHVyZWQobXNnLCBtZXRhZGF0YSkge1xuICAgIHRoaXMubG9nZ2VyLmluZm8obXNnLCBtZXRhZGF0YSk7XG4gIH1cbiAgbG9nU3RydWN0dXJlZEVycm9yKG1zZywgbWV0YWRhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcihtc2csIG1ldGFkYXRhKTtcbiAgfVxufVxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZ2dlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/plugin.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar plugin_exports = {};\n__export(plugin_exports, {\n  genkitPlugin: () => genkitPlugin\n});\nmodule.exports = __toCommonJS(plugin_exports);\nfunction genkitPlugin(pluginName, initFn) {\n  return (...args) => ({\n    name: pluginName,\n    initializer: () => __async(this, null, function* () {\n      const initializedPlugin = (yield initFn(...args)) || {};\n      validatePluginActions(pluginName, initializedPlugin);\n      return initializedPlugin;\n    })\n  });\n}\nfunction validatePluginActions(pluginName, plugin) {\n  var _a, _b, _c, _d, _e;\n  if (!plugin) {\n    return;\n  }\n  (_a = plugin.models) == null ? void 0 : _a.forEach((model) => validateNaming(pluginName, model));\n  (_b = plugin.retrievers) == null ? void 0 : _b.forEach(\n    (retriever) => validateNaming(pluginName, retriever)\n  );\n  (_c = plugin.embedders) == null ? void 0 : _c.forEach((embedder) => validateNaming(pluginName, embedder));\n  (_d = plugin.indexers) == null ? void 0 : _d.forEach((indexer) => validateNaming(pluginName, indexer));\n  (_e = plugin.evaluators) == null ? void 0 : _e.forEach(\n    (evaluator) => validateNaming(pluginName, evaluator)\n  );\n}\nfunction validateNaming(pluginName, action) {\n  const nameParts = action.__action.name.split(\"/\");\n  if (nameParts[0] !== pluginName) {\n    const err = `Plugin name ${pluginName} not found in action name ${action.__action.name}. Action names must follow the pattern {pluginName}/{actionName}`;\n    throw new Error(err);\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=plugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSwyQkFBMkIscUJBQXFCLHdDQUF3QyxXQUFXLEVBQUUsV0FBVztBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvcGx1Z2luLmpzP2QwZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBwbHVnaW5fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocGx1Z2luX2V4cG9ydHMsIHtcbiAgZ2Vua2l0UGx1Z2luOiAoKSA9PiBnZW5raXRQbHVnaW5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocGx1Z2luX2V4cG9ydHMpO1xuZnVuY3Rpb24gZ2Vua2l0UGx1Z2luKHBsdWdpbk5hbWUsIGluaXRGbikge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+ICh7XG4gICAgbmFtZTogcGx1Z2luTmFtZSxcbiAgICBpbml0aWFsaXplcjogKCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZWRQbHVnaW4gPSAoeWllbGQgaW5pdEZuKC4uLmFyZ3MpKSB8fCB7fTtcbiAgICAgIHZhbGlkYXRlUGx1Z2luQWN0aW9ucyhwbHVnaW5OYW1lLCBpbml0aWFsaXplZFBsdWdpbik7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRQbHVnaW47XG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBsdWdpbkFjdGlvbnMocGx1Z2luTmFtZSwgcGx1Z2luKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGlmICghcGx1Z2luKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIChfYSA9IHBsdWdpbi5tb2RlbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChtb2RlbCkgPT4gdmFsaWRhdGVOYW1pbmcocGx1Z2luTmFtZSwgbW9kZWwpKTtcbiAgKF9iID0gcGx1Z2luLnJldHJpZXZlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKFxuICAgIChyZXRyaWV2ZXIpID0+IHZhbGlkYXRlTmFtaW5nKHBsdWdpbk5hbWUsIHJldHJpZXZlcilcbiAgKTtcbiAgKF9jID0gcGx1Z2luLmVtYmVkZGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmZvckVhY2goKGVtYmVkZGVyKSA9PiB2YWxpZGF0ZU5hbWluZyhwbHVnaW5OYW1lLCBlbWJlZGRlcikpO1xuICAoX2QgPSBwbHVnaW4uaW5kZXhlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5mb3JFYWNoKChpbmRleGVyKSA9PiB2YWxpZGF0ZU5hbWluZyhwbHVnaW5OYW1lLCBpbmRleGVyKSk7XG4gIChfZSA9IHBsdWdpbi5ldmFsdWF0b3JzKSA9PSBudWxsID8gdm9pZCAwIDogX2UuZm9yRWFjaChcbiAgICAoZXZhbHVhdG9yKSA9PiB2YWxpZGF0ZU5hbWluZyhwbHVnaW5OYW1lLCBldmFsdWF0b3IpXG4gICk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWluZyhwbHVnaW5OYW1lLCBhY3Rpb24pIHtcbiAgY29uc3QgbmFtZVBhcnRzID0gYWN0aW9uLl9fYWN0aW9uLm5hbWUuc3BsaXQoXCIvXCIpO1xuICBpZiAobmFtZVBhcnRzWzBdICE9PSBwbHVnaW5OYW1lKSB7XG4gICAgY29uc3QgZXJyID0gYFBsdWdpbiBuYW1lICR7cGx1Z2luTmFtZX0gbm90IGZvdW5kIGluIGFjdGlvbiBuYW1lICR7YWN0aW9uLl9fYWN0aW9uLm5hbWV9LiBBY3Rpb24gbmFtZXMgbXVzdCBmb2xsb3cgdGhlIHBhdHRlcm4ge3BsdWdpbk5hbWV9L3thY3Rpb25OYW1lfWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gIH1cbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW5raXRQbHVnaW5cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/plugin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/reflectionApi.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/reflectionApi.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar reflectionApi_exports = {};\n__export(reflectionApi_exports, {\n  RunActionResponseSchema: () => RunActionResponseSchema,\n  startReflectionApi: () => startReflectionApi\n});\nmodule.exports = __toCommonJS(reflectionApi_exports);\nvar import_express = __toESM(__webpack_require__(/*! express */ \"express\"));\nvar import_zod = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nvar import_action = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\nvar import_config = __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/config.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar registry = __toESM(__webpack_require__(/*! ./registry.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\"));\nvar import_schema = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\nvar import_tracing = __webpack_require__(/*! ./tracing.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\");\nconst RunActionResponseSchema = import_zod.default.object({\n  result: import_zod.default.unknown().optional(),\n  error: import_zod.default.unknown().optional(),\n  telemetry: import_zod.default.object({\n    traceId: import_zod.default.string().optional()\n  }).optional()\n});\nlet server;\nconst GLOBAL_REFLECTION_API_PORT_KEY = \"genkit__reflectionApiPort\";\nfunction startReflectionApi(port) {\n  return __async(this, null, function* () {\n    if (global[GLOBAL_REFLECTION_API_PORT_KEY] !== void 0) {\n      import_logging.logger.warn(\n        `Reflection API is already running on port ${global[GLOBAL_REFLECTION_API_PORT_KEY]}`\n      );\n      return;\n    }\n    if (!port) {\n      port = Number(process.env.GENKIT_REFLECTION_PORT) || 3100;\n    }\n    global[GLOBAL_REFLECTION_API_PORT_KEY] = port;\n    const api = (0, import_express.default)();\n    api.use(import_express.default.json({ limit: \"30mb\" }));\n    api.get(\"/api/__health\", (_, response) => __async(this, null, function* () {\n      yield registry.listActions();\n      response.status(200).send(\"OK\");\n    }));\n    api.get(\"/api/__quitquitquit\", (_, response) => __async(this, null, function* () {\n      import_logging.logger.debug(\"Received quitquitquit\");\n      response.status(200).send(\"OK\");\n      yield stopReflectionApi();\n    }));\n    api.get(\"/api/actions\", (_, response, next) => __async(this, null, function* () {\n      import_logging.logger.debug(\"Fetching actions.\");\n      const actions = yield registry.listActions();\n      const convertedActions = {};\n      Object.keys(actions).forEach((key) => {\n        const action = actions[key].__action;\n        convertedActions[key] = {\n          key,\n          name: action.name,\n          description: action.description,\n          metadata: action.metadata\n        };\n        if (action.inputSchema || action.inputJsonSchema) {\n          convertedActions[key].inputSchema = (0, import_schema.toJsonSchema)({\n            schema: action.inputSchema,\n            jsonSchema: action.inputJsonSchema\n          });\n        }\n        if (action.outputSchema || action.outputJsonSchema) {\n          convertedActions[key].outputSchema = (0, import_schema.toJsonSchema)({\n            schema: action.outputSchema,\n            jsonSchema: action.outputJsonSchema\n          });\n        }\n      });\n      try {\n        response.send(convertedActions);\n      } catch (err) {\n        const { message, stack } = err;\n        next({ message, stack });\n      }\n    }));\n    api.post(\"/api/runAction\", (request, response, next) => __async(this, null, function* () {\n      const { key, input } = request.body;\n      const { stream } = request.query;\n      import_logging.logger.debug(`Running action \\`${key}\\`...`);\n      let traceId;\n      try {\n        const action = yield registry.lookupAction(key);\n        if (!action) {\n          response.status(404).send(`action ${key} not found`);\n          return;\n        }\n        if (stream === \"true\") {\n          const result = yield (0, import_tracing.newTrace)(\n            { name: \"dev-run-action-wrapper\" },\n            (_, span) => __async(this, null, function* () {\n              (0, import_tracing.setCustomMetadataAttribute)(\"genkit-dev-internal\", \"true\");\n              traceId = span.spanContext().traceId;\n              return yield (0, import_action.runWithStreamingCallback)(\n                (chunk) => {\n                  response.write(JSON.stringify(chunk) + \"\\n\");\n                },\n                () => __async(this, null, function* () {\n                  return yield action(input);\n                })\n              );\n            })\n          );\n          yield (0, import_tracing.flushTracing)();\n          response.write(\n            JSON.stringify({\n              result,\n              telemetry: traceId ? {\n                traceId\n              } : void 0\n            })\n          );\n          response.end();\n        } else {\n          const result = yield (0, import_tracing.newTrace)(\n            { name: \"dev-run-action-wrapper\" },\n            (_, span) => __async(this, null, function* () {\n              (0, import_tracing.setCustomMetadataAttribute)(\"genkit-dev-internal\", \"true\");\n              traceId = span.spanContext().traceId;\n              return yield action(input);\n            })\n          );\n          response.send({\n            result,\n            telemetry: traceId ? {\n              traceId\n            } : void 0\n          });\n        }\n      } catch (err) {\n        const { message, stack } = err;\n        next({ message, stack, traceId });\n      }\n    }));\n    api.get(\"/api/envs\", (_, response) => __async(this, null, function* () {\n      response.json(import_config.config.configuredEnvs);\n    }));\n    api.get(\"/api/envs/:env/traces/:traceId\", (request, response) => __async(this, null, function* () {\n      const { env, traceId } = request.params;\n      import_logging.logger.debug(`Fetching trace \\`${traceId}\\` for env \\`${env}\\`.`);\n      const tracestore = yield registry.lookupTraceStore(env);\n      if (!tracestore) {\n        return response.status(500).send({\n          code: import_action.StatusCodes.FAILED_PRECONDITION,\n          message: `${env} trace store not found`\n        });\n      }\n      try {\n        const trace = yield tracestore == null ? void 0 : tracestore.load(traceId);\n        return trace ? response.json(trace) : response.status(404).send({\n          code: import_action.StatusCodes.NOT_FOUND,\n          message: `Trace with traceId=${traceId} not found.`\n        });\n      } catch (err) {\n        const error = err;\n        const { message, stack } = error;\n        const errorResponse = {\n          code: import_action.StatusCodes.INTERNAL,\n          message,\n          details: {\n            stack\n          }\n        };\n        return response.status(500).json(errorResponse);\n      }\n    }));\n    api.get(\"/api/envs/:env/traces\", (request, response, next) => __async(this, null, function* () {\n      const { env } = request.params;\n      const { limit, continuationToken } = request.query;\n      import_logging.logger.debug(`Fetching traces for env \\`${env}\\`.`);\n      const tracestore = yield registry.lookupTraceStore(env);\n      if (!tracestore) {\n        return response.status(500).send({\n          code: import_action.StatusCodes.FAILED_PRECONDITION,\n          message: `${env} trace store not found`\n        });\n      }\n      try {\n        response.json(\n          yield tracestore.list({\n            limit: limit ? parseInt(limit.toString()) : void 0,\n            continuationToken: continuationToken ? continuationToken.toString() : void 0\n          })\n        );\n      } catch (err) {\n        const { message, stack } = err;\n        next({ message, stack });\n      }\n    }));\n    api.get(\n      \"/api/envs/:env/flowStates/:flowId\",\n      (request, response, next) => __async(this, null, function* () {\n        const { env, flowId } = request.params;\n        import_logging.logger.debug(`Fetching flow state \\`${flowId}\\` for env \\`${env}\\`.`);\n        const flowStateStore = yield registry.lookupFlowStateStore(env);\n        if (!flowStateStore) {\n          return response.status(500).send({\n            code: import_action.StatusCodes.FAILED_PRECONDITION,\n            message: `${env} flow state store not found`\n          });\n        }\n        try {\n          response.json(yield flowStateStore == null ? void 0 : flowStateStore.load(flowId));\n        } catch (err) {\n          const { message, stack } = err;\n          next({ message, stack });\n        }\n      })\n    );\n    api.get(\"/api/envs/:env/flowStates\", (request, response, next) => __async(this, null, function* () {\n      const { env } = request.params;\n      const { limit, continuationToken } = request.query;\n      import_logging.logger.debug(`Fetching traces for env \\`${env}\\`.`);\n      const flowStateStore = yield registry.lookupFlowStateStore(env);\n      if (!flowStateStore) {\n        return response.status(500).send({\n          code: import_action.StatusCodes.FAILED_PRECONDITION,\n          message: `${env} flow state store not found`\n        });\n      }\n      try {\n        response.json(\n          yield flowStateStore == null ? void 0 : flowStateStore.list({\n            limit: limit ? parseInt(limit.toString()) : void 0,\n            continuationToken: continuationToken ? continuationToken.toString() : void 0\n          })\n        );\n      } catch (err) {\n        const { message, stack } = err;\n        next({ message, stack });\n      }\n    }));\n    api.use((err, req, res, next) => {\n      import_logging.logger.error(err.stack);\n      const error = err;\n      const { message, stack } = error;\n      const errorResponse = {\n        code: import_action.StatusCodes.INTERNAL,\n        message,\n        details: {\n          stack\n        }\n      };\n      if (err.traceId) {\n        errorResponse.details.traceId = err.traceId;\n      }\n      res.status(500).json(errorResponse);\n    });\n    server = api.listen(port, () => {\n      console.log(`Reflection API running on http://localhost:${port}`);\n    });\n    server.on(\"error\", (error) => {\n      if (process.env.GENKIT_REFLECTION_ON_STARTUP_FAILURE === \"ignore\") {\n        import_logging.logger.warn(\n          `Failed to start the Reflection API on port ${port}, ignoring the error.`\n        );\n        import_logging.logger.debug(error);\n      } else {\n        throw error;\n      }\n    });\n    process.on(\"SIGTERM\", () => __async(this, null, function* () {\n      return yield stopReflectionApi();\n    }));\n  });\n}\nfunction stopReflectionApi() {\n  return __async(this, null, function* () {\n    yield Promise.all([\n      new Promise((resolve) => {\n        if (server) {\n          server.close(() => {\n            import_logging.logger.info(\"Reflection API has succesfully shut down.\");\n            resolve();\n          });\n        } else {\n          resolve();\n        }\n      }),\n      (0, import_tracing.cleanUpTracing)()\n    ]);\n    process.exit(0);\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=reflectionApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZmxlY3Rpb25BcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsd0JBQVM7QUFDOUMseUJBQXlCLG1CQUFPLENBQUMsMERBQUs7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWU7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVDQUF1QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUixnQkFBZ0IsaUJBQWlCO0FBQ2pDLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLGNBQWMsU0FBUztBQUN2QixzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUixnQkFBZ0IsaUJBQWlCO0FBQ2pDLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLGVBQWU7QUFDN0Isc0RBQXNELFFBQVEsZUFBZSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYywyQkFBMkI7QUFDekMsK0RBQStELElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQixpQkFBaUI7QUFDakMsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsNkRBQTZELE9BQU8sZUFBZSxJQUFJO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQkFBa0IsaUJBQWlCO0FBQ25DLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLDJCQUEyQjtBQUN6QywrREFBK0QsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLGlCQUFpQjtBQUNqQyxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0VBQWdFLEtBQUs7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLENBR0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZmxlY3Rpb25BcGkuanM/ZmQ5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIHJlZmxlY3Rpb25BcGlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVmbGVjdGlvbkFwaV9leHBvcnRzLCB7XG4gIFJ1bkFjdGlvblJlc3BvbnNlU2NoZW1hOiAoKSA9PiBSdW5BY3Rpb25SZXNwb25zZVNjaGVtYSxcbiAgc3RhcnRSZWZsZWN0aW9uQXBpOiAoKSA9PiBzdGFydFJlZmxlY3Rpb25BcGlcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocmVmbGVjdGlvbkFwaV9leHBvcnRzKTtcbnZhciBpbXBvcnRfZXhwcmVzcyA9IF9fdG9FU00ocmVxdWlyZShcImV4cHJlc3NcIikpO1xudmFyIGltcG9ydF96b2QgPSBfX3RvRVNNKHJlcXVpcmUoXCJ6b2RcIikpO1xudmFyIGltcG9ydF9hY3Rpb24gPSByZXF1aXJlKFwiLi9hY3Rpb24uanNcIik7XG52YXIgaW1wb3J0X2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZy5qc1wiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcuanNcIik7XG52YXIgcmVnaXN0cnkgPSBfX3RvRVNNKHJlcXVpcmUoXCIuL3JlZ2lzdHJ5LmpzXCIpKTtcbnZhciBpbXBvcnRfc2NoZW1hID0gcmVxdWlyZShcIi4vc2NoZW1hLmpzXCIpO1xudmFyIGltcG9ydF90cmFjaW5nID0gcmVxdWlyZShcIi4vdHJhY2luZy5qc1wiKTtcbmNvbnN0IFJ1bkFjdGlvblJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZC5kZWZhdWx0Lm9iamVjdCh7XG4gIHJlc3VsdDogaW1wb3J0X3pvZC5kZWZhdWx0LnVua25vd24oKS5vcHRpb25hbCgpLFxuICBlcnJvcjogaW1wb3J0X3pvZC5kZWZhdWx0LnVua25vd24oKS5vcHRpb25hbCgpLFxuICB0ZWxlbWV0cnk6IGltcG9ydF96b2QuZGVmYXVsdC5vYmplY3Qoe1xuICAgIHRyYWNlSWQ6IGltcG9ydF96b2QuZGVmYXVsdC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pLm9wdGlvbmFsKClcbn0pO1xubGV0IHNlcnZlcjtcbmNvbnN0IEdMT0JBTF9SRUZMRUNUSU9OX0FQSV9QT1JUX0tFWSA9IFwiZ2Vua2l0X19yZWZsZWN0aW9uQXBpUG9ydFwiO1xuZnVuY3Rpb24gc3RhcnRSZWZsZWN0aW9uQXBpKHBvcnQpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoZ2xvYmFsW0dMT0JBTF9SRUZMRUNUSU9OX0FQSV9QT1JUX0tFWV0gIT09IHZvaWQgMCkge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLndhcm4oXG4gICAgICAgIGBSZWZsZWN0aW9uIEFQSSBpcyBhbHJlYWR5IHJ1bm5pbmcgb24gcG9ydCAke2dsb2JhbFtHTE9CQUxfUkVGTEVDVElPTl9BUElfUE9SVF9LRVldfWBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IE51bWJlcihwcm9jZXNzLmVudi5HRU5LSVRfUkVGTEVDVElPTl9QT1JUKSB8fCAzMTAwO1xuICAgIH1cbiAgICBnbG9iYWxbR0xPQkFMX1JFRkxFQ1RJT05fQVBJX1BPUlRfS0VZXSA9IHBvcnQ7XG4gICAgY29uc3QgYXBpID0gKDAsIGltcG9ydF9leHByZXNzLmRlZmF1bHQpKCk7XG4gICAgYXBpLnVzZShpbXBvcnRfZXhwcmVzcy5kZWZhdWx0Lmpzb24oeyBsaW1pdDogXCIzMG1iXCIgfSkpO1xuICAgIGFwaS5nZXQoXCIvYXBpL19faGVhbHRoXCIsIChfLCByZXNwb25zZSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgcmVnaXN0cnkubGlzdEFjdGlvbnMoKTtcbiAgICAgIHJlc3BvbnNlLnN0YXR1cygyMDApLnNlbmQoXCJPS1wiKTtcbiAgICB9KSk7XG4gICAgYXBpLmdldChcIi9hcGkvX19xdWl0cXVpdHF1aXRcIiwgKF8sIHJlc3BvbnNlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoXCJSZWNlaXZlZCBxdWl0cXVpdHF1aXRcIik7XG4gICAgICByZXNwb25zZS5zdGF0dXMoMjAwKS5zZW5kKFwiT0tcIik7XG4gICAgICB5aWVsZCBzdG9wUmVmbGVjdGlvbkFwaSgpO1xuICAgIH0pKTtcbiAgICBhcGkuZ2V0KFwiL2FwaS9hY3Rpb25zXCIsIChfLCByZXNwb25zZSwgbmV4dCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKFwiRmV0Y2hpbmcgYWN0aW9ucy5cIik7XG4gICAgICBjb25zdCBhY3Rpb25zID0geWllbGQgcmVnaXN0cnkubGlzdEFjdGlvbnMoKTtcbiAgICAgIGNvbnN0IGNvbnZlcnRlZEFjdGlvbnMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW2tleV0uX19hY3Rpb247XG4gICAgICAgIGNvbnZlcnRlZEFjdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGFjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBtZXRhZGF0YTogYWN0aW9uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhY3Rpb24uaW5wdXRTY2hlbWEgfHwgYWN0aW9uLmlucHV0SnNvblNjaGVtYSkge1xuICAgICAgICAgIGNvbnZlcnRlZEFjdGlvbnNba2V5XS5pbnB1dFNjaGVtYSA9ICgwLCBpbXBvcnRfc2NoZW1hLnRvSnNvblNjaGVtYSkoe1xuICAgICAgICAgICAgc2NoZW1hOiBhY3Rpb24uaW5wdXRTY2hlbWEsXG4gICAgICAgICAgICBqc29uU2NoZW1hOiBhY3Rpb24uaW5wdXRKc29uU2NoZW1hXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5vdXRwdXRTY2hlbWEgfHwgYWN0aW9uLm91dHB1dEpzb25TY2hlbWEpIHtcbiAgICAgICAgICBjb252ZXJ0ZWRBY3Rpb25zW2tleV0ub3V0cHV0U2NoZW1hID0gKDAsIGltcG9ydF9zY2hlbWEudG9Kc29uU2NoZW1hKSh7XG4gICAgICAgICAgICBzY2hlbWE6IGFjdGlvbi5vdXRwdXRTY2hlbWEsXG4gICAgICAgICAgICBqc29uU2NoZW1hOiBhY3Rpb24ub3V0cHV0SnNvblNjaGVtYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlLnNlbmQoY29udmVydGVkQWN0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFjayB9ID0gZXJyO1xuICAgICAgICBuZXh0KHsgbWVzc2FnZSwgc3RhY2sgfSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGFwaS5wb3N0KFwiL2FwaS9ydW5BY3Rpb25cIiwgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IGtleSwgaW5wdXQgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSByZXF1ZXN0LnF1ZXJ5O1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBSdW5uaW5nIGFjdGlvbiBcXGAke2tleX1cXGAuLi5gKTtcbiAgICAgIGxldCB0cmFjZUlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0geWllbGQgcmVnaXN0cnkubG9va3VwQWN0aW9uKGtleSk7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzKDQwNCkuc2VuZChgYWN0aW9uICR7a2V5fSBub3QgZm91bmRgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCAoMCwgaW1wb3J0X3RyYWNpbmcubmV3VHJhY2UpKFxuICAgICAgICAgICAgeyBuYW1lOiBcImRldi1ydW4tYWN0aW9uLXdyYXBwZXJcIiB9LFxuICAgICAgICAgICAgKF8sIHNwYW4pID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgKDAsIGltcG9ydF90cmFjaW5nLnNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlKShcImdlbmtpdC1kZXYtaW50ZXJuYWxcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICB0cmFjZUlkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgaW1wb3J0X2FjdGlvbi5ydW5XaXRoU3RyZWFtaW5nQ2FsbGJhY2spKFxuICAgICAgICAgICAgICAgIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGUoSlNPTi5zdHJpbmdpZnkoY2h1bmspICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgYWN0aW9uKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHlpZWxkICgwLCBpbXBvcnRfdHJhY2luZy5mbHVzaFRyYWNpbmcpKCk7XG4gICAgICAgICAgcmVzcG9uc2Uud3JpdGUoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5OiB0cmFjZUlkID8ge1xuICAgICAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkICgwLCBpbXBvcnRfdHJhY2luZy5uZXdUcmFjZSkoXG4gICAgICAgICAgICB7IG5hbWU6IFwiZGV2LXJ1bi1hY3Rpb24td3JhcHBlclwiIH0sXG4gICAgICAgICAgICAoXywgc3BhbikgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAoMCwgaW1wb3J0X3RyYWNpbmcuc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGUpKFwiZ2Vua2l0LWRldi1pbnRlcm5hbFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgIHRyYWNlSWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGFjdGlvbihpbnB1dCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzcG9uc2Uuc2VuZCh7XG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB0ZWxlbWV0cnk6IHRyYWNlSWQgPyB7XG4gICAgICAgICAgICAgIHRyYWNlSWRcbiAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2sgfSA9IGVycjtcbiAgICAgICAgbmV4dCh7IG1lc3NhZ2UsIHN0YWNrLCB0cmFjZUlkIH0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBhcGkuZ2V0KFwiL2FwaS9lbnZzXCIsIChfLCByZXNwb25zZSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmVzcG9uc2UuanNvbihpbXBvcnRfY29uZmlnLmNvbmZpZy5jb25maWd1cmVkRW52cyk7XG4gICAgfSkpO1xuICAgIGFwaS5nZXQoXCIvYXBpL2VudnMvOmVudi90cmFjZXMvOnRyYWNlSWRcIiwgKHJlcXVlc3QsIHJlc3BvbnNlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IGVudiwgdHJhY2VJZCB9ID0gcmVxdWVzdC5wYXJhbXM7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoYEZldGNoaW5nIHRyYWNlIFxcYCR7dHJhY2VJZH1cXGAgZm9yIGVudiBcXGAke2Vudn1cXGAuYCk7XG4gICAgICBjb25zdCB0cmFjZXN0b3JlID0geWllbGQgcmVnaXN0cnkubG9va3VwVHJhY2VTdG9yZShlbnYpO1xuICAgICAgaWYgKCF0cmFjZXN0b3JlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMoNTAwKS5zZW5kKHtcbiAgICAgICAgICBjb2RlOiBpbXBvcnRfYWN0aW9uLlN0YXR1c0NvZGVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgICAgICAgbWVzc2FnZTogYCR7ZW52fSB0cmFjZSBzdG9yZSBub3QgZm91bmRgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2UgPSB5aWVsZCB0cmFjZXN0b3JlID09IG51bGwgPyB2b2lkIDAgOiB0cmFjZXN0b3JlLmxvYWQodHJhY2VJZCk7XG4gICAgICAgIHJldHVybiB0cmFjZSA/IHJlc3BvbnNlLmpzb24odHJhY2UpIDogcmVzcG9uc2Uuc3RhdHVzKDQwNCkuc2VuZCh7XG4gICAgICAgICAgY29kZTogaW1wb3J0X2FjdGlvbi5TdGF0dXNDb2Rlcy5OT1RfRk9VTkQsXG4gICAgICAgICAgbWVzc2FnZTogYFRyYWNlIHdpdGggdHJhY2VJZD0ke3RyYWNlSWR9IG5vdCBmb3VuZC5gXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnJvcjtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHtcbiAgICAgICAgICBjb2RlOiBpbXBvcnRfYWN0aW9uLlN0YXR1c0NvZGVzLklOVEVSTkFMLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMoNTAwKS5qc29uKGVycm9yUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBhcGkuZ2V0KFwiL2FwaS9lbnZzLzplbnYvdHJhY2VzXCIsIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgeyBlbnYgfSA9IHJlcXVlc3QucGFyYW1zO1xuICAgICAgY29uc3QgeyBsaW1pdCwgY29udGludWF0aW9uVG9rZW4gfSA9IHJlcXVlc3QucXVlcnk7XG4gICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuZGVidWcoYEZldGNoaW5nIHRyYWNlcyBmb3IgZW52IFxcYCR7ZW52fVxcYC5gKTtcbiAgICAgIGNvbnN0IHRyYWNlc3RvcmUgPSB5aWVsZCByZWdpc3RyeS5sb29rdXBUcmFjZVN0b3JlKGVudik7XG4gICAgICBpZiAoIXRyYWNlc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1cyg1MDApLnNlbmQoe1xuICAgICAgICAgIGNvZGU6IGltcG9ydF9hY3Rpb24uU3RhdHVzQ29kZXMuRkFJTEVEX1BSRUNPTkRJVElPTixcbiAgICAgICAgICBtZXNzYWdlOiBgJHtlbnZ9IHRyYWNlIHN0b3JlIG5vdCBmb3VuZGBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZS5qc29uKFxuICAgICAgICAgIHlpZWxkIHRyYWNlc3RvcmUubGlzdCh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQgPyBwYXJzZUludChsaW1pdC50b1N0cmluZygpKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGNvbnRpbnVhdGlvblRva2VuOiBjb250aW51YXRpb25Ub2tlbiA/IGNvbnRpbnVhdGlvblRva2VuLnRvU3RyaW5nKCkgOiB2b2lkIDBcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2sgfSA9IGVycjtcbiAgICAgICAgbmV4dCh7IG1lc3NhZ2UsIHN0YWNrIH0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBhcGkuZ2V0KFxuICAgICAgXCIvYXBpL2VudnMvOmVudi9mbG93U3RhdGVzLzpmbG93SWRcIixcbiAgICAgIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IGVudiwgZmxvd0lkIH0gPSByZXF1ZXN0LnBhcmFtcztcbiAgICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBGZXRjaGluZyBmbG93IHN0YXRlIFxcYCR7Zmxvd0lkfVxcYCBmb3IgZW52IFxcYCR7ZW52fVxcYC5gKTtcbiAgICAgICAgY29uc3QgZmxvd1N0YXRlU3RvcmUgPSB5aWVsZCByZWdpc3RyeS5sb29rdXBGbG93U3RhdGVTdG9yZShlbnYpO1xuICAgICAgICBpZiAoIWZsb3dTdGF0ZVN0b3JlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1cyg1MDApLnNlbmQoe1xuICAgICAgICAgICAgY29kZTogaW1wb3J0X2FjdGlvbi5TdGF0dXNDb2Rlcy5GQUlMRURfUFJFQ09ORElUSU9OLFxuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZW52fSBmbG93IHN0YXRlIHN0b3JlIG5vdCBmb3VuZGBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlLmpzb24oeWllbGQgZmxvd1N0YXRlU3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IGZsb3dTdGF0ZVN0b3JlLmxvYWQoZmxvd0lkKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2sgfSA9IGVycjtcbiAgICAgICAgICBuZXh0KHsgbWVzc2FnZSwgc3RhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBhcGkuZ2V0KFwiL2FwaS9lbnZzLzplbnYvZmxvd1N0YXRlc1wiLCAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHsgZW52IH0gPSByZXF1ZXN0LnBhcmFtcztcbiAgICAgIGNvbnN0IHsgbGltaXQsIGNvbnRpbnVhdGlvblRva2VuIH0gPSByZXF1ZXN0LnF1ZXJ5O1xuICAgICAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmRlYnVnKGBGZXRjaGluZyB0cmFjZXMgZm9yIGVudiBcXGAke2Vudn1cXGAuYCk7XG4gICAgICBjb25zdCBmbG93U3RhdGVTdG9yZSA9IHlpZWxkIHJlZ2lzdHJ5Lmxvb2t1cEZsb3dTdGF0ZVN0b3JlKGVudik7XG4gICAgICBpZiAoIWZsb3dTdGF0ZVN0b3JlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMoNTAwKS5zZW5kKHtcbiAgICAgICAgICBjb2RlOiBpbXBvcnRfYWN0aW9uLlN0YXR1c0NvZGVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgICAgICAgbWVzc2FnZTogYCR7ZW52fSBmbG93IHN0YXRlIHN0b3JlIG5vdCBmb3VuZGBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZS5qc29uKFxuICAgICAgICAgIHlpZWxkIGZsb3dTdGF0ZVN0b3JlID09IG51bGwgPyB2b2lkIDAgOiBmbG93U3RhdGVTdG9yZS5saXN0KHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdCA/IHBhcnNlSW50KGxpbWl0LnRvU3RyaW5nKCkpIDogdm9pZCAwLFxuICAgICAgICAgICAgY29udGludWF0aW9uVG9rZW46IGNvbnRpbnVhdGlvblRva2VuID8gY29udGludWF0aW9uVG9rZW4udG9TdHJpbmcoKSA6IHZvaWQgMFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFjayB9ID0gZXJyO1xuICAgICAgICBuZXh0KHsgbWVzc2FnZSwgc3RhY2sgfSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGFwaS51c2UoKGVyciwgcmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnJvcjtcbiAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgIGNvZGU6IGltcG9ydF9hY3Rpb24uU3RhdHVzQ29kZXMuSU5URVJOQUwsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBzdGFja1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGVyci50cmFjZUlkKSB7XG4gICAgICAgIGVycm9yUmVzcG9uc2UuZGV0YWlscy50cmFjZUlkID0gZXJyLnRyYWNlSWQ7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKDUwMCkuanNvbihlcnJvclJlc3BvbnNlKTtcbiAgICB9KTtcbiAgICBzZXJ2ZXIgPSBhcGkubGlzdGVuKHBvcnQsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBSZWZsZWN0aW9uIEFQSSBydW5uaW5nIG9uIGh0dHA6Ly9sb2NhbGhvc3Q6JHtwb3J0fWApO1xuICAgIH0pO1xuICAgIHNlcnZlci5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkdFTktJVF9SRUZMRUNUSU9OX09OX1NUQVJUVVBfRkFJTFVSRSA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIud2FybihcbiAgICAgICAgICBgRmFpbGVkIHRvIHN0YXJ0IHRoZSBSZWZsZWN0aW9uIEFQSSBvbiBwb3J0ICR7cG9ydH0sIGlnbm9yaW5nIHRoZSBlcnJvci5gXG4gICAgICAgICk7XG4gICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwcm9jZXNzLm9uKFwiU0lHVEVSTVwiLCAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgc3RvcFJlZmxlY3Rpb25BcGkoKTtcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RvcFJlZmxlY3Rpb25BcGkoKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHNlcnZlcikge1xuICAgICAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIuaW5mbyhcIlJlZmxlY3Rpb24gQVBJIGhhcyBzdWNjZXNmdWxseSBzaHV0IGRvd24uXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAoMCwgaW1wb3J0X3RyYWNpbmcuY2xlYW5VcFRyYWNpbmcpKClcbiAgICBdKTtcbiAgICBwcm9jZXNzLmV4aXQoMCk7XG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJ1bkFjdGlvblJlc3BvbnNlU2NoZW1hLFxuICBzdGFydFJlZmxlY3Rpb25BcGlcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGlvbkFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/reflectionApi.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js":
/*!******************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/registry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar registry_exports = {};\n__export(registry_exports, {\n  __hardResetRegistryForTesting: () => __hardResetRegistryForTesting,\n  initializePlugin: () => initializePlugin,\n  listActions: () => listActions,\n  lookupAction: () => lookupAction,\n  lookupFlowStateStore: () => lookupFlowStateStore,\n  lookupPlugin: () => lookupPlugin,\n  lookupSchema: () => lookupSchema,\n  lookupTraceStore: () => lookupTraceStore,\n  registerAction: () => registerAction,\n  registerFlowStateStore: () => registerFlowStateStore,\n  registerPluginProvider: () => registerPluginProvider,\n  registerSchema: () => registerSchema,\n  registerTraceStore: () => registerTraceStore\n});\nmodule.exports = __toCommonJS(registry_exports);\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_reflectionApi = __webpack_require__(/*! ./reflectionApi.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/reflectionApi.js\");\nconst ACTIONS_BY_ID = \"genkit__ACTIONS_BY_ID\";\nconst TRACE_STORES_BY_ENV = \"genkit__TRACE_STORES_BY_ENV\";\nconst FLOW_STATE_STORES_BY_ENV = \"genkit__FLOW_STATE_STORES_BY_ENV\";\nconst PLUGINS_BY_NAME = \"genkit__PLUGINS_BY_NAME\";\nconst SCHEMAS_BY_NAME = \"genkit__SCHEMAS_BY_NAME\";\nfunction actionsById() {\n  if (global[ACTIONS_BY_ID] === void 0) {\n    global[ACTIONS_BY_ID] = {};\n  }\n  return global[ACTIONS_BY_ID];\n}\nfunction traceStoresByEnv() {\n  if (global[TRACE_STORES_BY_ENV] === void 0) {\n    global[TRACE_STORES_BY_ENV] = {};\n  }\n  return global[TRACE_STORES_BY_ENV];\n}\nfunction flowStateStoresByEnv() {\n  if (global[FLOW_STATE_STORES_BY_ENV] === void 0) {\n    global[FLOW_STATE_STORES_BY_ENV] = {};\n  }\n  return global[FLOW_STATE_STORES_BY_ENV];\n}\nfunction pluginsByName() {\n  if (global[PLUGINS_BY_NAME] === void 0) {\n    global[PLUGINS_BY_NAME] = {};\n  }\n  return global[PLUGINS_BY_NAME];\n}\nfunction schemasByName() {\n  if (global[SCHEMAS_BY_NAME] === void 0) {\n    global[SCHEMAS_BY_NAME] = {};\n  }\n  return global[SCHEMAS_BY_NAME];\n}\nfunction lookupAction(key) {\n  return __async(this, null, function* () {\n    const pluginName = parsePluginName(key);\n    if (!actionsById()[key] && pluginName) {\n      yield initializePlugin(pluginName);\n    }\n    return actionsById()[key];\n  });\n}\nfunction parsePluginName(registryKey) {\n  const tokens = registryKey.split(\"/\");\n  if (tokens.length === 4) {\n    return tokens[2];\n  }\n  return void 0;\n}\nfunction registerAction(type, action) {\n  import_logging.logger.info(`Registering ${type}: ${action.__action.name}`);\n  const key = `/${type}/${action.__action.name}`;\n  if (actionsById().hasOwnProperty(key)) {\n    import_logging.logger.warn(\n      `WARNING: ${key} already has an entry in the registry. Overwriting.`\n    );\n  }\n  actionsById()[key] = action;\n}\nfunction listActions() {\n  return __async(this, null, function* () {\n    for (const pluginName of Object.keys(pluginsByName())) {\n      yield initializePlugin(pluginName);\n    }\n    return Object.assign({}, actionsById());\n  });\n}\nfunction registerTraceStore(env, traceStoreProvider) {\n  traceStoresByEnv()[env] = traceStoreProvider;\n}\nconst traceStoresByEnvCache = {};\nfunction lookupTraceStore(env) {\n  return __async(this, null, function* () {\n    if (!traceStoresByEnv()[env]) {\n      return void 0;\n    }\n    const cached = traceStoresByEnvCache[env];\n    if (!cached) {\n      const newStore = traceStoresByEnv()[env]();\n      traceStoresByEnvCache[env] = newStore;\n      return newStore;\n    }\n    return cached;\n  });\n}\nfunction registerFlowStateStore(env, flowStateStoreProvider) {\n  flowStateStoresByEnv()[env] = flowStateStoreProvider;\n}\nconst flowStateStoresByEnvCache = {};\nfunction lookupFlowStateStore(env) {\n  return __async(this, null, function* () {\n    if (!flowStateStoresByEnv()[env]) {\n      return void 0;\n    }\n    const cached = flowStateStoresByEnvCache[env];\n    if (!cached) {\n      const newStore = flowStateStoresByEnv()[env]();\n      flowStateStoresByEnvCache[env] = newStore;\n      return newStore;\n    }\n    return cached;\n  });\n}\nfunction registerPluginProvider(name, provider) {\n  let cached;\n  pluginsByName()[name] = {\n    name: provider.name,\n    initializer: () => {\n      if (cached) {\n        return cached;\n      }\n      cached = provider.initializer();\n      return cached;\n    }\n  };\n}\nfunction lookupPlugin(name) {\n  return pluginsByName()[name];\n}\nfunction initializePlugin(name) {\n  return __async(this, null, function* () {\n    if (pluginsByName()[name]) {\n      return yield pluginsByName()[name].initializer();\n    }\n    return void 0;\n  });\n}\nfunction registerSchema(name, data) {\n  schemasByName()[name] = data;\n}\nfunction lookupSchema(name) {\n  return schemasByName()[name];\n}\nif (process.env.GENKIT_ENV === \"dev\") {\n  (0, import_reflectionApi.startReflectionApi)();\n}\nfunction __hardResetRegistryForTesting() {\n  delete global[ACTIONS_BY_ID];\n  delete global[TRACE_STORES_BY_ENV];\n  delete global[FLOW_STATE_STORES_BY_ENV];\n  delete global[PLUGINS_BY_NAME];\n  deleteAll(flowStateStoresByEnvCache);\n  deleteAll(traceStoresByEnvCache);\n}\nfunction deleteAll(map) {\n  Object.keys(map).forEach((key) => delete map[key]);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=registry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFjO0FBQzNDLDJCQUEyQixtQkFBTyxDQUFDLGdHQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUssSUFBSSxxQkFBcUI7QUFDMUUsa0JBQWtCLEtBQUssR0FBRyxxQkFBcUI7QUFDL0M7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBY0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3JlZ2lzdHJ5LmpzP2FkYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciByZWdpc3RyeV9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZWdpc3RyeV9leHBvcnRzLCB7XG4gIF9faGFyZFJlc2V0UmVnaXN0cnlGb3JUZXN0aW5nOiAoKSA9PiBfX2hhcmRSZXNldFJlZ2lzdHJ5Rm9yVGVzdGluZyxcbiAgaW5pdGlhbGl6ZVBsdWdpbjogKCkgPT4gaW5pdGlhbGl6ZVBsdWdpbixcbiAgbGlzdEFjdGlvbnM6ICgpID0+IGxpc3RBY3Rpb25zLFxuICBsb29rdXBBY3Rpb246ICgpID0+IGxvb2t1cEFjdGlvbixcbiAgbG9va3VwRmxvd1N0YXRlU3RvcmU6ICgpID0+IGxvb2t1cEZsb3dTdGF0ZVN0b3JlLFxuICBsb29rdXBQbHVnaW46ICgpID0+IGxvb2t1cFBsdWdpbixcbiAgbG9va3VwU2NoZW1hOiAoKSA9PiBsb29rdXBTY2hlbWEsXG4gIGxvb2t1cFRyYWNlU3RvcmU6ICgpID0+IGxvb2t1cFRyYWNlU3RvcmUsXG4gIHJlZ2lzdGVyQWN0aW9uOiAoKSA9PiByZWdpc3RlckFjdGlvbixcbiAgcmVnaXN0ZXJGbG93U3RhdGVTdG9yZTogKCkgPT4gcmVnaXN0ZXJGbG93U3RhdGVTdG9yZSxcbiAgcmVnaXN0ZXJQbHVnaW5Qcm92aWRlcjogKCkgPT4gcmVnaXN0ZXJQbHVnaW5Qcm92aWRlcixcbiAgcmVnaXN0ZXJTY2hlbWE6ICgpID0+IHJlZ2lzdGVyU2NoZW1hLFxuICByZWdpc3RlclRyYWNlU3RvcmU6ICgpID0+IHJlZ2lzdGVyVHJhY2VTdG9yZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhyZWdpc3RyeV9leHBvcnRzKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcuanNcIik7XG52YXIgaW1wb3J0X3JlZmxlY3Rpb25BcGkgPSByZXF1aXJlKFwiLi9yZWZsZWN0aW9uQXBpLmpzXCIpO1xuY29uc3QgQUNUSU9OU19CWV9JRCA9IFwiZ2Vua2l0X19BQ1RJT05TX0JZX0lEXCI7XG5jb25zdCBUUkFDRV9TVE9SRVNfQllfRU5WID0gXCJnZW5raXRfX1RSQUNFX1NUT1JFU19CWV9FTlZcIjtcbmNvbnN0IEZMT1dfU1RBVEVfU1RPUkVTX0JZX0VOViA9IFwiZ2Vua2l0X19GTE9XX1NUQVRFX1NUT1JFU19CWV9FTlZcIjtcbmNvbnN0IFBMVUdJTlNfQllfTkFNRSA9IFwiZ2Vua2l0X19QTFVHSU5TX0JZX05BTUVcIjtcbmNvbnN0IFNDSEVNQVNfQllfTkFNRSA9IFwiZ2Vua2l0X19TQ0hFTUFTX0JZX05BTUVcIjtcbmZ1bmN0aW9uIGFjdGlvbnNCeUlkKCkge1xuICBpZiAoZ2xvYmFsW0FDVElPTlNfQllfSURdID09PSB2b2lkIDApIHtcbiAgICBnbG9iYWxbQUNUSU9OU19CWV9JRF0gPSB7fTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsW0FDVElPTlNfQllfSURdO1xufVxuZnVuY3Rpb24gdHJhY2VTdG9yZXNCeUVudigpIHtcbiAgaWYgKGdsb2JhbFtUUkFDRV9TVE9SRVNfQllfRU5WXSA9PT0gdm9pZCAwKSB7XG4gICAgZ2xvYmFsW1RSQUNFX1NUT1JFU19CWV9FTlZdID0ge307XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFtUUkFDRV9TVE9SRVNfQllfRU5WXTtcbn1cbmZ1bmN0aW9uIGZsb3dTdGF0ZVN0b3Jlc0J5RW52KCkge1xuICBpZiAoZ2xvYmFsW0ZMT1dfU1RBVEVfU1RPUkVTX0JZX0VOVl0gPT09IHZvaWQgMCkge1xuICAgIGdsb2JhbFtGTE9XX1NUQVRFX1NUT1JFU19CWV9FTlZdID0ge307XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFtGTE9XX1NUQVRFX1NUT1JFU19CWV9FTlZdO1xufVxuZnVuY3Rpb24gcGx1Z2luc0J5TmFtZSgpIHtcbiAgaWYgKGdsb2JhbFtQTFVHSU5TX0JZX05BTUVdID09PSB2b2lkIDApIHtcbiAgICBnbG9iYWxbUExVR0lOU19CWV9OQU1FXSA9IHt9O1xuICB9XG4gIHJldHVybiBnbG9iYWxbUExVR0lOU19CWV9OQU1FXTtcbn1cbmZ1bmN0aW9uIHNjaGVtYXNCeU5hbWUoKSB7XG4gIGlmIChnbG9iYWxbU0NIRU1BU19CWV9OQU1FXSA9PT0gdm9pZCAwKSB7XG4gICAgZ2xvYmFsW1NDSEVNQVNfQllfTkFNRV0gPSB7fTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsW1NDSEVNQVNfQllfTkFNRV07XG59XG5mdW5jdGlvbiBsb29rdXBBY3Rpb24oa2V5KSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcGx1Z2luTmFtZSA9IHBhcnNlUGx1Z2luTmFtZShrZXkpO1xuICAgIGlmICghYWN0aW9uc0J5SWQoKVtrZXldICYmIHBsdWdpbk5hbWUpIHtcbiAgICAgIHlpZWxkIGluaXRpYWxpemVQbHVnaW4ocGx1Z2luTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb25zQnlJZCgpW2tleV07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VQbHVnaW5OYW1lKHJlZ2lzdHJ5S2V5KSB7XG4gIGNvbnN0IHRva2VucyA9IHJlZ2lzdHJ5S2V5LnNwbGl0KFwiL1wiKTtcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdG9rZW5zWzJdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbih0eXBlLCBhY3Rpb24pIHtcbiAgaW1wb3J0X2xvZ2dpbmcubG9nZ2VyLmluZm8oYFJlZ2lzdGVyaW5nICR7dHlwZX06ICR7YWN0aW9uLl9fYWN0aW9uLm5hbWV9YCk7XG4gIGNvbnN0IGtleSA9IGAvJHt0eXBlfS8ke2FjdGlvbi5fX2FjdGlvbi5uYW1lfWA7XG4gIGlmIChhY3Rpb25zQnlJZCgpLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBpbXBvcnRfbG9nZ2luZy5sb2dnZXIud2FybihcbiAgICAgIGBXQVJOSU5HOiAke2tleX0gYWxyZWFkeSBoYXMgYW4gZW50cnkgaW4gdGhlIHJlZ2lzdHJ5LiBPdmVyd3JpdGluZy5gXG4gICAgKTtcbiAgfVxuICBhY3Rpb25zQnlJZCgpW2tleV0gPSBhY3Rpb247XG59XG5mdW5jdGlvbiBsaXN0QWN0aW9ucygpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbk5hbWUgb2YgT2JqZWN0LmtleXMocGx1Z2luc0J5TmFtZSgpKSkge1xuICAgICAgeWllbGQgaW5pdGlhbGl6ZVBsdWdpbihwbHVnaW5OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbnNCeUlkKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhY2VTdG9yZShlbnYsIHRyYWNlU3RvcmVQcm92aWRlcikge1xuICB0cmFjZVN0b3Jlc0J5RW52KClbZW52XSA9IHRyYWNlU3RvcmVQcm92aWRlcjtcbn1cbmNvbnN0IHRyYWNlU3RvcmVzQnlFbnZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbG9va3VwVHJhY2VTdG9yZShlbnYpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXRyYWNlU3RvcmVzQnlFbnYoKVtlbnZdKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWQgPSB0cmFjZVN0b3Jlc0J5RW52Q2FjaGVbZW52XTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgY29uc3QgbmV3U3RvcmUgPSB0cmFjZVN0b3Jlc0J5RW52KClbZW52XSgpO1xuICAgICAgdHJhY2VTdG9yZXNCeUVudkNhY2hlW2Vudl0gPSBuZXdTdG9yZTtcbiAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlckZsb3dTdGF0ZVN0b3JlKGVudiwgZmxvd1N0YXRlU3RvcmVQcm92aWRlcikge1xuICBmbG93U3RhdGVTdG9yZXNCeUVudigpW2Vudl0gPSBmbG93U3RhdGVTdG9yZVByb3ZpZGVyO1xufVxuY29uc3QgZmxvd1N0YXRlU3RvcmVzQnlFbnZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbG9va3VwRmxvd1N0YXRlU3RvcmUoZW52KSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFmbG93U3RhdGVTdG9yZXNCeUVudigpW2Vudl0pIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZCA9IGZsb3dTdGF0ZVN0b3Jlc0J5RW52Q2FjaGVbZW52XTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgY29uc3QgbmV3U3RvcmUgPSBmbG93U3RhdGVTdG9yZXNCeUVudigpW2Vudl0oKTtcbiAgICAgIGZsb3dTdGF0ZVN0b3Jlc0J5RW52Q2FjaGVbZW52XSA9IG5ld1N0b3JlO1xuICAgICAgcmV0dXJuIG5ld1N0b3JlO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luUHJvdmlkZXIobmFtZSwgcHJvdmlkZXIpIHtcbiAgbGV0IGNhY2hlZDtcbiAgcGx1Z2luc0J5TmFtZSgpW25hbWVdID0ge1xuICAgIG5hbWU6IHByb3ZpZGVyLm5hbWUsXG4gICAgaW5pdGlhbGl6ZXI6ICgpID0+IHtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgIH1cbiAgICAgIGNhY2hlZCA9IHByb3ZpZGVyLmluaXRpYWxpemVyKCk7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvb2t1cFBsdWdpbihuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5zQnlOYW1lKClbbmFtZV07XG59XG5mdW5jdGlvbiBpbml0aWFsaXplUGx1Z2luKG5hbWUpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAocGx1Z2luc0J5TmFtZSgpW25hbWVdKSB7XG4gICAgICByZXR1cm4geWllbGQgcGx1Z2luc0J5TmFtZSgpW25hbWVdLmluaXRpYWxpemVyKCk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTY2hlbWEobmFtZSwgZGF0YSkge1xuICBzY2hlbWFzQnlOYW1lKClbbmFtZV0gPSBkYXRhO1xufVxuZnVuY3Rpb24gbG9va3VwU2NoZW1hKG5hbWUpIHtcbiAgcmV0dXJuIHNjaGVtYXNCeU5hbWUoKVtuYW1lXTtcbn1cbmlmIChwcm9jZXNzLmVudi5HRU5LSVRfRU5WID09PSBcImRldlwiKSB7XG4gICgwLCBpbXBvcnRfcmVmbGVjdGlvbkFwaS5zdGFydFJlZmxlY3Rpb25BcGkpKCk7XG59XG5mdW5jdGlvbiBfX2hhcmRSZXNldFJlZ2lzdHJ5Rm9yVGVzdGluZygpIHtcbiAgZGVsZXRlIGdsb2JhbFtBQ1RJT05TX0JZX0lEXTtcbiAgZGVsZXRlIGdsb2JhbFtUUkFDRV9TVE9SRVNfQllfRU5WXTtcbiAgZGVsZXRlIGdsb2JhbFtGTE9XX1NUQVRFX1NUT1JFU19CWV9FTlZdO1xuICBkZWxldGUgZ2xvYmFsW1BMVUdJTlNfQllfTkFNRV07XG4gIGRlbGV0ZUFsbChmbG93U3RhdGVTdG9yZXNCeUVudkNhY2hlKTtcbiAgZGVsZXRlQWxsKHRyYWNlU3RvcmVzQnlFbnZDYWNoZSk7XG59XG5mdW5jdGlvbiBkZWxldGVBbGwobWFwKSB7XG4gIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgbWFwW2tleV0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIF9faGFyZFJlc2V0UmVnaXN0cnlGb3JUZXN0aW5nLFxuICBpbml0aWFsaXplUGx1Z2luLFxuICBsaXN0QWN0aW9ucyxcbiAgbG9va3VwQWN0aW9uLFxuICBsb29rdXBGbG93U3RhdGVTdG9yZSxcbiAgbG9va3VwUGx1Z2luLFxuICBsb29rdXBTY2hlbWEsXG4gIGxvb2t1cFRyYWNlU3RvcmUsXG4gIHJlZ2lzdGVyQWN0aW9uLFxuICByZWdpc3RlckZsb3dTdGF0ZVN0b3JlLFxuICByZWdpc3RlclBsdWdpblByb3ZpZGVyLFxuICByZWdpc3RlclNjaGVtYSxcbiAgcmVnaXN0ZXJUcmFjZVN0b3JlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdHJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/schema.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar schema_exports = {};\n__export(schema_exports, {\n  ValidationError: () => ValidationError,\n  defineJsonSchema: () => defineJsonSchema,\n  defineSchema: () => defineSchema,\n  parseSchema: () => parseSchema,\n  toJsonSchema: () => toJsonSchema,\n  validateSchema: () => validateSchema,\n  z: () => import_zod.z\n});\nmodule.exports = __toCommonJS(schema_exports);\nvar import_ajv = __toESM(__webpack_require__(/*! ajv */ \"(action-browser)/./node_modules/ajv/dist/ajv.js\"));\nvar import_ajv_formats = __toESM(__webpack_require__(/*! ajv-formats */ \"(action-browser)/./node_modules/ajv-formats/dist/index.js\"));\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nvar import_zod_to_json_schema = __toESM(__webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/cjs/index.js\"));\nvar import_error = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\nvar import_registry = __webpack_require__(/*! ./registry.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/registry.js\");\nconst ajv = new import_ajv.default();\n(0, import_ajv_formats.default)(ajv);\nconst jsonSchemas = /* @__PURE__ */ new WeakMap();\nconst validators = /* @__PURE__ */ new WeakMap();\nclass ValidationError extends import_error.GenkitError {\n  constructor({\n    data,\n    errors,\n    schema\n  }) {\n    super({\n      status: \"INVALID_ARGUMENT\",\n      message: `Schema validation failed. Parse Errors:\n\n${errors.map((e) => `- ${e.path}: ${e.message}`).join(\"\\n\")}\n\nProvided data:\n\n${JSON.stringify(data, null, 2)}\n\nRequired JSON schema:\n\n${JSON.stringify(schema, null, 2)}`,\n      detail: { errors, schema }\n    });\n  }\n}\nfunction toJsonSchema({\n  jsonSchema,\n  schema\n}) {\n  if (!jsonSchema && !schema)\n    return null;\n  if (jsonSchema)\n    return jsonSchema;\n  if (jsonSchemas.has(schema))\n    return jsonSchemas.get(schema);\n  const outSchema = (0, import_zod_to_json_schema.default)(schema, {\n    $refStrategy: \"none\",\n    removeAdditionalStrategy: \"strict\"\n  });\n  jsonSchemas.set(schema, outSchema);\n  return outSchema;\n}\nfunction toErrorDetail(error) {\n  return {\n    path: error.instancePath.substring(1).replace(/\\//g, \".\") || \"(root)\",\n    message: error.message\n  };\n}\nfunction validateSchema(data, options) {\n  var _a;\n  const toValidate = toJsonSchema(options);\n  if (!toValidate) {\n    return { valid: true, schema: toValidate };\n  }\n  const validator = validators.get(toValidate) || ajv.compile(toValidate);\n  const valid = validator(data);\n  const errors = (_a = validator.errors) == null ? void 0 : _a.map((e) => e);\n  return { valid, errors: errors == null ? void 0 : errors.map(toErrorDetail), schema: toValidate };\n}\nfunction parseSchema(data, options) {\n  const { valid, errors, schema } = validateSchema(data, options);\n  if (!valid)\n    throw new ValidationError({ data, errors, schema });\n  return data;\n}\nfunction defineSchema(name, schema) {\n  (0, import_registry.registerSchema)(name, { schema });\n  return schema;\n}\nfunction defineJsonSchema(name, jsonSchema) {\n  (0, import_registry.registerSchema)(name, { jsonSchema });\n  return jsonSchema;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=schema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0REFBSztBQUN0QyxpQ0FBaUMsbUJBQU8sQ0FBQyw4RUFBYTtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQywwREFBSztBQUM5Qix3Q0FBd0MsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLHVCQUF1QixPQUFPLElBQUksVUFBVTs7QUFFOUM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxFQUFFLGdDQUFnQztBQUNsQyxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVFMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi9zY2hlbWEuanM/Zjc2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgc2NoZW1hX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNjaGVtYV9leHBvcnRzLCB7XG4gIFZhbGlkYXRpb25FcnJvcjogKCkgPT4gVmFsaWRhdGlvbkVycm9yLFxuICBkZWZpbmVKc29uU2NoZW1hOiAoKSA9PiBkZWZpbmVKc29uU2NoZW1hLFxuICBkZWZpbmVTY2hlbWE6ICgpID0+IGRlZmluZVNjaGVtYSxcbiAgcGFyc2VTY2hlbWE6ICgpID0+IHBhcnNlU2NoZW1hLFxuICB0b0pzb25TY2hlbWE6ICgpID0+IHRvSnNvblNjaGVtYSxcbiAgdmFsaWRhdGVTY2hlbWE6ICgpID0+IHZhbGlkYXRlU2NoZW1hLFxuICB6OiAoKSA9PiBpbXBvcnRfem9kLnpcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc2NoZW1hX2V4cG9ydHMpO1xudmFyIGltcG9ydF9hanYgPSBfX3RvRVNNKHJlcXVpcmUoXCJhanZcIikpO1xudmFyIGltcG9ydF9hanZfZm9ybWF0cyA9IF9fdG9FU00ocmVxdWlyZShcImFqdi1mb3JtYXRzXCIpKTtcbnZhciBpbXBvcnRfem9kID0gcmVxdWlyZShcInpvZFwiKTtcbnZhciBpbXBvcnRfem9kX3RvX2pzb25fc2NoZW1hID0gX190b0VTTShyZXF1aXJlKFwiem9kLXRvLWpzb24tc2NoZW1hXCIpKTtcbnZhciBpbXBvcnRfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvci5qc1wiKTtcbnZhciBpbXBvcnRfcmVnaXN0cnkgPSByZXF1aXJlKFwiLi9yZWdpc3RyeS5qc1wiKTtcbmNvbnN0IGFqdiA9IG5ldyBpbXBvcnRfYWp2LmRlZmF1bHQoKTtcbigwLCBpbXBvcnRfYWp2X2Zvcm1hdHMuZGVmYXVsdCkoYWp2KTtcbmNvbnN0IGpzb25TY2hlbWFzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCB2YWxpZGF0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBpbXBvcnRfZXJyb3IuR2Vua2l0RXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc2NoZW1hXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBzdGF0dXM6IFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICAgICAgbWVzc2FnZTogYFNjaGVtYSB2YWxpZGF0aW9uIGZhaWxlZC4gUGFyc2UgRXJyb3JzOlxuXG4ke2Vycm9ycy5tYXAoKGUpID0+IGAtICR7ZS5wYXRofTogJHtlLm1lc3NhZ2V9YCkuam9pbihcIlxcblwiKX1cblxuUHJvdmlkZWQgZGF0YTpcblxuJHtKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKX1cblxuUmVxdWlyZWQgSlNPTiBzY2hlbWE6XG5cbiR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hLCBudWxsLCAyKX1gLFxuICAgICAgZGV0YWlsOiB7IGVycm9ycywgc2NoZW1hIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gdG9Kc29uU2NoZW1hKHtcbiAganNvblNjaGVtYSxcbiAgc2NoZW1hXG59KSB7XG4gIGlmICghanNvblNjaGVtYSAmJiAhc2NoZW1hKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoanNvblNjaGVtYSlcbiAgICByZXR1cm4ganNvblNjaGVtYTtcbiAgaWYgKGpzb25TY2hlbWFzLmhhcyhzY2hlbWEpKVxuICAgIHJldHVybiBqc29uU2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgY29uc3Qgb3V0U2NoZW1hID0gKDAsIGltcG9ydF96b2RfdG9fanNvbl9zY2hlbWEuZGVmYXVsdCkoc2NoZW1hLCB7XG4gICAgJHJlZlN0cmF0ZWd5OiBcIm5vbmVcIixcbiAgICByZW1vdmVBZGRpdGlvbmFsU3RyYXRlZ3k6IFwic3RyaWN0XCJcbiAgfSk7XG4gIGpzb25TY2hlbWFzLnNldChzY2hlbWEsIG91dFNjaGVtYSk7XG4gIHJldHVybiBvdXRTY2hlbWE7XG59XG5mdW5jdGlvbiB0b0Vycm9yRGV0YWlsKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgcGF0aDogZXJyb3IuaW5zdGFuY2VQYXRoLnN1YnN0cmluZygxKS5yZXBsYWNlKC9cXC8vZywgXCIuXCIpIHx8IFwiKHJvb3QpXCIsXG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHRvVmFsaWRhdGUgPSB0b0pzb25TY2hlbWEob3B0aW9ucyk7XG4gIGlmICghdG9WYWxpZGF0ZSkge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBzY2hlbWE6IHRvVmFsaWRhdGUgfTtcbiAgfVxuICBjb25zdCB2YWxpZGF0b3IgPSB2YWxpZGF0b3JzLmdldCh0b1ZhbGlkYXRlKSB8fCBhanYuY29tcGlsZSh0b1ZhbGlkYXRlKTtcbiAgY29uc3QgdmFsaWQgPSB2YWxpZGF0b3IoZGF0YSk7XG4gIGNvbnN0IGVycm9ycyA9IChfYSA9IHZhbGlkYXRvci5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpO1xuICByZXR1cm4geyB2YWxpZCwgZXJyb3JzOiBlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9ycy5tYXAodG9FcnJvckRldGFpbCksIHNjaGVtYTogdG9WYWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTY2hlbWEoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IHZhbGlkLCBlcnJvcnMsIHNjaGVtYSB9ID0gdmFsaWRhdGVTY2hlbWEoZGF0YSwgb3B0aW9ucyk7XG4gIGlmICghdmFsaWQpXG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih7IGRhdGEsIGVycm9ycywgc2NoZW1hIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGRlZmluZVNjaGVtYShuYW1lLCBzY2hlbWEpIHtcbiAgKDAsIGltcG9ydF9yZWdpc3RyeS5yZWdpc3RlclNjaGVtYSkobmFtZSwgeyBzY2hlbWEgfSk7XG4gIHJldHVybiBzY2hlbWE7XG59XG5mdW5jdGlvbiBkZWZpbmVKc29uU2NoZW1hKG5hbWUsIGpzb25TY2hlbWEpIHtcbiAgKDAsIGltcG9ydF9yZWdpc3RyeS5yZWdpc3RlclNjaGVtYSkobmFtZSwgeyBqc29uU2NoZW1hIH0pO1xuICByZXR1cm4ganNvblNjaGVtYTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBWYWxpZGF0aW9uRXJyb3IsXG4gIGRlZmluZUpzb25TY2hlbWEsXG4gIGRlZmluZVNjaGVtYSxcbiAgcGFyc2VTY2hlbWEsXG4gIHRvSnNvblNjaGVtYSxcbiAgdmFsaWRhdGVTY2hlbWEsXG4gIHpcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js":
/*!*********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/statusTypes.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar statusTypes_exports = {};\n__export(statusTypes_exports, {\n  StatusCodes: () => StatusCodes,\n  StatusNameSchema: () => StatusNameSchema,\n  StatusSchema: () => StatusSchema\n});\nmodule.exports = __toCommonJS(statusTypes_exports);\nvar z = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nvar StatusCodes = /* @__PURE__ */ ((StatusCodes2) => {\n  StatusCodes2[StatusCodes2[\"OK\"] = 0] = \"OK\";\n  StatusCodes2[StatusCodes2[\"CANCELLED\"] = 1] = \"CANCELLED\";\n  StatusCodes2[StatusCodes2[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n  StatusCodes2[StatusCodes2[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n  StatusCodes2[StatusCodes2[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n  StatusCodes2[StatusCodes2[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n  StatusCodes2[StatusCodes2[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n  StatusCodes2[StatusCodes2[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n  StatusCodes2[StatusCodes2[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n  StatusCodes2[StatusCodes2[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n  StatusCodes2[StatusCodes2[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n  StatusCodes2[StatusCodes2[\"ABORTED\"] = 10] = \"ABORTED\";\n  StatusCodes2[StatusCodes2[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n  StatusCodes2[StatusCodes2[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n  StatusCodes2[StatusCodes2[\"INTERNAL\"] = 13] = \"INTERNAL\";\n  StatusCodes2[StatusCodes2[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n  StatusCodes2[StatusCodes2[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n  return StatusCodes2;\n})(StatusCodes || {});\nconst StatusNameSchema = z.enum([\n  \"CANCELLED\",\n  \"UNKNOWN\",\n  \"INVALID_ARGUMENT\",\n  \"DEADLINE_EXCEEDED\",\n  \"NOT_FOUND\",\n  \"ALREADY_EXISTS\",\n  \"PERMISSION_DENIED\",\n  \"UNAUTHENTICATED\",\n  \"RESOURCE_EXHAUSTED\",\n  \"FAILED_PRECONDITION\",\n  \"ABORTED\",\n  \"OUT_OF_RANGE\",\n  \"UNIMPLEMENTED\",\n  \"INTERNAL\",\n  \"UNAVAILABLE\",\n  \"DATA_LOSS\"\n]);\nconst StatusCodesSchema = z.nativeEnum(StatusCodes);\nconst StatusSchema = z.object({\n  code: StatusCodesSchema,\n  message: z.string(),\n  details: z.any().optional()\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=statusTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3N0YXR1c1R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLENBSUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3N0YXR1c1R5cGVzLmpzPzU5NTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHN0YXR1c1R5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXR1c1R5cGVzX2V4cG9ydHMsIHtcbiAgU3RhdHVzQ29kZXM6ICgpID0+IFN0YXR1c0NvZGVzLFxuICBTdGF0dXNOYW1lU2NoZW1hOiAoKSA9PiBTdGF0dXNOYW1lU2NoZW1hLFxuICBTdGF0dXNTY2hlbWE6ICgpID0+IFN0YXR1c1NjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzdGF0dXNUeXBlc19leHBvcnRzKTtcbnZhciB6ID0gX190b0VTTShyZXF1aXJlKFwiem9kXCIpKTtcbnZhciBTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXR1c0NvZGVzMikgPT4ge1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiQUxSRUFEWV9FWElTVFNcIl0gPSA2XSA9IFwiQUxSRUFEWV9FWElTVFNcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiUkVTT1VSQ0VfRVhIQVVTVEVEXCJdID0gOF0gPSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJPVVRfT0ZfUkFOR0VcIl0gPSAxMV0gPSBcIk9VVF9PRl9SQU5HRVwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICBTdGF0dXNDb2RlczJbU3RhdHVzQ29kZXMyW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gIFN0YXR1c0NvZGVzMltTdGF0dXNDb2RlczJbXCJVTkFWQUlMQUJMRVwiXSA9IDE0XSA9IFwiVU5BVkFJTEFCTEVcIjtcbiAgU3RhdHVzQ29kZXMyW1N0YXR1c0NvZGVzMltcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG4gIHJldHVybiBTdGF0dXNDb2RlczI7XG59KShTdGF0dXNDb2RlcyB8fCB7fSk7XG5jb25zdCBTdGF0dXNOYW1lU2NoZW1hID0gei5lbnVtKFtcbiAgXCJDQU5DRUxMRURcIixcbiAgXCJVTktOT1dOXCIsXG4gIFwiSU5WQUxJRF9BUkdVTUVOVFwiLFxuICBcIkRFQURMSU5FX0VYQ0VFREVEXCIsXG4gIFwiTk9UX0ZPVU5EXCIsXG4gIFwiQUxSRUFEWV9FWElTVFNcIixcbiAgXCJQRVJNSVNTSU9OX0RFTklFRFwiLFxuICBcIlVOQVVUSEVOVElDQVRFRFwiLFxuICBcIlJFU09VUkNFX0VYSEFVU1RFRFwiLFxuICBcIkZBSUxFRF9QUkVDT05ESVRJT05cIixcbiAgXCJBQk9SVEVEXCIsXG4gIFwiT1VUX09GX1JBTkdFXCIsXG4gIFwiVU5JTVBMRU1FTlRFRFwiLFxuICBcIklOVEVSTkFMXCIsXG4gIFwiVU5BVkFJTEFCTEVcIixcbiAgXCJEQVRBX0xPU1NcIlxuXSk7XG5jb25zdCBTdGF0dXNDb2Rlc1NjaGVtYSA9IHoubmF0aXZlRW51bShTdGF0dXNDb2Rlcyk7XG5jb25zdCBTdGF0dXNTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGNvZGU6IFN0YXR1c0NvZGVzU2NoZW1hLFxuICBtZXNzYWdlOiB6LnN0cmluZygpLFxuICBkZXRhaWxzOiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0YXR1c0NvZGVzLFxuICBTdGF0dXNOYW1lU2NoZW1hLFxuICBTdGF0dXNTY2hlbWFcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzVHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/statusTypes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js":
/*!************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/telemetryTypes.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar telemetryTypes_exports = {};\nmodule.exports = __toCommonJS(telemetryTypes_exports);\n//# sourceMappingURL=telemetryTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RlbGVtZXRyeVR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RlbGVtZXRyeVR5cGVzLmpzPzIyNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHRlbGVtZXRyeVR5cGVzX2V4cG9ydHMgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHRlbGVtZXRyeVR5cGVzX2V4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVsZW1ldHJ5VHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js":
/*!*****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar tracing_exports = {};\n__export(tracing_exports, {\n  cleanUpTracing: () => cleanUpTracing,\n  enableTracingAndMetrics: () => enableTracingAndMetrics,\n  flushTracing: () => flushTracing\n});\nmodule.exports = __toCommonJS(tracing_exports);\nvar import_sdk_node = __webpack_require__(/*! @opentelemetry/sdk-node */ \"(action-browser)/./node_modules/@opentelemetry/sdk-node/build/src/index.js\");\nvar import_sdk_trace_base = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(action-browser)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nvar import_config = __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/config.js\");\nvar import_logging = __webpack_require__(/*! ./logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_exporter = __webpack_require__(/*! ./tracing/exporter.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\");\nvar import_multiSpanProcessor = __webpack_require__(/*! ./tracing/multiSpanProcessor.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/multiSpanProcessor.js\");\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/exporter.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/instrumentation.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/localFileTraceStore.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/localFileTraceStore.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/processor.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/processor.js\"), module.exports);\n__reExport(tracing_exports, __webpack_require__(/*! ./tracing/types.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js\"), module.exports);\nconst processors = [];\nlet telemetrySDK = null;\nlet nodeOtelConfig = null;\nfunction enableTracingAndMetrics(telemetryConfig, traceStore, traceStoreOptions = {}) {\n  if (traceStore) {\n    addProcessor(\n      createTraceStoreProcessor(\n        traceStore,\n        traceStoreOptions.processor || \"batch\"\n      )\n    );\n  }\n  nodeOtelConfig = telemetryConfig.getConfig() || {};\n  addProcessor(nodeOtelConfig.spanProcessor);\n  nodeOtelConfig.spanProcessor = new import_multiSpanProcessor.MultiSpanProcessor(processors);\n  telemetrySDK = new import_sdk_node.NodeSDK(nodeOtelConfig);\n  telemetrySDK.start();\n  process.on(\"SIGTERM\", () => __async(this, null, function* () {\n    return yield cleanUpTracing();\n  }));\n}\nfunction cleanUpTracing() {\n  return __async(this, null, function* () {\n    return new Promise((resolve) => {\n      if (telemetrySDK) {\n        const metricFlush = maybeFlushMetrics();\n        return metricFlush.then(() => {\n          return telemetrySDK.shutdown().then(() => {\n            import_logging.logger.debug(\"OpenTelemetry SDK shut down.\");\n            telemetrySDK = null;\n            resolve();\n          });\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nfunction createTraceStoreProcessor(traceStore, processor) {\n  const exporter = new import_exporter.TraceStoreExporter(traceStore);\n  return processor === \"simple\" || (0, import_config.getCurrentEnv)() === \"dev\" ? new import_sdk_trace_base.SimpleSpanProcessor(exporter) : new import_sdk_trace_base.BatchSpanProcessor(exporter);\n}\nfunction addProcessor(processor) {\n  if (processor)\n    processors.push(processor);\n}\nfunction maybeFlushMetrics() {\n  if (nodeOtelConfig == null ? void 0 : nodeOtelConfig.metricReader) {\n    return nodeOtelConfig.metricReader.forceFlush();\n  }\n  return Promise.resolve();\n}\nfunction flushTracing() {\n  return __async(this, null, function* () {\n    yield Promise.all(processors.map((p) => p.forceFlush()));\n  });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=tracing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsMkdBQXlCO0FBQ3ZELDRCQUE0QixtQkFBTyxDQUFDLHVIQUErQjtBQUNuRSxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyxzR0FBdUI7QUFDckQsZ0NBQWdDLG1CQUFPLENBQUMsMEhBQWlDO0FBQ3pFLDRCQUE0QixtQkFBTyxDQUFDLHNHQUF1QjtBQUMzRCw0QkFBNEIsbUJBQU8sQ0FBQyxvSEFBOEI7QUFDbEUsNEJBQTRCLG1CQUFPLENBQUMsNEhBQWtDO0FBQ3RFLDRCQUE0QixtQkFBTyxDQUFDLHdHQUF3QjtBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLENBU0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcuanM/YjEzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciB0cmFjaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRyYWNpbmdfZXhwb3J0cywge1xuICBjbGVhblVwVHJhY2luZzogKCkgPT4gY2xlYW5VcFRyYWNpbmcsXG4gIGVuYWJsZVRyYWNpbmdBbmRNZXRyaWNzOiAoKSA9PiBlbmFibGVUcmFjaW5nQW5kTWV0cmljcyxcbiAgZmx1c2hUcmFjaW5nOiAoKSA9PiBmbHVzaFRyYWNpbmdcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModHJhY2luZ19leHBvcnRzKTtcbnZhciBpbXBvcnRfc2RrX25vZGUgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2RrLW5vZGVcIik7XG52YXIgaW1wb3J0X3Nka190cmFjZV9iYXNlID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlXCIpO1xudmFyIGltcG9ydF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWcuanNcIik7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nLmpzXCIpO1xudmFyIGltcG9ydF9leHBvcnRlciA9IHJlcXVpcmUoXCIuL3RyYWNpbmcvZXhwb3J0ZXIuanNcIik7XG52YXIgaW1wb3J0X211bHRpU3BhblByb2Nlc3NvciA9IHJlcXVpcmUoXCIuL3RyYWNpbmcvbXVsdGlTcGFuUHJvY2Vzc29yLmpzXCIpO1xuX19yZUV4cG9ydCh0cmFjaW5nX2V4cG9ydHMsIHJlcXVpcmUoXCIuL3RyYWNpbmcvZXhwb3J0ZXIuanNcIiksIG1vZHVsZS5leHBvcnRzKTtcbl9fcmVFeHBvcnQodHJhY2luZ19leHBvcnRzLCByZXF1aXJlKFwiLi90cmFjaW5nL2luc3RydW1lbnRhdGlvbi5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuX19yZUV4cG9ydCh0cmFjaW5nX2V4cG9ydHMsIHJlcXVpcmUoXCIuL3RyYWNpbmcvbG9jYWxGaWxlVHJhY2VTdG9yZS5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuX19yZUV4cG9ydCh0cmFjaW5nX2V4cG9ydHMsIHJlcXVpcmUoXCIuL3RyYWNpbmcvcHJvY2Vzc29yLmpzXCIpLCBtb2R1bGUuZXhwb3J0cyk7XG5fX3JlRXhwb3J0KHRyYWNpbmdfZXhwb3J0cywgcmVxdWlyZShcIi4vdHJhY2luZy90eXBlcy5qc1wiKSwgbW9kdWxlLmV4cG9ydHMpO1xuY29uc3QgcHJvY2Vzc29ycyA9IFtdO1xubGV0IHRlbGVtZXRyeVNESyA9IG51bGw7XG5sZXQgbm9kZU90ZWxDb25maWcgPSBudWxsO1xuZnVuY3Rpb24gZW5hYmxlVHJhY2luZ0FuZE1ldHJpY3ModGVsZW1ldHJ5Q29uZmlnLCB0cmFjZVN0b3JlLCB0cmFjZVN0b3JlT3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0cmFjZVN0b3JlKSB7XG4gICAgYWRkUHJvY2Vzc29yKFxuICAgICAgY3JlYXRlVHJhY2VTdG9yZVByb2Nlc3NvcihcbiAgICAgICAgdHJhY2VTdG9yZSxcbiAgICAgICAgdHJhY2VTdG9yZU9wdGlvbnMucHJvY2Vzc29yIHx8IFwiYmF0Y2hcIlxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgbm9kZU90ZWxDb25maWcgPSB0ZWxlbWV0cnlDb25maWcuZ2V0Q29uZmlnKCkgfHwge307XG4gIGFkZFByb2Nlc3Nvcihub2RlT3RlbENvbmZpZy5zcGFuUHJvY2Vzc29yKTtcbiAgbm9kZU90ZWxDb25maWcuc3BhblByb2Nlc3NvciA9IG5ldyBpbXBvcnRfbXVsdGlTcGFuUHJvY2Vzc29yLk11bHRpU3BhblByb2Nlc3Nvcihwcm9jZXNzb3JzKTtcbiAgdGVsZW1ldHJ5U0RLID0gbmV3IGltcG9ydF9zZGtfbm9kZS5Ob2RlU0RLKG5vZGVPdGVsQ29uZmlnKTtcbiAgdGVsZW1ldHJ5U0RLLnN0YXJ0KCk7XG4gIHByb2Nlc3Mub24oXCJTSUdURVJNXCIsICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4geWllbGQgY2xlYW5VcFRyYWNpbmcoKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gY2xlYW5VcFRyYWNpbmcoKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGVsZW1ldHJ5U0RLKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpY0ZsdXNoID0gbWF5YmVGbHVzaE1ldHJpY3MoKTtcbiAgICAgICAgcmV0dXJuIG1ldHJpY0ZsdXNoLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0ZWxlbWV0cnlTREsuc2h1dGRvd24oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5kZWJ1ZyhcIk9wZW5UZWxlbWV0cnkgU0RLIHNodXQgZG93bi5cIik7XG4gICAgICAgICAgICB0ZWxlbWV0cnlTREsgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFjZVN0b3JlUHJvY2Vzc29yKHRyYWNlU3RvcmUsIHByb2Nlc3Nvcikge1xuICBjb25zdCBleHBvcnRlciA9IG5ldyBpbXBvcnRfZXhwb3J0ZXIuVHJhY2VTdG9yZUV4cG9ydGVyKHRyYWNlU3RvcmUpO1xuICByZXR1cm4gcHJvY2Vzc29yID09PSBcInNpbXBsZVwiIHx8ICgwLCBpbXBvcnRfY29uZmlnLmdldEN1cnJlbnRFbnYpKCkgPT09IFwiZGV2XCIgPyBuZXcgaW1wb3J0X3Nka190cmFjZV9iYXNlLlNpbXBsZVNwYW5Qcm9jZXNzb3IoZXhwb3J0ZXIpIDogbmV3IGltcG9ydF9zZGtfdHJhY2VfYmFzZS5CYXRjaFNwYW5Qcm9jZXNzb3IoZXhwb3J0ZXIpO1xufVxuZnVuY3Rpb24gYWRkUHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICBpZiAocHJvY2Vzc29yKVxuICAgIHByb2Nlc3NvcnMucHVzaChwcm9jZXNzb3IpO1xufVxuZnVuY3Rpb24gbWF5YmVGbHVzaE1ldHJpY3MoKSB7XG4gIGlmIChub2RlT3RlbENvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogbm9kZU90ZWxDb25maWcubWV0cmljUmVhZGVyKSB7XG4gICAgcmV0dXJuIG5vZGVPdGVsQ29uZmlnLm1ldHJpY1JlYWRlci5mb3JjZUZsdXNoKCk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuZnVuY3Rpb24gZmx1c2hUcmFjaW5nKCkge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHlpZWxkIFByb21pc2UuYWxsKHByb2Nlc3NvcnMubWFwKChwKSA9PiBwLmZvcmNlRmx1c2goKSkpO1xuICB9KTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhblVwVHJhY2luZyxcbiAgZW5hYmxlVHJhY2luZ0FuZE1ldHJpY3MsXG4gIGZsdXNoVHJhY2luZyxcbiAgLi4ucmVxdWlyZShcIi4vdHJhY2luZy9leHBvcnRlci5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vdHJhY2luZy9pbnN0cnVtZW50YXRpb24uanNcIiksXG4gIC4uLnJlcXVpcmUoXCIuL3RyYWNpbmcvbG9jYWxGaWxlVHJhY2VTdG9yZS5qc1wiKSxcbiAgLi4ucmVxdWlyZShcIi4vdHJhY2luZy9wcm9jZXNzb3IuanNcIiksXG4gIC4uLnJlcXVpcmUoXCIuL3RyYWNpbmcvdHlwZXMuanNcIilcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2luZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js":
/*!**************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/exporter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar exporter_exports = {};\n__export(exporter_exports, {\n  TraceStoreExporter: () => TraceStoreExporter\n});\nmodule.exports = __toCommonJS(exporter_exports);\nvar import_api = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nvar import_core = __webpack_require__(/*! @opentelemetry/core */ \"(action-browser)/./node_modules/@opentelemetry/core/build/esm/index.js\");\nvar import_logging = __webpack_require__(/*! ../logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_utils = __webpack_require__(/*! ../utils.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\");\nclass TraceStoreExporter {\n  constructor(traceStore) {\n    this.traceStore = traceStore;\n  }\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(spans, resultCallback) {\n    this._sendSpans(spans, resultCallback);\n  }\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown() {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n  /**\n   * Converts span info into trace store format.\n   * @param span\n   */\n  _exportInfo(span) {\n    const spanData = {\n      spanId: span.spanContext().spanId,\n      traceId: span.spanContext().traceId,\n      startTime: transformTime(span.startTime),\n      endTime: transformTime(span.endTime),\n      attributes: __spreadValues({}, span.attributes),\n      displayName: span.name,\n      links: span.links,\n      spanKind: import_api.SpanKind[span.kind],\n      parentSpanId: span.parentSpanId,\n      sameProcessAsParentSpan: { value: !span.spanContext().isRemote },\n      status: span.status,\n      timeEvents: {\n        timeEvent: span.events.map((e) => {\n          var _a;\n          return {\n            time: transformTime(e.time),\n            annotation: {\n              attributes: (_a = e.attributes) != null ? _a : {},\n              description: e.name\n            }\n          };\n        })\n      }\n    };\n    if (span.instrumentationLibrary !== void 0) {\n      spanData.instrumentationLibrary = {\n        name: span.instrumentationLibrary.name\n      };\n      if (span.instrumentationLibrary.schemaUrl !== void 0) {\n        spanData.instrumentationLibrary.schemaUrl = span.instrumentationLibrary.schemaUrl;\n      }\n      if (span.instrumentationLibrary.version !== void 0) {\n        spanData.instrumentationLibrary.version = span.instrumentationLibrary.version;\n      }\n    }\n    (0, import_utils.deleteUndefinedProps)(spanData);\n    return spanData;\n  }\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush() {\n    return Promise.resolve();\n  }\n  _sendSpans(spans, done) {\n    return __async(this, null, function* () {\n      const traces = {};\n      for (const span of spans) {\n        if (!traces[span.spanContext().traceId]) {\n          traces[span.spanContext().traceId] = [];\n        }\n        traces[span.spanContext().traceId].push(span);\n      }\n      let error = false;\n      for (const traceId of Object.keys(traces)) {\n        try {\n          yield this.save(traceId, traces[traceId]);\n        } catch (e) {\n          error = true;\n          import_logging.logger.error(\"Failed to save trace ${traceId}\", e);\n        }\n        if (done) {\n          return done({\n            code: error ? import_core.ExportResultCode.FAILED : import_core.ExportResultCode.SUCCESS\n          });\n        }\n      }\n    });\n  }\n  save(traceId, spans) {\n    return __async(this, null, function* () {\n      const data = {\n        traceId,\n        spans: {}\n      };\n      for (const span of spans) {\n        const convertedSpan = this._exportInfo(span);\n        data.spans[convertedSpan.spanId] = convertedSpan;\n        if (!convertedSpan.parentSpanId) {\n          data.displayName = convertedSpan.displayName;\n          data.startTime = convertedSpan.startTime;\n          data.endTime = convertedSpan.endTime;\n        }\n      }\n      yield this.traceStore.save(traceId, data);\n    });\n  }\n}\nfunction transformTime(time) {\n  return (0, import_core.hrTimeToMilliseconds)(time);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=exporter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvZXhwb3J0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsaUdBQW9CO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLG1HQUFxQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBZTtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFDQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhEQUE4RCxRQUFRO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvZXhwb3J0ZXIuanM/YmQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIGV4cG9ydGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydGVyX2V4cG9ydHMsIHtcbiAgVHJhY2VTdG9yZUV4cG9ydGVyOiAoKSA9PiBUcmFjZVN0b3JlRXhwb3J0ZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZXhwb3J0ZXJfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2FwaSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG52YXIgaW1wb3J0X2NvcmUgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbnZhciBpbXBvcnRfbG9nZ2luZyA9IHJlcXVpcmUoXCIuLi9sb2dnaW5nLmpzXCIpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbmNsYXNzIFRyYWNlU3RvcmVFeHBvcnRlciB7XG4gIGNvbnN0cnVjdG9yKHRyYWNlU3RvcmUpIHtcbiAgICB0aGlzLnRyYWNlU3RvcmUgPSB0cmFjZVN0b3JlO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnQgc3BhbnMuXG4gICAqIEBwYXJhbSBzcGFuc1xuICAgKiBAcGFyYW0gcmVzdWx0Q2FsbGJhY2tcbiAgICovXG4gIGV4cG9ydChzcGFucywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICB0aGlzLl9zZW5kU3BhbnMoc3BhbnMsIHJlc3VsdENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogU2h1dGRvd24gdGhlIGV4cG9ydGVyLlxuICAgKi9cbiAgc2h1dGRvd24oKSB7XG4gICAgdGhpcy5fc2VuZFNwYW5zKFtdKTtcbiAgICByZXR1cm4gdGhpcy5mb3JjZUZsdXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHNwYW4gaW5mbyBpbnRvIHRyYWNlIHN0b3JlIGZvcm1hdC5cbiAgICogQHBhcmFtIHNwYW5cbiAgICovXG4gIF9leHBvcnRJbmZvKHNwYW4pIHtcbiAgICBjb25zdCBzcGFuRGF0YSA9IHtcbiAgICAgIHNwYW5JZDogc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCxcbiAgICAgIHRyYWNlSWQ6IHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkLFxuICAgICAgc3RhcnRUaW1lOiB0cmFuc2Zvcm1UaW1lKHNwYW4uc3RhcnRUaW1lKSxcbiAgICAgIGVuZFRpbWU6IHRyYW5zZm9ybVRpbWUoc3Bhbi5lbmRUaW1lKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9fc3ByZWFkVmFsdWVzKHt9LCBzcGFuLmF0dHJpYnV0ZXMpLFxuICAgICAgZGlzcGxheU5hbWU6IHNwYW4ubmFtZSxcbiAgICAgIGxpbmtzOiBzcGFuLmxpbmtzLFxuICAgICAgc3BhbktpbmQ6IGltcG9ydF9hcGkuU3BhbktpbmRbc3Bhbi5raW5kXSxcbiAgICAgIHBhcmVudFNwYW5JZDogc3Bhbi5wYXJlbnRTcGFuSWQsXG4gICAgICBzYW1lUHJvY2Vzc0FzUGFyZW50U3BhbjogeyB2YWx1ZTogIXNwYW4uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSB9LFxuICAgICAgc3RhdHVzOiBzcGFuLnN0YXR1cyxcbiAgICAgIHRpbWVFdmVudHM6IHtcbiAgICAgICAgdGltZUV2ZW50OiBzcGFuLmV2ZW50cy5tYXAoKGUpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWU6IHRyYW5zZm9ybVRpbWUoZS50aW1lKSxcbiAgICAgICAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogKF9hID0gZS5hdHRyaWJ1dGVzKSAhPSBudWxsID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGUubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5ICE9PSB2b2lkIDApIHtcbiAgICAgIHNwYW5EYXRhLmluc3RydW1lbnRhdGlvbkxpYnJhcnkgPSB7XG4gICAgICAgIG5hbWU6IHNwYW4uaW5zdHJ1bWVudGF0aW9uTGlicmFyeS5uYW1lXG4gICAgICB9O1xuICAgICAgaWYgKHNwYW4uaW5zdHJ1bWVudGF0aW9uTGlicmFyeS5zY2hlbWFVcmwgIT09IHZvaWQgMCkge1xuICAgICAgICBzcGFuRGF0YS5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnNjaGVtYVVybCA9IHNwYW4uaW5zdHJ1bWVudGF0aW9uTGlicmFyeS5zY2hlbWFVcmw7XG4gICAgICB9XG4gICAgICBpZiAoc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBzcGFuRGF0YS5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnZlcnNpb24gPSBzcGFuLmluc3RydW1lbnRhdGlvbkxpYnJhcnkudmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgKDAsIGltcG9ydF91dGlscy5kZWxldGVVbmRlZmluZWRQcm9wcykoc3BhbkRhdGEpO1xuICAgIHJldHVybiBzcGFuRGF0YTtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0cyBhbnkgcGVuZGluZyBzcGFucyBpbiBleHBvcnRlclxuICAgKi9cbiAgZm9yY2VGbHVzaCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NlbmRTcGFucyhzcGFucywgZG9uZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0cmFjZXMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgICAgICBpZiAoIXRyYWNlc1tzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZF0pIHtcbiAgICAgICAgICB0cmFjZXNbc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VzW3NwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkXS5wdXNoKHNwYW4pO1xuICAgICAgfVxuICAgICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHRyYWNlSWQgb2YgT2JqZWN0LmtleXModHJhY2VzKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc2F2ZSh0cmFjZUlkLCB0cmFjZXNbdHJhY2VJZF0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHRyYWNlICR7dHJhY2VJZH1cIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSh7XG4gICAgICAgICAgICBjb2RlOiBlcnJvciA/IGltcG9ydF9jb3JlLkV4cG9ydFJlc3VsdENvZGUuRkFJTEVEIDogaW1wb3J0X2NvcmUuRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzYXZlKHRyYWNlSWQsIHNwYW5zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHRyYWNlSWQsXG4gICAgICAgIHNwYW5zOiB7fVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRTcGFuID0gdGhpcy5fZXhwb3J0SW5mbyhzcGFuKTtcbiAgICAgICAgZGF0YS5zcGFuc1tjb252ZXJ0ZWRTcGFuLnNwYW5JZF0gPSBjb252ZXJ0ZWRTcGFuO1xuICAgICAgICBpZiAoIWNvbnZlcnRlZFNwYW4ucGFyZW50U3BhbklkKSB7XG4gICAgICAgICAgZGF0YS5kaXNwbGF5TmFtZSA9IGNvbnZlcnRlZFNwYW4uZGlzcGxheU5hbWU7XG4gICAgICAgICAgZGF0YS5zdGFydFRpbWUgPSBjb252ZXJ0ZWRTcGFuLnN0YXJ0VGltZTtcbiAgICAgICAgICBkYXRhLmVuZFRpbWUgPSBjb252ZXJ0ZWRTcGFuLmVuZFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMudHJhY2VTdG9yZS5zYXZlKHRyYWNlSWQsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UaW1lKHRpbWUpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfY29yZS5oclRpbWVUb01pbGxpc2Vjb25kcykodGltZSk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJhY2VTdG9yZUV4cG9ydGVyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/exporter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar instrumentation_exports = {};\n__export(instrumentation_exports, {\n  ATTR_PREFIX: () => ATTR_PREFIX,\n  SPAN_TYPE_ATTR: () => SPAN_TYPE_ATTR,\n  newTrace: () => newTrace,\n  runInNewSpan: () => runInNewSpan,\n  setCustomMetadataAttribute: () => setCustomMetadataAttribute,\n  setCustomMetadataAttributes: () => setCustomMetadataAttributes,\n  spanMetadataAls: () => spanMetadataAls,\n  toDisplayPath: () => toDisplayPath,\n  traceMetadataAls: () => traceMetadataAls\n});\nmodule.exports = __toCommonJS(instrumentation_exports);\nvar import_api = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nvar import_node_async_hooks = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nvar import_node_perf_hooks = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nconst spanMetadataAls = new import_node_async_hooks.AsyncLocalStorage();\nconst traceMetadataAls = new import_node_async_hooks.AsyncLocalStorage();\nconst ATTR_PREFIX = \"genkit\";\nconst SPAN_TYPE_ATTR = ATTR_PREFIX + \":type\";\nconst TRACER_NAME = \"genkit-tracer\";\nconst TRACER_VERSION = \"v1\";\nfunction newTrace(opts, fn) {\n  return __async(this, null, function* () {\n    const isRoot = traceMetadataAls.getStore() ? false : true;\n    const traceMetadata = traceMetadataAls.getStore() || {\n      paths: /* @__PURE__ */ new Set(),\n      timestamp: import_node_perf_hooks.performance.now()\n    };\n    if (opts.labels && opts.labels[SPAN_TYPE_ATTR] === \"flow\") {\n      traceMetadata.flowName = opts.name;\n    }\n    return yield traceMetadataAls.run(\n      traceMetadata,\n      () => runInNewSpan(\n        {\n          metadata: {\n            name: opts.name,\n            isRoot\n          },\n          labels: opts.labels,\n          links: opts.links\n        },\n        (metadata, otSpan) => __async(this, null, function* () {\n          return yield fn(metadata, otSpan);\n        })\n      )\n    );\n  });\n}\nfunction runInNewSpan(opts, fn) {\n  return __async(this, null, function* () {\n    const tracer = import_api.trace.getTracer(TRACER_NAME, TRACER_VERSION);\n    const parentStep = spanMetadataAls.getStore();\n    const isInRoot = (parentStep == null ? void 0 : parentStep.isRoot) === true;\n    return yield tracer.startActiveSpan(\n      opts.metadata.name,\n      { links: opts.links, root: opts.metadata.isRoot },\n      (otSpan) => __async(this, null, function* () {\n        if (opts.labels)\n          otSpan.setAttributes(opts.labels);\n        try {\n          opts.metadata.path = buildPath(\n            opts.metadata.name,\n            (parentStep == null ? void 0 : parentStep.path) || \"\",\n            opts.labels\n          );\n          const output = yield spanMetadataAls.run(\n            opts.metadata,\n            () => fn(opts.metadata, otSpan, isInRoot)\n          );\n          if (opts.metadata.state !== \"error\") {\n            opts.metadata.state = \"success\";\n          }\n          recordPath(opts.metadata);\n          return output;\n        } catch (e) {\n          recordPath(opts.metadata, e);\n          opts.metadata.state = \"error\";\n          otSpan.setStatus({\n            code: import_api.SpanStatusCode.ERROR,\n            message: getErrorMessage(e)\n          });\n          if (e instanceof Error) {\n            otSpan.recordException(e);\n          }\n          throw e;\n        } finally {\n          otSpan.setAttributes(metadataToAttributes(opts.metadata));\n          otSpan.end();\n        }\n      })\n    );\n  });\n}\nfunction getErrorMessage(e) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  return `${e}`;\n}\nfunction metadataToAttributes(metadata) {\n  const out = {};\n  Object.keys(metadata).forEach((key) => {\n    if (key === \"metadata\" && typeof metadata[key] === \"object\" && metadata.metadata) {\n      Object.entries(metadata.metadata).forEach(([metaKey, value]) => {\n        out[ATTR_PREFIX + \":metadata:\" + metaKey] = value;\n      });\n    } else if (key === \"input\" || typeof metadata[key] === \"object\") {\n      out[ATTR_PREFIX + \":\" + key] = JSON.stringify(metadata[key]);\n    } else {\n      out[ATTR_PREFIX + \":\" + key] = metadata[key];\n    }\n  });\n  return out;\n}\nfunction setCustomMetadataAttribute(key, value) {\n  const currentStep = getCurrentSpan();\n  if (!currentStep) {\n    return;\n  }\n  if (!currentStep.metadata) {\n    currentStep.metadata = {};\n  }\n  currentStep.metadata[key] = value;\n}\nfunction setCustomMetadataAttributes(values) {\n  const currentStep = getCurrentSpan();\n  if (!currentStep) {\n    return;\n  }\n  if (!currentStep.metadata) {\n    currentStep.metadata = {};\n  }\n  for (const [key, value] of Object.entries(values)) {\n    currentStep.metadata[key] = value;\n  }\n}\nfunction toDisplayPath(path) {\n  const pathPartRegex = /\\{([^\\,}]+),[^\\}]+\\}/g;\n  return Array.from(path.matchAll(pathPartRegex), (m) => m[1]).join(\" > \");\n}\nfunction getCurrentSpan() {\n  const step = spanMetadataAls.getStore();\n  if (!step) {\n    throw new Error(\"running outside step context\");\n  }\n  return step;\n}\nfunction buildPath(name, parentPath, labels) {\n  const stepType = labels && labels[\"genkit:type\"] ? `,t:${labels[\"genkit:type\"]}` : \"\";\n  return parentPath + `/{${name}${stepType}}`;\n}\nfunction recordPath(spanMeta, err) {\n  var _a, _b, _c, _d;\n  const path = spanMeta.path || \"\";\n  const decoratedPath = decoratePathWithSubtype(spanMeta);\n  const paths = Array.from(\n    ((_a = traceMetadataAls.getStore()) == null ? void 0 : _a.paths) || /* @__PURE__ */ new Set()\n  );\n  const status = err ? \"failure\" : \"success\";\n  if (!paths.some((p) => p.path.startsWith(path) && p.status === status)) {\n    const now = import_node_perf_hooks.performance.now();\n    const start = ((_b = traceMetadataAls.getStore()) == null ? void 0 : _b.timestamp) || now;\n    (_d = (_c = traceMetadataAls.getStore()) == null ? void 0 : _c.paths) == null ? void 0 : _d.add({\n      path: decoratedPath,\n      error: err == null ? void 0 : err.name,\n      latency: now - start,\n      status\n    });\n  }\n  spanMeta.path = decoratedPath;\n}\nfunction decoratePathWithSubtype(metadata) {\n  var _a;\n  if (!metadata.path) {\n    return \"\";\n  }\n  const pathComponents = metadata.path.split(\"}/{\");\n  if (pathComponents.length == 1) {\n    return metadata.path;\n  }\n  const stepSubtype = metadata.metadata && metadata.metadata[\"subtype\"] ? `,s:${metadata.metadata[\"subtype\"]}` : \"\";\n  const root = `${pathComponents.slice(0, -1).join(\"}/{\")}}/`;\n  const decoratedStep = `{${(_a = pathComponents.at(-1)) == null ? void 0 : _a.slice(0, -1)}${stepSubtype}}`;\n  return root + decoratedStep;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvaW5zdHJ1bWVudGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxpR0FBb0I7QUFDN0MsOEJBQThCLG1CQUFPLENBQUMsMENBQWtCO0FBQ3hELDZCQUE2QixtQkFBTyxDQUFDLHdDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sUUFBUSxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNCQUFzQjtBQUNqRix5QkFBeUIsRUFBRSxLQUFLLEVBQUUsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkJBQTZCO0FBQzdHLGtCQUFrQixtQ0FBbUMsRUFBRSxJQUFJO0FBQzNELDBCQUEwQixFQUFFLGdFQUFnRSxFQUFFLGFBQWE7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVVMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi90cmFjaW5nL2luc3RydW1lbnRhdGlvbi5qcz8yYWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgaW5zdHJ1bWVudGF0aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluc3RydW1lbnRhdGlvbl9leHBvcnRzLCB7XG4gIEFUVFJfUFJFRklYOiAoKSA9PiBBVFRSX1BSRUZJWCxcbiAgU1BBTl9UWVBFX0FUVFI6ICgpID0+IFNQQU5fVFlQRV9BVFRSLFxuICBuZXdUcmFjZTogKCkgPT4gbmV3VHJhY2UsXG4gIHJ1bkluTmV3U3BhbjogKCkgPT4gcnVuSW5OZXdTcGFuLFxuICBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZTogKCkgPT4gc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGUsXG4gIHNldEN1c3RvbU1ldGFkYXRhQXR0cmlidXRlczogKCkgPT4gc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGVzLFxuICBzcGFuTWV0YWRhdGFBbHM6ICgpID0+IHNwYW5NZXRhZGF0YUFscyxcbiAgdG9EaXNwbGF5UGF0aDogKCkgPT4gdG9EaXNwbGF5UGF0aCxcbiAgdHJhY2VNZXRhZGF0YUFsczogKCkgPT4gdHJhY2VNZXRhZGF0YUFsc1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbnN0cnVtZW50YXRpb25fZXhwb3J0cyk7XG52YXIgaW1wb3J0X2FwaSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG52YXIgaW1wb3J0X25vZGVfYXN5bmNfaG9va3MgPSByZXF1aXJlKFwibm9kZTphc3luY19ob29rc1wiKTtcbnZhciBpbXBvcnRfbm9kZV9wZXJmX2hvb2tzID0gcmVxdWlyZShcIm5vZGU6cGVyZl9ob29rc1wiKTtcbmNvbnN0IHNwYW5NZXRhZGF0YUFscyA9IG5ldyBpbXBvcnRfbm9kZV9hc3luY19ob29rcy5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuY29uc3QgdHJhY2VNZXRhZGF0YUFscyA9IG5ldyBpbXBvcnRfbm9kZV9hc3luY19ob29rcy5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuY29uc3QgQVRUUl9QUkVGSVggPSBcImdlbmtpdFwiO1xuY29uc3QgU1BBTl9UWVBFX0FUVFIgPSBBVFRSX1BSRUZJWCArIFwiOnR5cGVcIjtcbmNvbnN0IFRSQUNFUl9OQU1FID0gXCJnZW5raXQtdHJhY2VyXCI7XG5jb25zdCBUUkFDRVJfVkVSU0lPTiA9IFwidjFcIjtcbmZ1bmN0aW9uIG5ld1RyYWNlKG9wdHMsIGZuKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgaXNSb290ID0gdHJhY2VNZXRhZGF0YUFscy5nZXRTdG9yZSgpID8gZmFsc2UgOiB0cnVlO1xuICAgIGNvbnN0IHRyYWNlTWV0YWRhdGEgPSB0cmFjZU1ldGFkYXRhQWxzLmdldFN0b3JlKCkgfHwge1xuICAgICAgcGF0aHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICB0aW1lc3RhbXA6IGltcG9ydF9ub2RlX3BlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KClcbiAgICB9O1xuICAgIGlmIChvcHRzLmxhYmVscyAmJiBvcHRzLmxhYmVsc1tTUEFOX1RZUEVfQVRUUl0gPT09IFwiZmxvd1wiKSB7XG4gICAgICB0cmFjZU1ldGFkYXRhLmZsb3dOYW1lID0gb3B0cy5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4geWllbGQgdHJhY2VNZXRhZGF0YUFscy5ydW4oXG4gICAgICB0cmFjZU1ldGFkYXRhLFxuICAgICAgKCkgPT4gcnVuSW5OZXdTcGFuKFxuICAgICAgICB7XG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgICAgIGlzUm9vdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGFiZWxzOiBvcHRzLmxhYmVscyxcbiAgICAgICAgICBsaW5rczogb3B0cy5saW5rc1xuICAgICAgICB9LFxuICAgICAgICAobWV0YWRhdGEsIG90U3BhbikgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJldHVybiB5aWVsZCBmbihtZXRhZGF0YSwgb3RTcGFuKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkluTmV3U3BhbihvcHRzLCBmbikge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHRyYWNlciA9IGltcG9ydF9hcGkudHJhY2UuZ2V0VHJhY2VyKFRSQUNFUl9OQU1FLCBUUkFDRVJfVkVSU0lPTik7XG4gICAgY29uc3QgcGFyZW50U3RlcCA9IHNwYW5NZXRhZGF0YUFscy5nZXRTdG9yZSgpO1xuICAgIGNvbnN0IGlzSW5Sb290ID0gKHBhcmVudFN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFN0ZXAuaXNSb290KSA9PT0gdHJ1ZTtcbiAgICByZXR1cm4geWllbGQgdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcbiAgICAgIG9wdHMubWV0YWRhdGEubmFtZSxcbiAgICAgIHsgbGlua3M6IG9wdHMubGlua3MsIHJvb3Q6IG9wdHMubWV0YWRhdGEuaXNSb290IH0sXG4gICAgICAob3RTcGFuKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChvcHRzLmxhYmVscylcbiAgICAgICAgICBvdFNwYW4uc2V0QXR0cmlidXRlcyhvcHRzLmxhYmVscyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cy5tZXRhZGF0YS5wYXRoID0gYnVpbGRQYXRoKFxuICAgICAgICAgICAgb3B0cy5tZXRhZGF0YS5uYW1lLFxuICAgICAgICAgICAgKHBhcmVudFN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFN0ZXAucGF0aCkgfHwgXCJcIixcbiAgICAgICAgICAgIG9wdHMubGFiZWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSB5aWVsZCBzcGFuTWV0YWRhdGFBbHMucnVuKFxuICAgICAgICAgICAgb3B0cy5tZXRhZGF0YSxcbiAgICAgICAgICAgICgpID0+IGZuKG9wdHMubWV0YWRhdGEsIG90U3BhbiwgaXNJblJvb3QpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob3B0cy5tZXRhZGF0YS5zdGF0ZSAhPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBvcHRzLm1ldGFkYXRhLnN0YXRlID0gXCJzdWNjZXNzXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlY29yZFBhdGgob3B0cy5tZXRhZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlY29yZFBhdGgob3B0cy5tZXRhZGF0YSwgZSk7XG4gICAgICAgICAgb3B0cy5tZXRhZGF0YS5zdGF0ZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgICBvdFNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IGltcG9ydF9hcGkuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UoZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBvdFNwYW4ucmVjb3JkRXhjZXB0aW9uKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIG90U3Bhbi5zZXRBdHRyaWJ1dGVzKG1ldGFkYXRhVG9BdHRyaWJ1dGVzKG9wdHMubWV0YWRhdGEpKTtcbiAgICAgICAgICBvdFNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGUubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYCR7ZX1gO1xufVxuZnVuY3Rpb24gbWV0YWRhdGFUb0F0dHJpYnV0ZXMobWV0YWRhdGEpIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIm1ldGFkYXRhXCIgJiYgdHlwZW9mIG1ldGFkYXRhW2tleV0gPT09IFwib2JqZWN0XCIgJiYgbWV0YWRhdGEubWV0YWRhdGEpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLm1ldGFkYXRhKS5mb3JFYWNoKChbbWV0YUtleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIG91dFtBVFRSX1BSRUZJWCArIFwiOm1ldGFkYXRhOlwiICsgbWV0YUtleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImlucHV0XCIgfHwgdHlwZW9mIG1ldGFkYXRhW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG91dFtBVFRSX1BSRUZJWCArIFwiOlwiICsga2V5XSA9IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbQVRUUl9QUkVGSVggKyBcIjpcIiArIGtleV0gPSBtZXRhZGF0YVtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gIGNvbnN0IGN1cnJlbnRTdGVwID0gZ2V0Q3VycmVudFNwYW4oKTtcbiAgaWYgKCFjdXJyZW50U3RlcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWN1cnJlbnRTdGVwLm1ldGFkYXRhKSB7XG4gICAgY3VycmVudFN0ZXAubWV0YWRhdGEgPSB7fTtcbiAgfVxuICBjdXJyZW50U3RlcC5tZXRhZGF0YVtrZXldID0gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZXModmFsdWVzKSB7XG4gIGNvbnN0IGN1cnJlbnRTdGVwID0gZ2V0Q3VycmVudFNwYW4oKTtcbiAgaWYgKCFjdXJyZW50U3RlcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWN1cnJlbnRTdGVwLm1ldGFkYXRhKSB7XG4gICAgY3VycmVudFN0ZXAubWV0YWRhdGEgPSB7fTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgY3VycmVudFN0ZXAubWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiB0b0Rpc3BsYXlQYXRoKHBhdGgpIHtcbiAgY29uc3QgcGF0aFBhcnRSZWdleCA9IC9cXHsoW15cXCx9XSspLFteXFx9XStcXH0vZztcbiAgcmV0dXJuIEFycmF5LmZyb20ocGF0aC5tYXRjaEFsbChwYXRoUGFydFJlZ2V4KSwgKG0pID0+IG1bMV0pLmpvaW4oXCIgPiBcIik7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U3BhbigpIHtcbiAgY29uc3Qgc3RlcCA9IHNwYW5NZXRhZGF0YUFscy5nZXRTdG9yZSgpO1xuICBpZiAoIXN0ZXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJydW5uaW5nIG91dHNpZGUgc3RlcCBjb250ZXh0XCIpO1xuICB9XG4gIHJldHVybiBzdGVwO1xufVxuZnVuY3Rpb24gYnVpbGRQYXRoKG5hbWUsIHBhcmVudFBhdGgsIGxhYmVscykge1xuICBjb25zdCBzdGVwVHlwZSA9IGxhYmVscyAmJiBsYWJlbHNbXCJnZW5raXQ6dHlwZVwiXSA/IGAsdDoke2xhYmVsc1tcImdlbmtpdDp0eXBlXCJdfWAgOiBcIlwiO1xuICByZXR1cm4gcGFyZW50UGF0aCArIGAveyR7bmFtZX0ke3N0ZXBUeXBlfX1gO1xufVxuZnVuY3Rpb24gcmVjb3JkUGF0aChzcGFuTWV0YSwgZXJyKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgcGF0aCA9IHNwYW5NZXRhLnBhdGggfHwgXCJcIjtcbiAgY29uc3QgZGVjb3JhdGVkUGF0aCA9IGRlY29yYXRlUGF0aFdpdGhTdWJ0eXBlKHNwYW5NZXRhKTtcbiAgY29uc3QgcGF0aHMgPSBBcnJheS5mcm9tKFxuICAgICgoX2EgPSB0cmFjZU1ldGFkYXRhQWxzLmdldFN0b3JlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wYXRocykgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICApO1xuICBjb25zdCBzdGF0dXMgPSBlcnIgPyBcImZhaWx1cmVcIiA6IFwic3VjY2Vzc1wiO1xuICBpZiAoIXBhdGhzLnNvbWUoKHApID0+IHAucGF0aC5zdGFydHNXaXRoKHBhdGgpICYmIHAuc3RhdHVzID09PSBzdGF0dXMpKSB7XG4gICAgY29uc3Qgbm93ID0gaW1wb3J0X25vZGVfcGVyZl9ob29rcy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydCA9ICgoX2IgPSB0cmFjZU1ldGFkYXRhQWxzLmdldFN0b3JlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYi50aW1lc3RhbXApIHx8IG5vdztcbiAgICAoX2QgPSAoX2MgPSB0cmFjZU1ldGFkYXRhQWxzLmdldFN0b3JlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wYXRocykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFkZCh7XG4gICAgICBwYXRoOiBkZWNvcmF0ZWRQYXRoLFxuICAgICAgZXJyb3I6IGVyciA9PSBudWxsID8gdm9pZCAwIDogZXJyLm5hbWUsXG4gICAgICBsYXRlbmN5OiBub3cgLSBzdGFydCxcbiAgICAgIHN0YXR1c1xuICAgIH0pO1xuICB9XG4gIHNwYW5NZXRhLnBhdGggPSBkZWNvcmF0ZWRQYXRoO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVQYXRoV2l0aFN1YnR5cGUobWV0YWRhdGEpIHtcbiAgdmFyIF9hO1xuICBpZiAoIW1ldGFkYXRhLnBhdGgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IG1ldGFkYXRhLnBhdGguc3BsaXQoXCJ9L3tcIik7XG4gIGlmIChwYXRoQ29tcG9uZW50cy5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBtZXRhZGF0YS5wYXRoO1xuICB9XG4gIGNvbnN0IHN0ZXBTdWJ0eXBlID0gbWV0YWRhdGEubWV0YWRhdGEgJiYgbWV0YWRhdGEubWV0YWRhdGFbXCJzdWJ0eXBlXCJdID8gYCxzOiR7bWV0YWRhdGEubWV0YWRhdGFbXCJzdWJ0eXBlXCJdfWAgOiBcIlwiO1xuICBjb25zdCByb290ID0gYCR7cGF0aENvbXBvbmVudHMuc2xpY2UoMCwgLTEpLmpvaW4oXCJ9L3tcIil9fS9gO1xuICBjb25zdCBkZWNvcmF0ZWRTdGVwID0gYHskeyhfYSA9IHBhdGhDb21wb25lbnRzLmF0KC0xKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNsaWNlKDAsIC0xKX0ke3N0ZXBTdWJ0eXBlfX1gO1xuICByZXR1cm4gcm9vdCArIGRlY29yYXRlZFN0ZXA7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQVRUUl9QUkVGSVgsXG4gIFNQQU5fVFlQRV9BVFRSLFxuICBuZXdUcmFjZSxcbiAgcnVuSW5OZXdTcGFuLFxuICBzZXRDdXN0b21NZXRhZGF0YUF0dHJpYnV0ZSxcbiAgc2V0Q3VzdG9tTWV0YWRhdGFBdHRyaWJ1dGVzLFxuICBzcGFuTWV0YWRhdGFBbHMsXG4gIHRvRGlzcGxheVBhdGgsXG4gIHRyYWNlTWV0YWRhdGFBbHNcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdHJ1bWVudGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/localFileTraceStore.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/localFileTraceStore.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar localFileTraceStore_exports = {};\n__export(localFileTraceStore_exports, {\n  LocalFileTraceStore: () => LocalFileTraceStore\n});\nmodule.exports = __toCommonJS(localFileTraceStore_exports);\nvar import_async_mutex = __webpack_require__(/*! async-mutex */ \"(action-browser)/./node_modules/async-mutex/lib/index.js\");\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_fs = __toESM(__webpack_require__(/*! fs */ \"fs\"));\nvar import_os = __toESM(__webpack_require__(/*! os */ \"os\"));\nvar import_path = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_logging = __webpack_require__(/*! ../logging.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/logging.js\");\nvar import_types = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js\");\nconst _LocalFileTraceStore = class _LocalFileTraceStore {\n  constructor(filters = _LocalFileTraceStore.defaultFilters) {\n    this.mutexes = {};\n    var _a;\n    const rootHash = import_crypto.default.createHash(\"md5\").update(((_a = __webpack_require__(\"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing sync recursive\") == null ? void 0 : __webpack_require__.c[__webpack_require__.s]) == null ? void 0 : _a.filename) || \"unknown\").digest(\"hex\");\n    this.storeRoot = import_path.default.resolve(import_os.default.tmpdir(), `.genkit/${rootHash}/traces`);\n    import_fs.default.mkdirSync(this.storeRoot, { recursive: true });\n    import_logging.logger.info(\n      `Initialized local file trace store at root: ${this.storeRoot}`\n    );\n    this.filters = filters;\n  }\n  load(id) {\n    return __async(this, null, function* () {\n      const filePath = import_path.default.resolve(this.storeRoot, `${id}`);\n      if (!import_fs.default.existsSync(filePath)) {\n        return void 0;\n      }\n      const data = import_fs.default.readFileSync(filePath, \"utf8\");\n      const parsed = JSON.parse(data);\n      if (!parsed.traceId) {\n        parsed.traceId = id;\n      }\n      return import_types.TraceDataSchema.parse(parsed);\n    });\n  }\n  getMutex(id) {\n    if (!this.mutexes[id]) {\n      this.mutexes[id] = new import_async_mutex.Mutex();\n    }\n    return this.mutexes[id];\n  }\n  save(id, rawTrace) {\n    return __async(this, null, function* () {\n      let trace = this.filter(rawTrace);\n      if (Object.keys(trace.spans).length === 0) {\n        return;\n      }\n      const mutex = this.getMutex(id);\n      yield mutex.waitForUnlock();\n      const release = yield mutex.acquire();\n      try {\n        const existing = yield this.load(id);\n        if (existing) {\n          Object.keys(trace.spans).forEach(\n            (spanId) => existing.spans[spanId] = trace.spans[spanId]\n          );\n          existing.displayName = trace.displayName;\n          existing.startTime = trace.startTime;\n          existing.endTime = trace.endTime;\n          trace = existing;\n        }\n        import_fs.default.writeFileSync(\n          import_path.default.resolve(this.storeRoot, `${id}`),\n          JSON.stringify(trace)\n        );\n      } finally {\n        release();\n      }\n    });\n  }\n  list(query) {\n    return __async(this, null, function* () {\n      const files = import_fs.default.readdirSync(this.storeRoot);\n      files.sort((a, b) => {\n        return import_fs.default.statSync(import_path.default.resolve(this.storeRoot, `${b}`)).mtime.getTime() - import_fs.default.statSync(import_path.default.resolve(this.storeRoot, `${a}`)).mtime.getTime();\n      });\n      const startFrom = (query == null ? void 0 : query.continuationToken) ? parseInt(query == null ? void 0 : query.continuationToken) : 0;\n      const stopAt = startFrom + ((query == null ? void 0 : query.limit) || 10);\n      const traces = files.slice(startFrom, stopAt).map((id) => {\n        const filePath = import_path.default.resolve(this.storeRoot, `${id}`);\n        const data = import_fs.default.readFileSync(filePath, \"utf8\");\n        const parsed = JSON.parse(data);\n        if (!parsed.traceId) {\n          parsed.traceId = id;\n        }\n        return import_types.TraceDataSchema.parse(parsed);\n      });\n      return {\n        traces,\n        continuationToken: files.length > stopAt ? stopAt.toString() : void 0\n      };\n    });\n  }\n  filter(trace) {\n    Object.keys(trace.spans).forEach((spanId) => {\n      const span = trace.spans[spanId];\n      Object.keys(this.filters).forEach((f) => {\n        if (span.attributes[f] === this.filters[f]) {\n          delete trace.spans[spanId];\n        }\n      });\n    });\n    if (Object.keys(trace.spans).length === 1) {\n      Object.keys(trace.spans).forEach((spanId) => {\n        const span = trace.spans[spanId];\n        if (span.attributes[\"genkit:name\"] === \"dev-run-action-wrapper\") {\n          delete trace.spans[spanId];\n        }\n      });\n    }\n    return trace;\n  }\n};\n_LocalFileTraceStore.defaultFilters = {\n  // Prevent prompt rendering from spamming local trace store\n  \"genkit:metadata:subtype\": \"prompt\"\n};\nlet LocalFileTraceStore = _LocalFileTraceStore;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=localFileTraceStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvbG9jYWxGaWxlVHJhY2VTdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsNkVBQWE7QUFDOUMsNEJBQTRCLG1CQUFPLENBQUMsc0JBQVE7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsY0FBSTtBQUNwQyx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDLDBCQUEwQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLHFGQUFlO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGlHQUFPLG9CQUFvQiw0Q0FBWTtBQUNsSCx3RkFBd0YsU0FBUztBQUNqRyxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0EscURBQXFELGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxHQUFHO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxHQUFHO0FBQzVEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLEVBQUUsZ0dBQWdHLEVBQUU7QUFDN0wsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxHQUFHO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvbG9jYWxGaWxlVHJhY2VTdG9yZS5qcz9mZTE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgbG9jYWxGaWxlVHJhY2VTdG9yZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChsb2NhbEZpbGVUcmFjZVN0b3JlX2V4cG9ydHMsIHtcbiAgTG9jYWxGaWxlVHJhY2VTdG9yZTogKCkgPT4gTG9jYWxGaWxlVHJhY2VTdG9yZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhsb2NhbEZpbGVUcmFjZVN0b3JlX2V4cG9ydHMpO1xudmFyIGltcG9ydF9hc3luY19tdXRleCA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbnZhciBpbXBvcnRfY3J5cHRvID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfZnMgPSBfX3RvRVNNKHJlcXVpcmUoXCJmc1wiKSk7XG52YXIgaW1wb3J0X29zID0gX190b0VTTShyZXF1aXJlKFwib3NcIikpO1xudmFyIGltcG9ydF9wYXRoID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgaW1wb3J0X2xvZ2dpbmcgPSByZXF1aXJlKFwiLi4vbG9nZ2luZy5qc1wiKTtcbnZhciBpbXBvcnRfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlcy5qc1wiKTtcbmNvbnN0IF9Mb2NhbEZpbGVUcmFjZVN0b3JlID0gY2xhc3MgX0xvY2FsRmlsZVRyYWNlU3RvcmUge1xuICBjb25zdHJ1Y3RvcihmaWx0ZXJzID0gX0xvY2FsRmlsZVRyYWNlU3RvcmUuZGVmYXVsdEZpbHRlcnMpIHtcbiAgICB0aGlzLm11dGV4ZXMgPSB7fTtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgcm9vdEhhc2ggPSBpbXBvcnRfY3J5cHRvLmRlZmF1bHQuY3JlYXRlSGFzaChcIm1kNVwiKS51cGRhdGUoKChfYSA9IHJlcXVpcmUgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcXVpcmUubWFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSB8fCBcInVua25vd25cIikuZGlnZXN0KFwiaGV4XCIpO1xuICAgIHRoaXMuc3RvcmVSb290ID0gaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKGltcG9ydF9vcy5kZWZhdWx0LnRtcGRpcigpLCBgLmdlbmtpdC8ke3Jvb3RIYXNofS90cmFjZXNgKTtcbiAgICBpbXBvcnRfZnMuZGVmYXVsdC5ta2RpclN5bmModGhpcy5zdG9yZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGltcG9ydF9sb2dnaW5nLmxvZ2dlci5pbmZvKFxuICAgICAgYEluaXRpYWxpemVkIGxvY2FsIGZpbGUgdHJhY2Ugc3RvcmUgYXQgcm9vdDogJHt0aGlzLnN0b3JlUm9vdH1gXG4gICAgKTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICB9XG4gIGxvYWQoaWQpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5zdG9yZVJvb3QsIGAke2lkfWApO1xuICAgICAgaWYgKCFpbXBvcnRfZnMuZGVmYXVsdC5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGltcG9ydF9mcy5kZWZhdWx0LnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGY4XCIpO1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGlmICghcGFyc2VkLnRyYWNlSWQpIHtcbiAgICAgICAgcGFyc2VkLnRyYWNlSWQgPSBpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbXBvcnRfdHlwZXMuVHJhY2VEYXRhU2NoZW1hLnBhcnNlKHBhcnNlZCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0TXV0ZXgoaWQpIHtcbiAgICBpZiAoIXRoaXMubXV0ZXhlc1tpZF0pIHtcbiAgICAgIHRoaXMubXV0ZXhlc1tpZF0gPSBuZXcgaW1wb3J0X2FzeW5jX211dGV4Lk11dGV4KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm11dGV4ZXNbaWRdO1xuICB9XG4gIHNhdmUoaWQsIHJhd1RyYWNlKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCB0cmFjZSA9IHRoaXMuZmlsdGVyKHJhd1RyYWNlKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0cmFjZS5zcGFucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG11dGV4ID0gdGhpcy5nZXRNdXRleChpZCk7XG4gICAgICB5aWVsZCBtdXRleC53YWl0Rm9yVW5sb2NrKCk7XG4gICAgICBjb25zdCByZWxlYXNlID0geWllbGQgbXV0ZXguYWNxdWlyZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB5aWVsZCB0aGlzLmxvYWQoaWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0cmFjZS5zcGFucykuZm9yRWFjaChcbiAgICAgICAgICAgIChzcGFuSWQpID0+IGV4aXN0aW5nLnNwYW5zW3NwYW5JZF0gPSB0cmFjZS5zcGFuc1tzcGFuSWRdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBleGlzdGluZy5kaXNwbGF5TmFtZSA9IHRyYWNlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIGV4aXN0aW5nLnN0YXJ0VGltZSA9IHRyYWNlLnN0YXJ0VGltZTtcbiAgICAgICAgICBleGlzdGluZy5lbmRUaW1lID0gdHJhY2UuZW5kVGltZTtcbiAgICAgICAgICB0cmFjZSA9IGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGltcG9ydF9mcy5kZWZhdWx0LndyaXRlRmlsZVN5bmMoXG4gICAgICAgICAgaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKHRoaXMuc3RvcmVSb290LCBgJHtpZH1gKSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0cmFjZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlbGVhc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsaXN0KHF1ZXJ5KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gaW1wb3J0X2ZzLmRlZmF1bHQucmVhZGRpclN5bmModGhpcy5zdG9yZVJvb3QpO1xuICAgICAgZmlsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gaW1wb3J0X2ZzLmRlZmF1bHQuc3RhdFN5bmMoaW1wb3J0X3BhdGguZGVmYXVsdC5yZXNvbHZlKHRoaXMuc3RvcmVSb290LCBgJHtifWApKS5tdGltZS5nZXRUaW1lKCkgLSBpbXBvcnRfZnMuZGVmYXVsdC5zdGF0U3luYyhpbXBvcnRfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5zdG9yZVJvb3QsIGAke2F9YCkpLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhcnRGcm9tID0gKHF1ZXJ5ID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeS5jb250aW51YXRpb25Ub2tlbikgPyBwYXJzZUludChxdWVyeSA9PSBudWxsID8gdm9pZCAwIDogcXVlcnkuY29udGludWF0aW9uVG9rZW4pIDogMDtcbiAgICAgIGNvbnN0IHN0b3BBdCA9IHN0YXJ0RnJvbSArICgocXVlcnkgPT0gbnVsbCA/IHZvaWQgMCA6IHF1ZXJ5LmxpbWl0KSB8fCAxMCk7XG4gICAgICBjb25zdCB0cmFjZXMgPSBmaWxlcy5zbGljZShzdGFydEZyb20sIHN0b3BBdCkubWFwKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGltcG9ydF9wYXRoLmRlZmF1bHQucmVzb2x2ZSh0aGlzLnN0b3JlUm9vdCwgYCR7aWR9YCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbXBvcnRfZnMuZGVmYXVsdC5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgaWYgKCFwYXJzZWQudHJhY2VJZCkge1xuICAgICAgICAgIHBhcnNlZC50cmFjZUlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydF90eXBlcy5UcmFjZURhdGFTY2hlbWEucGFyc2UocGFyc2VkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2VzLFxuICAgICAgICBjb250aW51YXRpb25Ub2tlbjogZmlsZXMubGVuZ3RoID4gc3RvcEF0ID8gc3RvcEF0LnRvU3RyaW5nKCkgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZmlsdGVyKHRyYWNlKSB7XG4gICAgT2JqZWN0LmtleXModHJhY2Uuc3BhbnMpLmZvckVhY2goKHNwYW5JZCkgPT4ge1xuICAgICAgY29uc3Qgc3BhbiA9IHRyYWNlLnNwYW5zW3NwYW5JZF07XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmZpbHRlcnMpLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgaWYgKHNwYW4uYXR0cmlidXRlc1tmXSA9PT0gdGhpcy5maWx0ZXJzW2ZdKSB7XG4gICAgICAgICAgZGVsZXRlIHRyYWNlLnNwYW5zW3NwYW5JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh0cmFjZS5zcGFucykubGVuZ3RoID09PSAxKSB7XG4gICAgICBPYmplY3Qua2V5cyh0cmFjZS5zcGFucykuZm9yRWFjaCgoc3BhbklkKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0cmFjZS5zcGFuc1tzcGFuSWRdO1xuICAgICAgICBpZiAoc3Bhbi5hdHRyaWJ1dGVzW1wiZ2Vua2l0Om5hbWVcIl0gPT09IFwiZGV2LXJ1bi1hY3Rpb24td3JhcHBlclwiKSB7XG4gICAgICAgICAgZGVsZXRlIHRyYWNlLnNwYW5zW3NwYW5JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2U7XG4gIH1cbn07XG5fTG9jYWxGaWxlVHJhY2VTdG9yZS5kZWZhdWx0RmlsdGVycyA9IHtcbiAgLy8gUHJldmVudCBwcm9tcHQgcmVuZGVyaW5nIGZyb20gc3BhbW1pbmcgbG9jYWwgdHJhY2Ugc3RvcmVcbiAgXCJnZW5raXQ6bWV0YWRhdGE6c3VidHlwZVwiOiBcInByb21wdFwiXG59O1xubGV0IExvY2FsRmlsZVRyYWNlU3RvcmUgPSBfTG9jYWxGaWxlVHJhY2VTdG9yZTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBMb2NhbEZpbGVUcmFjZVN0b3JlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsRmlsZVRyYWNlU3RvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/localFileTraceStore.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/multiSpanProcessor.js":
/*!************************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/multiSpanProcessor.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar multiSpanProcessor_exports = {};\n__export(multiSpanProcessor_exports, {\n  MultiSpanProcessor: () => MultiSpanProcessor\n});\nmodule.exports = __toCommonJS(multiSpanProcessor_exports);\nclass MultiSpanProcessor {\n  constructor(processors) {\n    this.processors = processors;\n  }\n  forceFlush() {\n    return Promise.all(this.processors.map((p) => p.forceFlush())).then();\n  }\n  onStart(span, parentContext) {\n    this.processors.map((p) => p.onStart(span, parentContext));\n  }\n  onEnd(span) {\n    this.processors.map((p) => p.onEnd(span));\n  }\n  shutdown() {\n    return __async(this, null, function* () {\n      return Promise.all(this.processors.map((p) => p.shutdown())).then();\n    });\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=multiSpanProcessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvbXVsdGlTcGFuUHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FFTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvdHJhY2luZy9tdWx0aVNwYW5Qcm9jZXNzb3IuanM/NmRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIG11bHRpU3BhblByb2Nlc3Nvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChtdWx0aVNwYW5Qcm9jZXNzb3JfZXhwb3J0cywge1xuICBNdWx0aVNwYW5Qcm9jZXNzb3I6ICgpID0+IE11bHRpU3BhblByb2Nlc3NvclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhtdWx0aVNwYW5Qcm9jZXNzb3JfZXhwb3J0cyk7XG5jbGFzcyBNdWx0aVNwYW5Qcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3JzKSB7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gcHJvY2Vzc29ycztcbiAgfVxuICBmb3JjZUZsdXNoKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnByb2Nlc3NvcnMubWFwKChwKSA9PiBwLmZvcmNlRmx1c2goKSkpLnRoZW4oKTtcbiAgfVxuICBvblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnByb2Nlc3NvcnMubWFwKChwKSA9PiBwLm9uU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkpO1xuICB9XG4gIG9uRW5kKHNwYW4pIHtcbiAgICB0aGlzLnByb2Nlc3NvcnMubWFwKChwKSA9PiBwLm9uRW5kKHNwYW4pKTtcbiAgfVxuICBzaHV0ZG93bigpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMucHJvY2Vzc29ycy5tYXAoKHApID0+IHAuc2h1dGRvd24oKSkpLnRoZW4oKTtcbiAgICB9KTtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIE11bHRpU3BhblByb2Nlc3NvclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aVNwYW5Qcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/multiSpanProcessor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/processor.js":
/*!***************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/processor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar processor_exports = {};\n__export(processor_exports, {\n  GenkitSpanProcessorWrapper: () => GenkitSpanProcessorWrapper\n});\nmodule.exports = __toCommonJS(processor_exports);\nvar import_instrumentation = __webpack_require__(/*! ./instrumentation.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/instrumentation.js\");\nclass GenkitSpanProcessorWrapper {\n  constructor(processor) {\n    this.processor = processor;\n  }\n  forceFlush() {\n    return this.processor.forceFlush();\n  }\n  onStart(span, parentContext) {\n    return this.processor.onStart(span, parentContext);\n  }\n  onEnd(span) {\n    if (Object.keys(span.attributes).find((k) => k.startsWith(import_instrumentation.ATTR_PREFIX + \":\"))) {\n      return this.processor.onEnd(new FilteringReadableSpanProxy(span));\n    } else {\n      return this.processor.onEnd(span);\n    }\n  }\n  shutdown() {\n    return __async(this, null, function* () {\n      return this.processor.shutdown();\n    });\n  }\n}\nclass FilteringReadableSpanProxy {\n  constructor(span) {\n    this.span = span;\n  }\n  get name() {\n    return this.span.name;\n  }\n  get kind() {\n    return this.span.kind;\n  }\n  get parentSpanId() {\n    return this.span.parentSpanId;\n  }\n  get startTime() {\n    return this.span.startTime;\n  }\n  get endTime() {\n    return this.span.endTime;\n  }\n  get status() {\n    return this.span.status;\n  }\n  get attributes() {\n    console.log(\n      \"FilteringReadableSpanProxy get attributes\",\n      this.span.attributes\n    );\n    const out = {};\n    for (const [key, value] of Object.entries(this.span.attributes)) {\n      if (!key.startsWith(import_instrumentation.ATTR_PREFIX + \":\")) {\n        out[key] = value;\n      }\n    }\n    return out;\n  }\n  get links() {\n    return this.span.links;\n  }\n  get events() {\n    return this.span.events;\n  }\n  get duration() {\n    return this.span.duration;\n  }\n  get ended() {\n    return this.span.ended;\n  }\n  get resource() {\n    return this.span.resource;\n  }\n  get instrumentationLibrary() {\n    return this.span.instrumentationLibrary;\n  }\n  get droppedAttributesCount() {\n    return this.span.droppedAttributesCount;\n  }\n  get droppedEventsCount() {\n    return this.span.droppedEventsCount;\n  }\n  get droppedLinksCount() {\n    return this.span.droppedLinksCount;\n  }\n  spanContext() {\n    return this.span.spanContext();\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLDRHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi90cmFjaW5nL3Byb2Nlc3Nvci5qcz84ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgcHJvY2Vzc29yX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHByb2Nlc3Nvcl9leHBvcnRzLCB7XG4gIEdlbmtpdFNwYW5Qcm9jZXNzb3JXcmFwcGVyOiAoKSA9PiBHZW5raXRTcGFuUHJvY2Vzc29yV3JhcHBlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhwcm9jZXNzb3JfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2luc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoXCIuL2luc3RydW1lbnRhdGlvbi5qc1wiKTtcbmNsYXNzIEdlbmtpdFNwYW5Qcm9jZXNzb3JXcmFwcGVyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gIH1cbiAgZm9yY2VGbHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3IuZm9yY2VGbHVzaCgpO1xuICB9XG4gIG9uU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3Nvci5vblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpO1xuICB9XG4gIG9uRW5kKHNwYW4pIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoc3Bhbi5hdHRyaWJ1dGVzKS5maW5kKChrKSA9PiBrLnN0YXJ0c1dpdGgoaW1wb3J0X2luc3RydW1lbnRhdGlvbi5BVFRSX1BSRUZJWCArIFwiOlwiKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3Nvci5vbkVuZChuZXcgRmlsdGVyaW5nUmVhZGFibGVTcGFuUHJveHkoc3BhbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3Iub25FbmQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHNodXRkb3duKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3Iuc2h1dGRvd24oKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRmlsdGVyaW5nUmVhZGFibGVTcGFuUHJveHkge1xuICBjb25zdHJ1Y3RvcihzcGFuKSB7XG4gICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLm5hbWU7XG4gIH1cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5raW5kO1xuICB9XG4gIGdldCBwYXJlbnRTcGFuSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5wYXJlbnRTcGFuSWQ7XG4gIH1cbiAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLnN0YXJ0VGltZTtcbiAgfVxuICBnZXQgZW5kVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLmVuZFRpbWU7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLnN0YXR1cztcbiAgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiRmlsdGVyaW5nUmVhZGFibGVTcGFuUHJveHkgZ2V0IGF0dHJpYnV0ZXNcIixcbiAgICAgIHRoaXMuc3Bhbi5hdHRyaWJ1dGVzXG4gICAgKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnNwYW4uYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoaW1wb3J0X2luc3RydW1lbnRhdGlvbi5BVFRSX1BSRUZJWCArIFwiOlwiKSkge1xuICAgICAgICBvdXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGdldCBsaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLmxpbmtzO1xuICB9XG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5ldmVudHM7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uZHVyYXRpb247XG4gIH1cbiAgZ2V0IGVuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uZW5kZWQ7XG4gIH1cbiAgZ2V0IHJlc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4ucmVzb3VyY2U7XG4gIH1cbiAgZ2V0IGluc3RydW1lbnRhdGlvbkxpYnJhcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5pbnN0cnVtZW50YXRpb25MaWJyYXJ5O1xuICB9XG4gIGdldCBkcm9wcGVkQXR0cmlidXRlc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDtcbiAgfVxuICBnZXQgZHJvcHBlZEV2ZW50c0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uZHJvcHBlZEV2ZW50c0NvdW50O1xuICB9XG4gIGdldCBkcm9wcGVkTGlua3NDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLmRyb3BwZWRMaW5rc0NvdW50O1xuICB9XG4gIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uc3BhbkNvbnRleHQoKTtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdlbmtpdFNwYW5Qcm9jZXNzb3JXcmFwcGVyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/processor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/tracing/types.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar types_exports = {};\n__export(types_exports, {\n  InstrumentationLibrarySchema: () => InstrumentationLibrarySchema,\n  LinkSchema: () => LinkSchema,\n  PathMetadataSchema: () => PathMetadataSchema,\n  SpanContextSchema: () => SpanContextSchema,\n  SpanDataSchema: () => SpanDataSchema,\n  SpanMetadataSchema: () => SpanMetadataSchema,\n  SpanStatusSchema: () => SpanStatusSchema,\n  TimeEventSchema: () => TimeEventSchema,\n  TraceDataSchema: () => TraceDataSchema,\n  TraceMetadataSchema: () => TraceMetadataSchema\n});\nmodule.exports = __toCommonJS(types_exports);\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nconst PathMetadataSchema = import_zod.z.object({\n  path: import_zod.z.string(),\n  status: import_zod.z.string(),\n  error: import_zod.z.string().optional(),\n  latency: import_zod.z.number()\n});\nconst TraceMetadataSchema = import_zod.z.object({\n  flowName: import_zod.z.string().optional(),\n  paths: import_zod.z.set(PathMetadataSchema).optional(),\n  timestamp: import_zod.z.number()\n});\nconst SpanMetadataSchema = import_zod.z.object({\n  name: import_zod.z.string(),\n  state: import_zod.z.enum([\"success\", \"error\"]).optional(),\n  input: import_zod.z.any().optional(),\n  output: import_zod.z.any().optional(),\n  isRoot: import_zod.z.boolean().optional(),\n  metadata: import_zod.z.record(import_zod.z.string(), import_zod.z.string()).optional(),\n  path: import_zod.z.string().optional()\n});\nconst SpanStatusSchema = import_zod.z.object({\n  code: import_zod.z.number(),\n  message: import_zod.z.string().optional()\n});\nconst TimeEventSchema = import_zod.z.object({\n  time: import_zod.z.number(),\n  annotation: import_zod.z.object({\n    attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),\n    description: import_zod.z.string()\n  })\n});\nconst SpanContextSchema = import_zod.z.object({\n  traceId: import_zod.z.string(),\n  spanId: import_zod.z.string(),\n  isRemote: import_zod.z.boolean().optional(),\n  traceFlags: import_zod.z.number()\n});\nconst LinkSchema = import_zod.z.object({\n  context: SpanContextSchema.optional(),\n  attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()).optional(),\n  droppedAttributesCount: import_zod.z.number().optional()\n});\nconst InstrumentationLibrarySchema = import_zod.z.object({\n  name: import_zod.z.string().readonly(),\n  version: import_zod.z.string().optional().readonly(),\n  schemaUrl: import_zod.z.string().optional().readonly()\n});\nconst SpanDataSchema = import_zod.z.object({\n  spanId: import_zod.z.string(),\n  traceId: import_zod.z.string(),\n  parentSpanId: import_zod.z.string().optional(),\n  startTime: import_zod.z.number(),\n  endTime: import_zod.z.number(),\n  attributes: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),\n  displayName: import_zod.z.string(),\n  links: import_zod.z.array(LinkSchema).optional(),\n  instrumentationLibrary: InstrumentationLibrarySchema,\n  spanKind: import_zod.z.string(),\n  sameProcessAsParentSpan: import_zod.z.object({ value: import_zod.z.boolean() }).optional(),\n  status: SpanStatusSchema.optional(),\n  timeEvents: import_zod.z.object({\n    timeEvent: import_zod.z.array(TimeEventSchema)\n  }).optional(),\n  truncated: import_zod.z.boolean().optional()\n});\nconst TraceDataSchema = import_zod.z.object({\n  traceId: import_zod.z.string(),\n  displayName: import_zod.z.string().optional(),\n  startTime: import_zod.z.number().optional().describe(\"trace start time in milliseconds since the epoch\"),\n  endTime: import_zod.z.number().optional().describe(\"end time in milliseconds since the epoch\"),\n  spans: import_zod.z.record(import_zod.z.string(), SpanDataSchema)\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3RyYWNpbmcvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwREFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwrQkFBK0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sQ0FXTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvY29yZS9saWIvdHJhY2luZy90eXBlcy5qcz84OGUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEluc3RydW1lbnRhdGlvbkxpYnJhcnlTY2hlbWE6ICgpID0+IEluc3RydW1lbnRhdGlvbkxpYnJhcnlTY2hlbWEsXG4gIExpbmtTY2hlbWE6ICgpID0+IExpbmtTY2hlbWEsXG4gIFBhdGhNZXRhZGF0YVNjaGVtYTogKCkgPT4gUGF0aE1ldGFkYXRhU2NoZW1hLFxuICBTcGFuQ29udGV4dFNjaGVtYTogKCkgPT4gU3BhbkNvbnRleHRTY2hlbWEsXG4gIFNwYW5EYXRhU2NoZW1hOiAoKSA9PiBTcGFuRGF0YVNjaGVtYSxcbiAgU3Bhbk1ldGFkYXRhU2NoZW1hOiAoKSA9PiBTcGFuTWV0YWRhdGFTY2hlbWEsXG4gIFNwYW5TdGF0dXNTY2hlbWE6ICgpID0+IFNwYW5TdGF0dXNTY2hlbWEsXG4gIFRpbWVFdmVudFNjaGVtYTogKCkgPT4gVGltZUV2ZW50U2NoZW1hLFxuICBUcmFjZURhdGFTY2hlbWE6ICgpID0+IFRyYWNlRGF0YVNjaGVtYSxcbiAgVHJhY2VNZXRhZGF0YVNjaGVtYTogKCkgPT4gVHJhY2VNZXRhZGF0YVNjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh0eXBlc19leHBvcnRzKTtcbnZhciBpbXBvcnRfem9kID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IFBhdGhNZXRhZGF0YVNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBwYXRoOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIHN0YXR1czogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBlcnJvcjogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGxhdGVuY3k6IGltcG9ydF96b2Quei5udW1iZXIoKVxufSk7XG5jb25zdCBUcmFjZU1ldGFkYXRhU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIGZsb3dOYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcGF0aHM6IGltcG9ydF96b2Quei5zZXQoUGF0aE1ldGFkYXRhU2NoZW1hKS5vcHRpb25hbCgpLFxuICB0aW1lc3RhbXA6IGltcG9ydF96b2Quei5udW1iZXIoKVxufSk7XG5jb25zdCBTcGFuTWV0YWRhdGFTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgbmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBzdGF0ZTogaW1wb3J0X3pvZC56LmVudW0oW1wic3VjY2Vzc1wiLCBcImVycm9yXCJdKS5vcHRpb25hbCgpLFxuICBpbnB1dDogaW1wb3J0X3pvZC56LmFueSgpLm9wdGlvbmFsKCksXG4gIG91dHB1dDogaW1wb3J0X3pvZC56LmFueSgpLm9wdGlvbmFsKCksXG4gIGlzUm9vdDogaW1wb3J0X3pvZC56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBtZXRhZGF0YTogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouc3RyaW5nKCksIGltcG9ydF96b2Quei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgcGF0aDogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgU3BhblN0YXR1c1NjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBjb2RlOiBpbXBvcnRfem9kLnoubnVtYmVyKCksXG4gIG1lc3NhZ2U6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IFRpbWVFdmVudFNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICB0aW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCksXG4gIGFubm90YXRpb246IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICAgIGF0dHJpYnV0ZXM6IGltcG9ydF96b2Quei5yZWNvcmQoaW1wb3J0X3pvZC56LnN0cmluZygpLCBpbXBvcnRfem9kLnouYW55KCkpLFxuICAgIGRlc2NyaXB0aW9uOiBpbXBvcnRfem9kLnouc3RyaW5nKClcbiAgfSlcbn0pO1xuY29uc3QgU3BhbkNvbnRleHRTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgdHJhY2VJZDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBzcGFuSWQ6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgaXNSZW1vdGU6IGltcG9ydF96b2Quei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgdHJhY2VGbGFnczogaW1wb3J0X3pvZC56Lm51bWJlcigpXG59KTtcbmNvbnN0IExpbmtTY2hlbWEgPSBpbXBvcnRfem9kLnoub2JqZWN0KHtcbiAgY29udGV4dDogU3BhbkNvbnRleHRTY2hlbWEub3B0aW9uYWwoKSxcbiAgYXR0cmlidXRlczogaW1wb3J0X3pvZC56LnJlY29yZChpbXBvcnRfem9kLnouc3RyaW5nKCksIGltcG9ydF96b2Quei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDogaW1wb3J0X3pvZC56Lm51bWJlcigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgSW5zdHJ1bWVudGF0aW9uTGlicmFyeVNjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICBuYW1lOiBpbXBvcnRfem9kLnouc3RyaW5nKCkucmVhZG9ubHkoKSxcbiAgdmVyc2lvbjogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCkucmVhZG9ubHkoKSxcbiAgc2NoZW1hVXJsOiBpbXBvcnRfem9kLnouc3RyaW5nKCkub3B0aW9uYWwoKS5yZWFkb25seSgpXG59KTtcbmNvbnN0IFNwYW5EYXRhU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHNwYW5JZDogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICB0cmFjZUlkOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIHBhcmVudFNwYW5JZDogaW1wb3J0X3pvZC56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHN0YXJ0VGltZTogaW1wb3J0X3pvZC56Lm51bWJlcigpLFxuICBlbmRUaW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCksXG4gIGF0dHJpYnV0ZXM6IGltcG9ydF96b2Quei5yZWNvcmQoaW1wb3J0X3pvZC56LnN0cmluZygpLCBpbXBvcnRfem9kLnouYW55KCkpLFxuICBkaXNwbGF5TmFtZTogaW1wb3J0X3pvZC56LnN0cmluZygpLFxuICBsaW5rczogaW1wb3J0X3pvZC56LmFycmF5KExpbmtTY2hlbWEpLm9wdGlvbmFsKCksXG4gIGluc3RydW1lbnRhdGlvbkxpYnJhcnk6IEluc3RydW1lbnRhdGlvbkxpYnJhcnlTY2hlbWEsXG4gIHNwYW5LaW5kOiBpbXBvcnRfem9kLnouc3RyaW5nKCksXG4gIHNhbWVQcm9jZXNzQXNQYXJlbnRTcGFuOiBpbXBvcnRfem9kLnoub2JqZWN0KHsgdmFsdWU6IGltcG9ydF96b2Quei5ib29sZWFuKCkgfSkub3B0aW9uYWwoKSxcbiAgc3RhdHVzOiBTcGFuU3RhdHVzU2NoZW1hLm9wdGlvbmFsKCksXG4gIHRpbWVFdmVudHM6IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICAgIHRpbWVFdmVudDogaW1wb3J0X3pvZC56LmFycmF5KFRpbWVFdmVudFNjaGVtYSlcbiAgfSkub3B0aW9uYWwoKSxcbiAgdHJ1bmNhdGVkOiBpbXBvcnRfem9kLnouYm9vbGVhbigpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgVHJhY2VEYXRhU2NoZW1hID0gaW1wb3J0X3pvZC56Lm9iamVjdCh7XG4gIHRyYWNlSWQ6IGltcG9ydF96b2Quei5zdHJpbmcoKSxcbiAgZGlzcGxheU5hbWU6IGltcG9ydF96b2Quei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBzdGFydFRpbWU6IGltcG9ydF96b2Quei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwidHJhY2Ugc3RhcnQgdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXCIpLFxuICBlbmRUaW1lOiBpbXBvcnRfem9kLnoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcImVuZCB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcIiksXG4gIHNwYW5zOiBpbXBvcnRfem9kLnoucmVjb3JkKGltcG9ydF96b2Quei5zdHJpbmcoKSwgU3BhbkRhdGFTY2hlbWEpXG59KTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBJbnN0cnVtZW50YXRpb25MaWJyYXJ5U2NoZW1hLFxuICBMaW5rU2NoZW1hLFxuICBQYXRoTWV0YWRhdGFTY2hlbWEsXG4gIFNwYW5Db250ZXh0U2NoZW1hLFxuICBTcGFuRGF0YVNjaGVtYSxcbiAgU3Bhbk1ldGFkYXRhU2NoZW1hLFxuICBTcGFuU3RhdHVzU2NoZW1hLFxuICBUaW1lRXZlbnRTY2hlbWEsXG4gIFRyYWNlRGF0YVNjaGVtYSxcbiAgVHJhY2VNZXRhZGF0YVNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/tracing/types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/utils.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  deleteUndefinedProps: () => deleteUndefinedProps\n});\nmodule.exports = __toCommonJS(utils_exports);\nfunction deleteUndefinedProps(obj) {\n  for (const prop in obj) {\n    if (obj[prop] === void 0) {\n      delete obj[prop];\n    } else {\n      if (typeof obj[prop] === \"object\") {\n        deleteUndefinedProps(obj[prop]);\n      }\n    }\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBRUw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmFzdGVyeTM2MC8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL3V0aWxzLmpzPzljMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHM6ICgpID0+IGRlbGV0ZVVuZGVmaW5lZFByb3BzXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHV0aWxzX2V4cG9ydHMpO1xuZnVuY3Rpb24gZGVsZXRlVW5kZWZpbmVkUHJvcHMob2JqKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAob2JqW3Byb3BdID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRlbGV0ZVVuZGVmaW5lZFByb3BzKG9ialtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHNcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/googleai/lib/embedder.js":
/*!**********************************************************!*\
  !*** ./node_modules/@genkit-ai/googleai/lib/embedder.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar embedder_exports = {};\n__export(embedder_exports, {\n  SUPPORTED_MODELS: () => SUPPORTED_MODELS,\n  TaskTypeSchema: () => TaskTypeSchema,\n  TextEmbeddingGeckoConfigSchema: () => TextEmbeddingGeckoConfigSchema,\n  textEmbeddingGecko001: () => textEmbeddingGecko001,\n  textEmbeddingGeckoEmbedder: () => textEmbeddingGeckoEmbedder\n});\nmodule.exports = __toCommonJS(embedder_exports);\nvar import_embedder = __webpack_require__(/*! @genkit-ai/ai/embedder */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/embedder.js\");\nvar import_generative_ai = __webpack_require__(/*! @google/generative-ai */ \"(action-browser)/./node_modules/@genkit-ai/googleai/node_modules/@google/generative-ai/dist/index.js\");\nvar import_zod = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nconst TaskTypeSchema = import_zod.z.enum([\n  \"RETRIEVAL_DOCUMENT\",\n  \"RETRIEVAL_QUERY\",\n  \"SEMANTIC_SIMILARITY\",\n  \"CLASSIFICATION\",\n  \"CLUSTERING\"\n]);\nconst TextEmbeddingGeckoConfigSchema = import_zod.z.object({\n  /**\n   * The `task_type` parameter is defined as the intended downstream application to help the model\n   * produce better quality embeddings.\n   **/\n  taskType: TaskTypeSchema.optional(),\n  title: (0, import_zod.string)().optional()\n});\nconst textEmbeddingGecko001 = (0, import_embedder.embedderRef)({\n  name: \"googleai/embedding-001\",\n  configSchema: TextEmbeddingGeckoConfigSchema,\n  info: {\n    dimensions: 768,\n    label: \"Google Gen AI - Text Embedding Gecko (Legacy)\",\n    supports: {\n      input: [\"text\"]\n    }\n  }\n});\nconst SUPPORTED_MODELS = {\n  \"embedding-001\": textEmbeddingGecko001\n};\nfunction textEmbeddingGeckoEmbedder(name, options) {\n  let apiKey = (options == null ? void 0 : options.apiKey) || process.env.GOOGLE_GENAI_API_KEY || process.env.GOOGLE_API_KEY;\n  if (!apiKey)\n    throw new Error(\n      \"Please pass in the API key or set either GOOGLE_GENAI_API_KEY or GOOGLE_API_KEY environment variable.\\nFor more details see https://firebase.google.com/docs/genkit/plugins/google-genai\"\n    );\n  const client = new import_generative_ai.GoogleGenerativeAI(apiKey).getGenerativeModel({\n    model: name\n  });\n  const embedder = SUPPORTED_MODELS[name];\n  return (0, import_embedder.defineEmbedder)(\n    {\n      name: embedder.name,\n      configSchema: TextEmbeddingGeckoConfigSchema,\n      info: embedder.info\n    },\n    (input, options2) => __async(this, null, function* () {\n      const embeddings = yield Promise.all(\n        input.map((doc) => __async(this, null, function* () {\n          const response = yield client.embedContent({\n            taskType: options2 == null ? void 0 : options2.taskType,\n            title: options2 == null ? void 0 : options2.title,\n            content: {\n              role: \"\",\n              parts: [{ text: doc.text() }]\n            }\n          });\n          const values = response.embedding.values;\n          return { embedding: values };\n        }))\n      );\n      return { embeddings };\n    })\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=embedder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZWFpL2xpYi9lbWJlZGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDZGQUF3QjtBQUN0RCwyQkFBMkIsbUJBQU8sQ0FBQyxtSUFBdUI7QUFDMUQsaUJBQWlCLG1CQUFPLENBQUMsMERBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFdBQVc7QUFDWDtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FNTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvZ29vZ2xlYWkvbGliL2VtYmVkZGVyLmpzPzExMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBlbWJlZGRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbWJlZGRlcl9leHBvcnRzLCB7XG4gIFNVUFBPUlRFRF9NT0RFTFM6ICgpID0+IFNVUFBPUlRFRF9NT0RFTFMsXG4gIFRhc2tUeXBlU2NoZW1hOiAoKSA9PiBUYXNrVHlwZVNjaGVtYSxcbiAgVGV4dEVtYmVkZGluZ0dlY2tvQ29uZmlnU2NoZW1hOiAoKSA9PiBUZXh0RW1iZWRkaW5nR2Vja29Db25maWdTY2hlbWEsXG4gIHRleHRFbWJlZGRpbmdHZWNrbzAwMTogKCkgPT4gdGV4dEVtYmVkZGluZ0dlY2tvMDAxLFxuICB0ZXh0RW1iZWRkaW5nR2Vja29FbWJlZGRlcjogKCkgPT4gdGV4dEVtYmVkZGluZ0dlY2tvRW1iZWRkZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZW1iZWRkZXJfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2VtYmVkZGVyID0gcmVxdWlyZShcIkBnZW5raXQtYWkvYWkvZW1iZWRkZXJcIik7XG52YXIgaW1wb3J0X2dlbmVyYXRpdmVfYWkgPSByZXF1aXJlKFwiQGdvb2dsZS9nZW5lcmF0aXZlLWFpXCIpO1xudmFyIGltcG9ydF96b2QgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgVGFza1R5cGVTY2hlbWEgPSBpbXBvcnRfem9kLnouZW51bShbXG4gIFwiUkVUUklFVkFMX0RPQ1VNRU5UXCIsXG4gIFwiUkVUUklFVkFMX1FVRVJZXCIsXG4gIFwiU0VNQU5USUNfU0lNSUxBUklUWVwiLFxuICBcIkNMQVNTSUZJQ0FUSU9OXCIsXG4gIFwiQ0xVU1RFUklOR1wiXG5dKTtcbmNvbnN0IFRleHRFbWJlZGRpbmdHZWNrb0NvbmZpZ1NjaGVtYSA9IGltcG9ydF96b2Quei5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIGB0YXNrX3R5cGVgIHBhcmFtZXRlciBpcyBkZWZpbmVkIGFzIHRoZSBpbnRlbmRlZCBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHRvIGhlbHAgdGhlIG1vZGVsXG4gICAqIHByb2R1Y2UgYmV0dGVyIHF1YWxpdHkgZW1iZWRkaW5ncy5cbiAgICoqL1xuICB0YXNrVHlwZTogVGFza1R5cGVTY2hlbWEub3B0aW9uYWwoKSxcbiAgdGl0bGU6ICgwLCBpbXBvcnRfem9kLnN0cmluZykoKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IHRleHRFbWJlZGRpbmdHZWNrbzAwMSA9ICgwLCBpbXBvcnRfZW1iZWRkZXIuZW1iZWRkZXJSZWYpKHtcbiAgbmFtZTogXCJnb29nbGVhaS9lbWJlZGRpbmctMDAxXCIsXG4gIGNvbmZpZ1NjaGVtYTogVGV4dEVtYmVkZGluZ0dlY2tvQ29uZmlnU2NoZW1hLFxuICBpbmZvOiB7XG4gICAgZGltZW5zaW9uczogNzY4LFxuICAgIGxhYmVsOiBcIkdvb2dsZSBHZW4gQUkgLSBUZXh0IEVtYmVkZGluZyBHZWNrbyAoTGVnYWN5KVwiLFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICBpbnB1dDogW1widGV4dFwiXVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBTVVBQT1JURURfTU9ERUxTID0ge1xuICBcImVtYmVkZGluZy0wMDFcIjogdGV4dEVtYmVkZGluZ0dlY2tvMDAxXG59O1xuZnVuY3Rpb24gdGV4dEVtYmVkZGluZ0dlY2tvRW1iZWRkZXIobmFtZSwgb3B0aW9ucykge1xuICBsZXQgYXBpS2V5ID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBpS2V5KSB8fCBwcm9jZXNzLmVudi5HT09HTEVfR0VOQUlfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5HT09HTEVfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJQbGVhc2UgcGFzcyBpbiB0aGUgQVBJIGtleSBvciBzZXQgZWl0aGVyIEdPT0dMRV9HRU5BSV9BUElfS0VZIG9yIEdPT0dMRV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlLlxcbkZvciBtb3JlIGRldGFpbHMgc2VlIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2dlbmtpdC9wbHVnaW5zL2dvb2dsZS1nZW5haVwiXG4gICAgKTtcbiAgY29uc3QgY2xpZW50ID0gbmV3IGltcG9ydF9nZW5lcmF0aXZlX2FpLkdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpLmdldEdlbmVyYXRpdmVNb2RlbCh7XG4gICAgbW9kZWw6IG5hbWVcbiAgfSk7XG4gIGNvbnN0IGVtYmVkZGVyID0gU1VQUE9SVEVEX01PREVMU1tuYW1lXTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfZW1iZWRkZXIuZGVmaW5lRW1iZWRkZXIpKFxuICAgIHtcbiAgICAgIG5hbWU6IGVtYmVkZGVyLm5hbWUsXG4gICAgICBjb25maWdTY2hlbWE6IFRleHRFbWJlZGRpbmdHZWNrb0NvbmZpZ1NjaGVtYSxcbiAgICAgIGluZm86IGVtYmVkZGVyLmluZm9cbiAgICB9LFxuICAgIChpbnB1dCwgb3B0aW9uczIpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSB5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5wdXQubWFwKChkb2MpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGNsaWVudC5lbWJlZENvbnRlbnQoe1xuICAgICAgICAgICAgdGFza1R5cGU6IG9wdGlvbnMyID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zMi50YXNrVHlwZSxcbiAgICAgICAgICAgIHRpdGxlOiBvcHRpb25zMiA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9uczIudGl0bGUsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgIHJvbGU6IFwiXCIsXG4gICAgICAgICAgICAgIHBhcnRzOiBbeyB0ZXh0OiBkb2MudGV4dCgpIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gcmVzcG9uc2UuZW1iZWRkaW5nLnZhbHVlcztcbiAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmc6IHZhbHVlcyB9O1xuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgICByZXR1cm4geyBlbWJlZGRpbmdzIH07XG4gICAgfSlcbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBTVVBQT1JURURfTU9ERUxTLFxuICBUYXNrVHlwZVNjaGVtYSxcbiAgVGV4dEVtYmVkZGluZ0dlY2tvQ29uZmlnU2NoZW1hLFxuICB0ZXh0RW1iZWRkaW5nR2Vja28wMDEsXG4gIHRleHRFbWJlZGRpbmdHZWNrb0VtYmVkZGVyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/googleai/lib/embedder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/googleai/lib/gemini.js":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/googleai/lib/gemini.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => {\n  return (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar __forAwait = (obj, it, method) => (it = obj[__knownSymbol(\"asyncIterator\")]) ? it.call(obj) : (obj = obj[__knownSymbol(\"iterator\")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method(\"next\"), method(\"return\"), it);\nvar gemini_exports = {};\n__export(gemini_exports, {\n  SUPPORTED_V15_MODELS: () => SUPPORTED_V15_MODELS,\n  SUPPORTED_V1_MODELS: () => SUPPORTED_V1_MODELS,\n  fromGeminiCandidate: () => fromGeminiCandidate,\n  gemini15Flash: () => gemini15Flash,\n  gemini15Flash8B: () => gemini15Flash8B,\n  gemini15Pro: () => gemini15Pro,\n  geminiPro: () => geminiPro,\n  geminiProVision: () => geminiProVision,\n  geminiUltra: () => geminiUltra,\n  googleAIModel: () => googleAIModel,\n  toGeminiMessage: () => toGeminiMessage,\n  toGeminiSystemInstruction: () => toGeminiSystemInstruction\n});\nmodule.exports = __toCommonJS(gemini_exports);\nvar import_extract = __webpack_require__(/*! @genkit-ai/ai/extract */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/extract.js\");\nvar import_model = __webpack_require__(/*! @genkit-ai/ai/model */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\nvar import_middleware = __webpack_require__(/*! @genkit-ai/ai/model/middleware */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model/middleware.js\");\nvar import_core = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.js\");\nvar import_generative_ai = __webpack_require__(/*! @google/generative-ai */ \"(action-browser)/./node_modules/@genkit-ai/googleai/node_modules/@google/generative-ai/dist/index.js\");\nvar import_process = __toESM(__webpack_require__(/*! process */ \"process\"));\nvar import_zod = __toESM(__webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\"));\nconst SafetySettingsSchema = import_zod.default.object({\n  category: import_zod.default.enum([\n    \"HARM_CATEGORY_UNSPECIFIED\",\n    \"HARM_CATEGORY_HATE_SPEECH\",\n    \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    \"HARM_CATEGORY_HARASSMENT\",\n    \"HARM_CATEGORY_DANGEROUS_CONTENT\"\n  ]),\n  threshold: import_zod.default.enum([\n    \"BLOCK_LOW_AND_ABOVE\",\n    \"BLOCK_MEDIUM_AND_ABOVE\",\n    \"BLOCK_ONLY_HIGH\",\n    \"BLOCK_NONE\"\n  ])\n});\nconst GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({\n  safetySettings: import_zod.default.array(SafetySettingsSchema).optional(),\n  codeExecution: import_zod.default.union([import_zod.default.boolean(), import_zod.default.object({}).strict()]).optional()\n});\nconst geminiPro = (0, import_model.modelRef)({\n  name: \"googleai/gemini-pro\",\n  info: {\n    label: \"Google AI - Gemini Pro\",\n    supports: {\n      multiturn: true,\n      media: false,\n      tools: true,\n      systemRole: true\n    },\n    versions: [\"gemini-1.0-pro\", \"gemini-1.0-pro-latest\", \"gemini-1.0-pro-001\"]\n  },\n  configSchema: GeminiConfigSchema\n});\nconst geminiProVision = (0, import_model.modelRef)({\n  name: \"googleai/gemini-pro-vision\",\n  info: {\n    label: \"Google AI - Gemini Pro Vision\",\n    // none declared on https://ai.google.dev/models/gemini#model-variations\n    versions: [],\n    supports: {\n      multiturn: true,\n      media: true,\n      tools: false,\n      systemRole: false\n    },\n    stage: \"deprecated\"\n  },\n  configSchema: GeminiConfigSchema\n});\nconst gemini15Pro = (0, import_model.modelRef)({\n  name: \"googleai/gemini-1.5-pro-latest\",\n  info: {\n    label: \"Google AI - Gemini 1.5 Pro\",\n    supports: {\n      multiturn: true,\n      media: true,\n      tools: true,\n      systemRole: true,\n      output: [\"text\", \"json\"]\n    },\n    versions: [\n      \"gemini-1.5-pro\",\n      \"gemini-1.5-pro-001\",\n      \"gemini-1.5-pro-002\",\n      \"gemini-1.5-pro-exp-0827\"\n    ]\n  },\n  configSchema: GeminiConfigSchema\n});\nconst gemini15Flash = (0, import_model.modelRef)({\n  name: \"googleai/gemini-1.5-flash-latest\",\n  info: {\n    label: \"Google AI - Gemini 1.5 Flash\",\n    supports: {\n      multiturn: true,\n      media: true,\n      tools: true,\n      systemRole: true,\n      output: [\"text\", \"json\"]\n    },\n    versions: [\n      \"gemini-1.5-flash\",\n      \"gemini-1.5-flash-001\",\n      \"gemini-1.5-flash-002\",\n      \"gemini-1.5-flash-8b-exp-0924\",\n      \"gemini-1.5-flash-8b-exp-0827\",\n      \"gemini-1.5-flash-exp-0827\"\n    ]\n  },\n  configSchema: GeminiConfigSchema\n});\nconst gemini15Flash8B = (0, import_model.modelRef)({\n  name: \"googleai/gemini-1.5-flash-8b-latest\",\n  info: {\n    label: \"Google AI - Gemini 1.5 Flash-8B\",\n    supports: {\n      multiturn: true,\n      media: true,\n      tools: true,\n      systemRole: true,\n      output: [\"text\", \"json\"]\n    },\n    versions: [\"gemini-1.5-flash-8b\", \"gemini-1.5-flash-8b-001\"]\n  },\n  configSchema: GeminiConfigSchema\n});\nconst geminiUltra = (0, import_model.modelRef)({\n  name: \"googleai/gemini-ultra\",\n  info: {\n    label: \"Google AI - Gemini Ultra\",\n    versions: [],\n    supports: {\n      multiturn: true,\n      media: false,\n      tools: true,\n      systemRole: true\n    }\n  },\n  configSchema: GeminiConfigSchema\n});\nconst SUPPORTED_V1_MODELS = {\n  \"gemini-pro\": geminiPro,\n  \"gemini-pro-vision\": geminiProVision\n  // 'gemini-ultra': geminiUltra,\n};\nconst SUPPORTED_V15_MODELS = {\n  \"gemini-1.5-pro-latest\": gemini15Pro,\n  \"gemini-1.5-flash-latest\": gemini15Flash,\n  \"gemini-1.5-flash-8b-latest\": gemini15Flash8B\n};\nconst SUPPORTED_MODELS = __spreadValues(__spreadValues({}, SUPPORTED_V1_MODELS), SUPPORTED_V15_MODELS);\nfunction toGeminiRole(role, model) {\n  switch (role) {\n    case \"user\":\n      return \"user\";\n    case \"model\":\n      return \"model\";\n    case \"system\":\n      if (model && SUPPORTED_V15_MODELS[model.name]) {\n        throw new Error(\n          \"system role is only supported for a single message in the first position\"\n        );\n      } else {\n        throw new Error(\"system role is not supported\");\n      }\n    case \"tool\":\n      return \"function\";\n    default:\n      return \"user\";\n  }\n}\nfunction convertSchemaProperty(property) {\n  if (!property) {\n    return null;\n  }\n  if (property.type === \"object\") {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = convertSchemaProperty(property.properties[key]);\n    });\n    return {\n      type: import_generative_ai.FunctionDeclarationSchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required\n    };\n  } else if (property.type === \"array\") {\n    return {\n      type: import_generative_ai.FunctionDeclarationSchemaType.ARRAY,\n      items: convertSchemaProperty(property.items)\n    };\n  } else {\n    return {\n      type: import_generative_ai.FunctionDeclarationSchemaType[property.type.toUpperCase()]\n    };\n  }\n}\nfunction toGeminiTool(tool) {\n  const declaration = {\n    name: tool.name.replace(/\\//g, \"__\"),\n    // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: convertSchemaProperty(tool.inputSchema)\n  };\n  return declaration;\n}\nfunction toInlineData(part) {\n  const dataUrl = part.media.url;\n  const b64Data = dataUrl.substring(dataUrl.indexOf(\",\") + 1);\n  const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(\":\") + 1, dataUrl.indexOf(\";\"));\n  return { inlineData: { mimeType: contentType, data: b64Data } };\n}\nfunction toFileData(part) {\n  if (!part.media.contentType)\n    throw new Error(\n      \"Must supply a `contentType` when sending File URIs to Gemini.\"\n    );\n  return {\n    fileData: { mimeType: part.media.contentType, fileUri: part.media.url }\n  };\n}\nfunction fromInlineData(inlinePart) {\n  if (!inlinePart.inlineData || !inlinePart.inlineData.hasOwnProperty(\"mimeType\") || !inlinePart.inlineData.hasOwnProperty(\"data\")) {\n    throw new Error(\"Invalid InlineDataPart: missing required properties\");\n  }\n  const { mimeType, data } = inlinePart.inlineData;\n  const dataUrl = `data:${mimeType};base64,${data}`;\n  return {\n    media: {\n      url: dataUrl,\n      contentType: mimeType\n    }\n  };\n}\nfunction toFunctionCall(part) {\n  var _a;\n  if (!((_a = part == null ? void 0 : part.toolRequest) == null ? void 0 : _a.input)) {\n    throw Error(\"Invalid ToolRequestPart: input was missing.\");\n  }\n  return {\n    functionCall: {\n      name: part.toolRequest.name,\n      args: part.toolRequest.input\n    }\n  };\n}\nfunction fromFunctionCall(part) {\n  if (!part.functionCall) {\n    throw Error(\"Invalid FunctionCallPart\");\n  }\n  return {\n    toolRequest: {\n      name: part.functionCall.name,\n      input: part.functionCall.args\n    }\n  };\n}\nfunction toFunctionResponse(part) {\n  var _a;\n  if (!((_a = part == null ? void 0 : part.toolResponse) == null ? void 0 : _a.output)) {\n    throw Error(\"Invalid ToolResponsePart: output was missing.\");\n  }\n  return {\n    functionResponse: {\n      name: part.toolResponse.name,\n      response: {\n        name: part.toolResponse.name,\n        content: part.toolResponse.output\n      }\n    }\n  };\n}\nfunction fromFunctionResponse(part) {\n  if (!part.functionResponse) {\n    throw new Error(\"Invalid FunctionResponsePart.\");\n  }\n  return {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, \"/\"),\n      // restore slashes\n      output: part.functionResponse.response\n    }\n  };\n}\nfunction fromExecutableCode(part) {\n  if (!part.executableCode) {\n    throw new Error(\"Invalid GeminiPart: missing executableCode\");\n  }\n  return {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code\n      }\n    }\n  };\n}\nfunction fromCodeExecutionResult(part) {\n  if (!part.codeExecutionResult) {\n    throw new Error(\"Invalid GeminiPart: missing codeExecutionResult\");\n  }\n  return {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output\n      }\n    }\n  };\n}\nfunction toCustomPart(part) {\n  if (!part.custom) {\n    throw new Error(\"Invalid GeminiPart: missing custom\");\n  }\n  if (part.custom.codeExecutionResult) {\n    return { codeExecutionResult: part.custom.codeExecutionResult };\n  }\n  if (part.custom.executableCode) {\n    return { executableCode: part.custom.executableCode };\n  }\n  throw new Error(\"Unsupported Custom Part type\");\n}\nfunction toGeminiPart(part) {\n  if (part.text !== void 0)\n    return { text: part.text };\n  if (part.media) {\n    if (part.media.url.startsWith(\"data:\"))\n      return toInlineData(part);\n    return toFileData(part);\n  }\n  if (part.toolRequest)\n    return toFunctionCall(part);\n  if (part.toolResponse)\n    return toFunctionResponse(part);\n  if (part.custom)\n    return toCustomPart(part);\n  throw new Error(\"Unsupported Part type\");\n}\nfunction fromGeminiPart(part, jsonMode) {\n  if (jsonMode && part.text !== void 0) {\n    return { data: (0, import_extract.extractJson)(part.text) };\n  }\n  if (part.text !== void 0)\n    return { text: part.text };\n  if (part.inlineData)\n    return fromInlineData(part);\n  if (part.functionCall)\n    return fromFunctionCall(part);\n  if (part.functionResponse)\n    return fromFunctionResponse(part);\n  if (part.executableCode)\n    return fromExecutableCode(part);\n  if (part.codeExecutionResult)\n    return fromCodeExecutionResult(part);\n  throw new Error(\"Unsupported GeminiPart type\");\n}\nfunction toGeminiMessage(message, model) {\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: message.content.map(toGeminiPart)\n  };\n}\nfunction toGeminiSystemInstruction(message) {\n  return {\n    role: \"user\",\n    parts: message.content.map(toGeminiPart)\n  };\n}\nfunction fromGeminiFinishReason(reason) {\n  if (!reason)\n    return \"unknown\";\n  switch (reason) {\n    case \"STOP\":\n      return \"stop\";\n    case \"MAX_TOKENS\":\n      return \"length\";\n    case \"SAFETY\":\n    case \"RECITATION\":\n      return \"blocked\";\n    default:\n      return \"unknown\";\n  }\n}\nfunction fromGeminiCandidate(candidate, jsonMode = false) {\n  var _a;\n  return {\n    index: candidate.index || 0,\n    // reasonable default?\n    message: {\n      role: \"model\",\n      content: (((_a = candidate.content) == null ? void 0 : _a.parts) || []).map(\n        (part) => fromGeminiPart(part, jsonMode)\n      )\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata\n    }\n  };\n}\nfunction googleAIModel(name, apiKey, apiVersion, baseUrl) {\n  var _a, _b;\n  const modelName = `googleai/${name}`;\n  if (!apiKey) {\n    apiKey = import_process.default.env.GOOGLE_GENAI_API_KEY || import_process.default.env.GOOGLE_API_KEY;\n  }\n  if (!apiKey) {\n    throw new Error(\n      \"Please pass in the API key or set the GOOGLE_GENAI_API_KEY or GOOGLE_API_KEY environment variable.\\nFor more details see https://firebase.google.com/docs/genkit/plugins/google-genai\"\n    );\n  }\n  const model = SUPPORTED_MODELS[name];\n  if (!model)\n    throw new Error(`Unsupported model: ${name}`);\n  const middleware = [];\n  if (SUPPORTED_V1_MODELS[name]) {\n    middleware.push((0, import_middleware.simulateSystemPrompt)());\n  }\n  if ((_b = (_a = model == null ? void 0 : model.info) == null ? void 0 : _a.supports) == null ? void 0 : _b.media) {\n    middleware.push(\n      (0, import_middleware.downloadRequestMedia)({\n        maxBytes: 1024 * 1024 * 10,\n        // don't downlaod files that have been uploaded using the Files API\n        filter: (part) => !part.media.url.startsWith(\n          \"https://generativelanguage.googleapis.com/\"\n        )\n      })\n    );\n  }\n  return (0, import_model.defineModel)(\n    __spreadProps(__spreadValues({\n      name: modelName\n    }, model.info), {\n      configSchema: model.configSchema,\n      use: middleware\n    }),\n    (request, streamingCallback) => __async(this, null, function* () {\n      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;\n      const options = { apiClient: import_core.GENKIT_CLIENT_HEADER };\n      if (apiVersion) {\n        options.apiVersion = apiVersion;\n      }\n      if (apiVersion) {\n        options.baseUrl = baseUrl;\n      }\n      const client = new import_generative_ai.GoogleGenerativeAI(apiKey).getGenerativeModel(\n        {\n          model: ((_a2 = request.config) == null ? void 0 : _a2.version) || model.version || name\n        },\n        options\n      );\n      const messages = [...request.messages];\n      if (messages.length === 0)\n        throw new Error(\"No messages provided.\");\n      let systemInstruction = void 0;\n      if (SUPPORTED_V15_MODELS[name]) {\n        const systemMessage = messages.find((m) => m.role === \"system\");\n        if (systemMessage) {\n          messages.splice(messages.indexOf(systemMessage), 1);\n          systemInstruction = toGeminiSystemInstruction(systemMessage);\n        }\n      }\n      const tools = [];\n      if ((_b2 = request.tools) == null ? void 0 : _b2.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(toGeminiTool)\n        });\n      }\n      if ((_c = request.config) == null ? void 0 : _c.codeExecution) {\n        tools.push({\n          codeExecution: request.config.codeExecution === true ? {} : request.config.codeExecution\n        });\n      }\n      const jsonMode = (((_d = request.output) == null ? void 0 : _d.format) === \"json\" || !!((_e = request.output) == null ? void 0 : _e.schema)) && tools.length === 0;\n      const generationConfig = {\n        candidateCount: request.candidates || void 0,\n        temperature: (_f = request.config) == null ? void 0 : _f.temperature,\n        maxOutputTokens: (_g = request.config) == null ? void 0 : _g.maxOutputTokens,\n        topK: (_h = request.config) == null ? void 0 : _h.topK,\n        topP: (_i = request.config) == null ? void 0 : _i.topP,\n        stopSequences: (_j = request.config) == null ? void 0 : _j.stopSequences,\n        responseMimeType: jsonMode ? \"application/json\" : void 0\n      };\n      const chatRequest = {\n        systemInstruction,\n        generationConfig,\n        tools,\n        history: messages.slice(0, -1).map((message) => toGeminiMessage(message, model)),\n        safetySettings: (_k = request.config) == null ? void 0 : _k.safetySettings\n      };\n      const msg = toGeminiMessage(messages[messages.length - 1], model);\n      const fromJSONModeScopedGeminiCandidate = (candidate) => {\n        return fromGeminiCandidate(candidate, jsonMode);\n      };\n      if (streamingCallback) {\n        const result = yield client.startChat(chatRequest).sendMessageStream(msg.parts, options);\n        try {\n          for (var iter = __forAwait(result.stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {\n            const item = temp.value;\n            (_l = item.candidates) == null ? void 0 : _l.forEach((candidate) => {\n              const c = fromJSONModeScopedGeminiCandidate(candidate);\n              streamingCallback({\n                index: c.index,\n                content: c.message.content\n              });\n            });\n          }\n        } catch (temp) {\n          error = [temp];\n        } finally {\n          try {\n            more && (temp = iter.return) && (yield temp.call(iter));\n          } finally {\n            if (error)\n              throw error[0];\n          }\n        }\n        const response = yield result.response;\n        if (!((_m = response.candidates) == null ? void 0 : _m.length)) {\n          throw new Error(\"No valid candidates returned.\");\n        }\n        return {\n          candidates: ((_n = response.candidates) == null ? void 0 : _n.map(fromJSONModeScopedGeminiCandidate)) || [],\n          custom: response\n        };\n      } else {\n        const result = yield client.startChat(chatRequest).sendMessage(msg.parts, options);\n        if (!((_o = result.response.candidates) == null ? void 0 : _o.length))\n          throw new Error(\"No valid candidates returned.\");\n        const responseCandidates = ((_p = result.response.candidates) == null ? void 0 : _p.map(fromJSONModeScopedGeminiCandidate)) || [];\n        return {\n          candidates: responseCandidates,\n          custom: result.response,\n          usage: __spreadProps(__spreadValues({}, (0, import_model.getBasicUsageStats)(request.messages, responseCandidates)), {\n            inputTokens: (_q = result.response.usageMetadata) == null ? void 0 : _q.promptTokenCount,\n            outputTokens: (_r = result.response.usageMetadata) == null ? void 0 : _r.candidatesTokenCount,\n            totalTokens: (_s = result.response.usageMetadata) == null ? void 0 : _s.totalTokenCount\n          })\n        };\n      }\n    })\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=gemini.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZWFpL2xpYi9nZW1pbmkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtKQUFrSiwwTEFBMEwsYUFBYTtBQUN6VjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQyw2R0FBZ0M7QUFDaEUsa0JBQWtCLG1CQUFPLENBQUMscUZBQWlCO0FBQzNDLDJCQUEyQixtQkFBTyxDQUFDLG1JQUF1QjtBQUMxRCw2QkFBNkIsbUJBQU8sQ0FBQyx3QkFBUztBQUM5Qyx5QkFBeUIsbUJBQU8sQ0FBQywwREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUcsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLDBCQUEwQixVQUFVLFNBQVMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHlDQUF5QztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FhTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvZ29vZ2xlYWkvbGliL2dlbWluaS5qcz9jODIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fa25vd25TeW1ib2wgPSAobmFtZSwgc3ltYm9sKSA9PiB7XG4gIHJldHVybiAoc3ltYm9sID0gU3ltYm9sW25hbWVdKSA/IHN5bWJvbCA6IFN5bWJvbC5mb3IoXCJTeW1ib2wuXCIgKyBuYW1lKTtcbn07XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fZm9yQXdhaXQgPSAob2JqLCBpdCwgbWV0aG9kKSA9PiAoaXQgPSBvYmpbX19rbm93blN5bWJvbChcImFzeW5jSXRlcmF0b3JcIildKSA/IGl0LmNhbGwob2JqKSA6IChvYmogPSBvYmpbX19rbm93blN5bWJvbChcIml0ZXJhdG9yXCIpXSgpLCBpdCA9IHt9LCBtZXRob2QgPSAoa2V5LCBmbikgPT4gKGZuID0gb2JqW2tleV0pICYmIChpdFtrZXldID0gKGFyZykgPT4gbmV3IFByb21pc2UoKHllcywgbm8sIGRvbmUpID0+IChhcmcgPSBmbi5jYWxsKG9iaiwgYXJnKSwgZG9uZSA9IGFyZy5kb25lLCBQcm9taXNlLnJlc29sdmUoYXJnLnZhbHVlKS50aGVuKCh2YWx1ZSkgPT4geWVzKHsgdmFsdWUsIGRvbmUgfSksIG5vKSkpKSwgbWV0aG9kKFwibmV4dFwiKSwgbWV0aG9kKFwicmV0dXJuXCIpLCBpdCk7XG52YXIgZ2VtaW5pX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdlbWluaV9leHBvcnRzLCB7XG4gIFNVUFBPUlRFRF9WMTVfTU9ERUxTOiAoKSA9PiBTVVBQT1JURURfVjE1X01PREVMUyxcbiAgU1VQUE9SVEVEX1YxX01PREVMUzogKCkgPT4gU1VQUE9SVEVEX1YxX01PREVMUyxcbiAgZnJvbUdlbWluaUNhbmRpZGF0ZTogKCkgPT4gZnJvbUdlbWluaUNhbmRpZGF0ZSxcbiAgZ2VtaW5pMTVGbGFzaDogKCkgPT4gZ2VtaW5pMTVGbGFzaCxcbiAgZ2VtaW5pMTVGbGFzaDhCOiAoKSA9PiBnZW1pbmkxNUZsYXNoOEIsXG4gIGdlbWluaTE1UHJvOiAoKSA9PiBnZW1pbmkxNVBybyxcbiAgZ2VtaW5pUHJvOiAoKSA9PiBnZW1pbmlQcm8sXG4gIGdlbWluaVByb1Zpc2lvbjogKCkgPT4gZ2VtaW5pUHJvVmlzaW9uLFxuICBnZW1pbmlVbHRyYTogKCkgPT4gZ2VtaW5pVWx0cmEsXG4gIGdvb2dsZUFJTW9kZWw6ICgpID0+IGdvb2dsZUFJTW9kZWwsXG4gIHRvR2VtaW5pTWVzc2FnZTogKCkgPT4gdG9HZW1pbmlNZXNzYWdlLFxuICB0b0dlbWluaVN5c3RlbUluc3RydWN0aW9uOiAoKSA9PiB0b0dlbWluaVN5c3RlbUluc3RydWN0aW9uXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGdlbWluaV9leHBvcnRzKTtcbnZhciBpbXBvcnRfZXh0cmFjdCA9IHJlcXVpcmUoXCJAZ2Vua2l0LWFpL2FpL2V4dHJhY3RcIik7XG52YXIgaW1wb3J0X21vZGVsID0gcmVxdWlyZShcIkBnZW5raXQtYWkvYWkvbW9kZWxcIik7XG52YXIgaW1wb3J0X21pZGRsZXdhcmUgPSByZXF1aXJlKFwiQGdlbmtpdC1haS9haS9tb2RlbC9taWRkbGV3YXJlXCIpO1xudmFyIGltcG9ydF9jb3JlID0gcmVxdWlyZShcIkBnZW5raXQtYWkvY29yZVwiKTtcbnZhciBpbXBvcnRfZ2VuZXJhdGl2ZV9haSA9IHJlcXVpcmUoXCJAZ29vZ2xlL2dlbmVyYXRpdmUtYWlcIik7XG52YXIgaW1wb3J0X3Byb2Nlc3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJwcm9jZXNzXCIpKTtcbnZhciBpbXBvcnRfem9kID0gX190b0VTTShyZXF1aXJlKFwiem9kXCIpKTtcbmNvbnN0IFNhZmV0eVNldHRpbmdzU2NoZW1hID0gaW1wb3J0X3pvZC5kZWZhdWx0Lm9iamVjdCh7XG4gIGNhdGVnb3J5OiBpbXBvcnRfem9kLmRlZmF1bHQuZW51bShbXG4gICAgXCJIQVJNX0NBVEVHT1JZX1VOU1BFQ0lGSUVEXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCIsXG4gICAgXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIlxuICBdKSxcbiAgdGhyZXNob2xkOiBpbXBvcnRfem9kLmRlZmF1bHQuZW51bShbXG4gICAgXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgXCJCTE9DS19PTkxZX0hJR0hcIixcbiAgICBcIkJMT0NLX05PTkVcIlxuICBdKVxufSk7XG5jb25zdCBHZW1pbmlDb25maWdTY2hlbWEgPSBpbXBvcnRfbW9kZWwuR2VuZXJhdGlvbkNvbW1vbkNvbmZpZ1NjaGVtYS5leHRlbmQoe1xuICBzYWZldHlTZXR0aW5nczogaW1wb3J0X3pvZC5kZWZhdWx0LmFycmF5KFNhZmV0eVNldHRpbmdzU2NoZW1hKS5vcHRpb25hbCgpLFxuICBjb2RlRXhlY3V0aW9uOiBpbXBvcnRfem9kLmRlZmF1bHQudW5pb24oW2ltcG9ydF96b2QuZGVmYXVsdC5ib29sZWFuKCksIGltcG9ydF96b2QuZGVmYXVsdC5vYmplY3Qoe30pLnN0cmljdCgpXSkub3B0aW9uYWwoKVxufSk7XG5jb25zdCBnZW1pbmlQcm8gPSAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gIG5hbWU6IFwiZ29vZ2xlYWkvZ2VtaW5pLXByb1wiLFxuICBpbmZvOiB7XG4gICAgbGFiZWw6IFwiR29vZ2xlIEFJIC0gR2VtaW5pIFByb1wiLFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICBtdWx0aXR1cm46IHRydWUsXG4gICAgICBtZWRpYTogZmFsc2UsXG4gICAgICB0b29sczogdHJ1ZSxcbiAgICAgIHN5c3RlbVJvbGU6IHRydWVcbiAgICB9LFxuICAgIHZlcnNpb25zOiBbXCJnZW1pbmktMS4wLXByb1wiLCBcImdlbWluaS0xLjAtcHJvLWxhdGVzdFwiLCBcImdlbWluaS0xLjAtcHJvLTAwMVwiXVxuICB9LFxuICBjb25maWdTY2hlbWE6IEdlbWluaUNvbmZpZ1NjaGVtYVxufSk7XG5jb25zdCBnZW1pbmlQcm9WaXNpb24gPSAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gIG5hbWU6IFwiZ29vZ2xlYWkvZ2VtaW5pLXByby12aXNpb25cIixcbiAgaW5mbzoge1xuICAgIGxhYmVsOiBcIkdvb2dsZSBBSSAtIEdlbWluaSBQcm8gVmlzaW9uXCIsXG4gICAgLy8gbm9uZSBkZWNsYXJlZCBvbiBodHRwczovL2FpLmdvb2dsZS5kZXYvbW9kZWxzL2dlbWluaSNtb2RlbC12YXJpYXRpb25zXG4gICAgdmVyc2lvbnM6IFtdLFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICBtdWx0aXR1cm46IHRydWUsXG4gICAgICBtZWRpYTogdHJ1ZSxcbiAgICAgIHRvb2xzOiBmYWxzZSxcbiAgICAgIHN5c3RlbVJvbGU6IGZhbHNlXG4gICAgfSxcbiAgICBzdGFnZTogXCJkZXByZWNhdGVkXCJcbiAgfSxcbiAgY29uZmlnU2NoZW1hOiBHZW1pbmlDb25maWdTY2hlbWFcbn0pO1xuY29uc3QgZ2VtaW5pMTVQcm8gPSAoMCwgaW1wb3J0X21vZGVsLm1vZGVsUmVmKSh7XG4gIG5hbWU6IFwiZ29vZ2xlYWkvZ2VtaW5pLTEuNS1wcm8tbGF0ZXN0XCIsXG4gIGluZm86IHtcbiAgICBsYWJlbDogXCJHb29nbGUgQUkgLSBHZW1pbmkgMS41IFByb1wiLFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICBtdWx0aXR1cm46IHRydWUsXG4gICAgICBtZWRpYTogdHJ1ZSxcbiAgICAgIHRvb2xzOiB0cnVlLFxuICAgICAgc3lzdGVtUm9sZTogdHJ1ZSxcbiAgICAgIG91dHB1dDogW1widGV4dFwiLCBcImpzb25cIl1cbiAgICB9LFxuICAgIHZlcnNpb25zOiBbXG4gICAgICBcImdlbWluaS0xLjUtcHJvXCIsXG4gICAgICBcImdlbWluaS0xLjUtcHJvLTAwMVwiLFxuICAgICAgXCJnZW1pbmktMS41LXByby0wMDJcIixcbiAgICAgIFwiZ2VtaW5pLTEuNS1wcm8tZXhwLTA4MjdcIlxuICAgIF1cbiAgfSxcbiAgY29uZmlnU2NoZW1hOiBHZW1pbmlDb25maWdTY2hlbWFcbn0pO1xuY29uc3QgZ2VtaW5pMTVGbGFzaCA9ICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgbmFtZTogXCJnb29nbGVhaS9nZW1pbmktMS41LWZsYXNoLWxhdGVzdFwiLFxuICBpbmZvOiB7XG4gICAgbGFiZWw6IFwiR29vZ2xlIEFJIC0gR2VtaW5pIDEuNSBGbGFzaFwiLFxuICAgIHN1cHBvcnRzOiB7XG4gICAgICBtdWx0aXR1cm46IHRydWUsXG4gICAgICBtZWRpYTogdHJ1ZSxcbiAgICAgIHRvb2xzOiB0cnVlLFxuICAgICAgc3lzdGVtUm9sZTogdHJ1ZSxcbiAgICAgIG91dHB1dDogW1widGV4dFwiLCBcImpzb25cIl1cbiAgICB9LFxuICAgIHZlcnNpb25zOiBbXG4gICAgICBcImdlbWluaS0xLjUtZmxhc2hcIixcbiAgICAgIFwiZ2VtaW5pLTEuNS1mbGFzaC0wMDFcIixcbiAgICAgIFwiZ2VtaW5pLTEuNS1mbGFzaC0wMDJcIixcbiAgICAgIFwiZ2VtaW5pLTEuNS1mbGFzaC04Yi1leHAtMDkyNFwiLFxuICAgICAgXCJnZW1pbmktMS41LWZsYXNoLThiLWV4cC0wODI3XCIsXG4gICAgICBcImdlbWluaS0xLjUtZmxhc2gtZXhwLTA4MjdcIlxuICAgIF1cbiAgfSxcbiAgY29uZmlnU2NoZW1hOiBHZW1pbmlDb25maWdTY2hlbWFcbn0pO1xuY29uc3QgZ2VtaW5pMTVGbGFzaDhCID0gKDAsIGltcG9ydF9tb2RlbC5tb2RlbFJlZikoe1xuICBuYW1lOiBcImdvb2dsZWFpL2dlbWluaS0xLjUtZmxhc2gtOGItbGF0ZXN0XCIsXG4gIGluZm86IHtcbiAgICBsYWJlbDogXCJHb29nbGUgQUkgLSBHZW1pbmkgMS41IEZsYXNoLThCXCIsXG4gICAgc3VwcG9ydHM6IHtcbiAgICAgIG11bHRpdHVybjogdHJ1ZSxcbiAgICAgIG1lZGlhOiB0cnVlLFxuICAgICAgdG9vbHM6IHRydWUsXG4gICAgICBzeXN0ZW1Sb2xlOiB0cnVlLFxuICAgICAgb3V0cHV0OiBbXCJ0ZXh0XCIsIFwianNvblwiXVxuICAgIH0sXG4gICAgdmVyc2lvbnM6IFtcImdlbWluaS0xLjUtZmxhc2gtOGJcIiwgXCJnZW1pbmktMS41LWZsYXNoLThiLTAwMVwiXVxuICB9LFxuICBjb25maWdTY2hlbWE6IEdlbWluaUNvbmZpZ1NjaGVtYVxufSk7XG5jb25zdCBnZW1pbmlVbHRyYSA9ICgwLCBpbXBvcnRfbW9kZWwubW9kZWxSZWYpKHtcbiAgbmFtZTogXCJnb29nbGVhaS9nZW1pbmktdWx0cmFcIixcbiAgaW5mbzoge1xuICAgIGxhYmVsOiBcIkdvb2dsZSBBSSAtIEdlbWluaSBVbHRyYVwiLFxuICAgIHZlcnNpb25zOiBbXSxcbiAgICBzdXBwb3J0czoge1xuICAgICAgbXVsdGl0dXJuOiB0cnVlLFxuICAgICAgbWVkaWE6IGZhbHNlLFxuICAgICAgdG9vbHM6IHRydWUsXG4gICAgICBzeXN0ZW1Sb2xlOiB0cnVlXG4gICAgfVxuICB9LFxuICBjb25maWdTY2hlbWE6IEdlbWluaUNvbmZpZ1NjaGVtYVxufSk7XG5jb25zdCBTVVBQT1JURURfVjFfTU9ERUxTID0ge1xuICBcImdlbWluaS1wcm9cIjogZ2VtaW5pUHJvLFxuICBcImdlbWluaS1wcm8tdmlzaW9uXCI6IGdlbWluaVByb1Zpc2lvblxuICAvLyAnZ2VtaW5pLXVsdHJhJzogZ2VtaW5pVWx0cmEsXG59O1xuY29uc3QgU1VQUE9SVEVEX1YxNV9NT0RFTFMgPSB7XG4gIFwiZ2VtaW5pLTEuNS1wcm8tbGF0ZXN0XCI6IGdlbWluaTE1UHJvLFxuICBcImdlbWluaS0xLjUtZmxhc2gtbGF0ZXN0XCI6IGdlbWluaTE1Rmxhc2gsXG4gIFwiZ2VtaW5pLTEuNS1mbGFzaC04Yi1sYXRlc3RcIjogZ2VtaW5pMTVGbGFzaDhCXG59O1xuY29uc3QgU1VQUE9SVEVEX01PREVMUyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBTVVBQT1JURURfVjFfTU9ERUxTKSwgU1VQUE9SVEVEX1YxNV9NT0RFTFMpO1xuZnVuY3Rpb24gdG9HZW1pbmlSb2xlKHJvbGUsIG1vZGVsKSB7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJ1c2VyXCI6XG4gICAgICByZXR1cm4gXCJ1c2VyXCI7XG4gICAgY2FzZSBcIm1vZGVsXCI6XG4gICAgICByZXR1cm4gXCJtb2RlbFwiO1xuICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgIGlmIChtb2RlbCAmJiBTVVBQT1JURURfVjE1X01PREVMU1ttb2RlbC5uYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJzeXN0ZW0gcm9sZSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgYSBzaW5nbGUgbWVzc2FnZSBpbiB0aGUgZmlyc3QgcG9zaXRpb25cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3lzdGVtIHJvbGUgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwidXNlclwiO1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U2NoZW1hUHJvcGVydHkocHJvcGVydHkpIHtcbiAgaWYgKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcm9wZXJ0eS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmVzdGVkUHJvcGVydGllcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHByb3BlcnR5LnByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbmVzdGVkUHJvcGVydGllc1trZXldID0gY29udmVydFNjaGVtYVByb3BlcnR5KHByb3BlcnR5LnByb3BlcnRpZXNba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGltcG9ydF9nZW5lcmF0aXZlX2FpLkZ1bmN0aW9uRGVjbGFyYXRpb25TY2hlbWFUeXBlLk9CSkVDVCxcbiAgICAgIHByb3BlcnRpZXM6IG5lc3RlZFByb3BlcnRpZXMsXG4gICAgICByZXF1aXJlZDogcHJvcGVydHkucmVxdWlyZWRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHByb3BlcnR5LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBpbXBvcnRfZ2VuZXJhdGl2ZV9haS5GdW5jdGlvbkRlY2xhcmF0aW9uU2NoZW1hVHlwZS5BUlJBWSxcbiAgICAgIGl0ZW1zOiBjb252ZXJ0U2NoZW1hUHJvcGVydHkocHJvcGVydHkuaXRlbXMpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogaW1wb3J0X2dlbmVyYXRpdmVfYWkuRnVuY3Rpb25EZWNsYXJhdGlvblNjaGVtYVR5cGVbcHJvcGVydHkudHlwZS50b1VwcGVyQ2FzZSgpXVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHRvR2VtaW5pVG9vbCh0b29sKSB7XG4gIGNvbnN0IGRlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6IHRvb2wubmFtZS5yZXBsYWNlKC9cXC8vZywgXCJfX1wiKSxcbiAgICAvLyBHZW1pbmkgdGhyb3dzIG9uICcvJyBpbiB0b29sIG5hbWVcbiAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0U2NoZW1hUHJvcGVydHkodG9vbC5pbnB1dFNjaGVtYSlcbiAgfTtcbiAgcmV0dXJuIGRlY2xhcmF0aW9uO1xufVxuZnVuY3Rpb24gdG9JbmxpbmVEYXRhKHBhcnQpIHtcbiAgY29uc3QgZGF0YVVybCA9IHBhcnQubWVkaWEudXJsO1xuICBjb25zdCBiNjREYXRhID0gZGF0YVVybC5zdWJzdHJpbmcoZGF0YVVybC5pbmRleE9mKFwiLFwiKSArIDEpO1xuICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnQubWVkaWEuY29udGVudFR5cGUgfHwgZGF0YVVybC5zdWJzdHJpbmcoZGF0YVVybC5pbmRleE9mKFwiOlwiKSArIDEsIGRhdGFVcmwuaW5kZXhPZihcIjtcIikpO1xuICByZXR1cm4geyBpbmxpbmVEYXRhOiB7IG1pbWVUeXBlOiBjb250ZW50VHlwZSwgZGF0YTogYjY0RGF0YSB9IH07XG59XG5mdW5jdGlvbiB0b0ZpbGVEYXRhKHBhcnQpIHtcbiAgaWYgKCFwYXJ0Lm1lZGlhLmNvbnRlbnRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTXVzdCBzdXBwbHkgYSBgY29udGVudFR5cGVgIHdoZW4gc2VuZGluZyBGaWxlIFVSSXMgdG8gR2VtaW5pLlwiXG4gICAgKTtcbiAgcmV0dXJuIHtcbiAgICBmaWxlRGF0YTogeyBtaW1lVHlwZTogcGFydC5tZWRpYS5jb250ZW50VHlwZSwgZmlsZVVyaTogcGFydC5tZWRpYS51cmwgfVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUlubGluZURhdGEoaW5saW5lUGFydCkge1xuICBpZiAoIWlubGluZVBhcnQuaW5saW5lRGF0YSB8fCAhaW5saW5lUGFydC5pbmxpbmVEYXRhLmhhc093blByb3BlcnR5KFwibWltZVR5cGVcIikgfHwgIWlubGluZVBhcnQuaW5saW5lRGF0YS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElubGluZURhdGFQYXJ0OiBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnRpZXNcIik7XG4gIH1cbiAgY29uc3QgeyBtaW1lVHlwZSwgZGF0YSB9ID0gaW5saW5lUGFydC5pbmxpbmVEYXRhO1xuICBjb25zdCBkYXRhVXJsID0gYGRhdGE6JHttaW1lVHlwZX07YmFzZTY0LCR7ZGF0YX1gO1xuICByZXR1cm4ge1xuICAgIG1lZGlhOiB7XG4gICAgICB1cmw6IGRhdGFVcmwsXG4gICAgICBjb250ZW50VHlwZTogbWltZVR5cGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0b0Z1bmN0aW9uQ2FsbChwYXJ0KSB7XG4gIHZhciBfYTtcbiAgaWYgKCEoKF9hID0gcGFydCA9PSBudWxsID8gdm9pZCAwIDogcGFydC50b29sUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlucHV0KSkge1xuICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBUb29sUmVxdWVzdFBhcnQ6IGlucHV0IHdhcyBtaXNzaW5nLlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgbmFtZTogcGFydC50b29sUmVxdWVzdC5uYW1lLFxuICAgICAgYXJnczogcGFydC50b29sUmVxdWVzdC5pbnB1dFxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZyb21GdW5jdGlvbkNhbGwocGFydCkge1xuICBpZiAoIXBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIEZ1bmN0aW9uQ2FsbFBhcnRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sUmVxdWVzdDoge1xuICAgICAgbmFtZTogcGFydC5mdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgIGlucHV0OiBwYXJ0LmZ1bmN0aW9uQ2FsbC5hcmdzXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdG9GdW5jdGlvblJlc3BvbnNlKHBhcnQpIHtcbiAgdmFyIF9hO1xuICBpZiAoISgoX2EgPSBwYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJ0LnRvb2xSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm91dHB1dCkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgVG9vbFJlc3BvbnNlUGFydDogb3V0cHV0IHdhcyBtaXNzaW5nLlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgIG5hbWU6IHBhcnQudG9vbFJlc3BvbnNlLm5hbWUsXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBuYW1lOiBwYXJ0LnRvb2xSZXNwb25zZS5uYW1lLFxuICAgICAgICBjb250ZW50OiBwYXJ0LnRvb2xSZXNwb25zZS5vdXRwdXRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tRnVuY3Rpb25SZXNwb25zZShwYXJ0KSB7XG4gIGlmICghcGFydC5mdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBGdW5jdGlvblJlc3BvbnNlUGFydC5cIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sUmVzcG9uc2U6IHtcbiAgICAgIG5hbWU6IHBhcnQuZnVuY3Rpb25SZXNwb25zZS5uYW1lLnJlcGxhY2UoL19fL2csIFwiL1wiKSxcbiAgICAgIC8vIHJlc3RvcmUgc2xhc2hlc1xuICAgICAgb3V0cHV0OiBwYXJ0LmZ1bmN0aW9uUmVzcG9uc2UucmVzcG9uc2VcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tRXhlY3V0YWJsZUNvZGUocGFydCkge1xuICBpZiAoIXBhcnQuZXhlY3V0YWJsZUNvZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlbWluaVBhcnQ6IG1pc3NpbmcgZXhlY3V0YWJsZUNvZGVcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjdXN0b206IHtcbiAgICAgIGV4ZWN1dGFibGVDb2RlOiB7XG4gICAgICAgIGxhbmd1YWdlOiBwYXJ0LmV4ZWN1dGFibGVDb2RlLmxhbmd1YWdlLFxuICAgICAgICBjb2RlOiBwYXJ0LmV4ZWN1dGFibGVDb2RlLmNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdChwYXJ0KSB7XG4gIGlmICghcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHZW1pbmlQYXJ0OiBtaXNzaW5nIGNvZGVFeGVjdXRpb25SZXN1bHRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjdXN0b206IHtcbiAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgb3V0Y29tZTogcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0Lm91dGNvbWUsXG4gICAgICAgIG91dHB1dDogcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0Lm91dHB1dFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3VzdG9tUGFydChwYXJ0KSB7XG4gIGlmICghcGFydC5jdXN0b20pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlbWluaVBhcnQ6IG1pc3NpbmcgY3VzdG9tXCIpO1xuICB9XG4gIGlmIChwYXJ0LmN1c3RvbS5jb2RlRXhlY3V0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHsgY29kZUV4ZWN1dGlvblJlc3VsdDogcGFydC5jdXN0b20uY29kZUV4ZWN1dGlvblJlc3VsdCB9O1xuICB9XG4gIGlmIChwYXJ0LmN1c3RvbS5leGVjdXRhYmxlQ29kZSkge1xuICAgIHJldHVybiB7IGV4ZWN1dGFibGVDb2RlOiBwYXJ0LmN1c3RvbS5leGVjdXRhYmxlQ29kZSB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEN1c3RvbSBQYXJ0IHR5cGVcIik7XG59XG5mdW5jdGlvbiB0b0dlbWluaVBhcnQocGFydCkge1xuICBpZiAocGFydC50ZXh0ICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHsgdGV4dDogcGFydC50ZXh0IH07XG4gIGlmIChwYXJ0Lm1lZGlhKSB7XG4gICAgaWYgKHBhcnQubWVkaWEudXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSlcbiAgICAgIHJldHVybiB0b0lubGluZURhdGEocGFydCk7XG4gICAgcmV0dXJuIHRvRmlsZURhdGEocGFydCk7XG4gIH1cbiAgaWYgKHBhcnQudG9vbFJlcXVlc3QpXG4gICAgcmV0dXJuIHRvRnVuY3Rpb25DYWxsKHBhcnQpO1xuICBpZiAocGFydC50b29sUmVzcG9uc2UpXG4gICAgcmV0dXJuIHRvRnVuY3Rpb25SZXNwb25zZShwYXJ0KTtcbiAgaWYgKHBhcnQuY3VzdG9tKVxuICAgIHJldHVybiB0b0N1c3RvbVBhcnQocGFydCk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFBhcnQgdHlwZVwiKTtcbn1cbmZ1bmN0aW9uIGZyb21HZW1pbmlQYXJ0KHBhcnQsIGpzb25Nb2RlKSB7XG4gIGlmIChqc29uTW9kZSAmJiBwYXJ0LnRleHQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IGRhdGE6ICgwLCBpbXBvcnRfZXh0cmFjdC5leHRyYWN0SnNvbikocGFydC50ZXh0KSB9O1xuICB9XG4gIGlmIChwYXJ0LnRleHQgIT09IHZvaWQgMClcbiAgICByZXR1cm4geyB0ZXh0OiBwYXJ0LnRleHQgfTtcbiAgaWYgKHBhcnQuaW5saW5lRGF0YSlcbiAgICByZXR1cm4gZnJvbUlubGluZURhdGEocGFydCk7XG4gIGlmIChwYXJ0LmZ1bmN0aW9uQ2FsbClcbiAgICByZXR1cm4gZnJvbUZ1bmN0aW9uQ2FsbChwYXJ0KTtcbiAgaWYgKHBhcnQuZnVuY3Rpb25SZXNwb25zZSlcbiAgICByZXR1cm4gZnJvbUZ1bmN0aW9uUmVzcG9uc2UocGFydCk7XG4gIGlmIChwYXJ0LmV4ZWN1dGFibGVDb2RlKVxuICAgIHJldHVybiBmcm9tRXhlY3V0YWJsZUNvZGUocGFydCk7XG4gIGlmIChwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpXG4gICAgcmV0dXJuIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KHBhcnQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBHZW1pbmlQYXJ0IHR5cGVcIik7XG59XG5mdW5jdGlvbiB0b0dlbWluaU1lc3NhZ2UobWVzc2FnZSwgbW9kZWwpIHtcbiAgcmV0dXJuIHtcbiAgICByb2xlOiB0b0dlbWluaVJvbGUobWVzc2FnZS5yb2xlLCBtb2RlbCksXG4gICAgcGFydHM6IG1lc3NhZ2UuY29udGVudC5tYXAodG9HZW1pbmlQYXJ0KVxuICB9O1xufVxuZnVuY3Rpb24gdG9HZW1pbmlTeXN0ZW1JbnN0cnVjdGlvbihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgcGFydHM6IG1lc3NhZ2UuY29udGVudC5tYXAodG9HZW1pbmlQYXJ0KVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUdlbWluaUZpbmlzaFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCFyZWFzb24pXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICBzd2l0Y2ggKHJlYXNvbikge1xuICAgIGNhc2UgXCJTVE9QXCI6XG4gICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgY2FzZSBcIk1BWF9UT0tFTlNcIjpcbiAgICAgIHJldHVybiBcImxlbmd0aFwiO1xuICAgIGNhc2UgXCJTQUZFVFlcIjpcbiAgICBjYXNlIFwiUkVDSVRBVElPTlwiOlxuICAgICAgcmV0dXJuIFwiYmxvY2tlZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21HZW1pbmlDYW5kaWRhdGUoY2FuZGlkYXRlLCBqc29uTW9kZSA9IGZhbHNlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogY2FuZGlkYXRlLmluZGV4IHx8IDAsXG4gICAgLy8gcmVhc29uYWJsZSBkZWZhdWx0P1xuICAgIG1lc3NhZ2U6IHtcbiAgICAgIHJvbGU6IFwibW9kZWxcIixcbiAgICAgIGNvbnRlbnQ6ICgoKF9hID0gY2FuZGlkYXRlLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wYXJ0cykgfHwgW10pLm1hcChcbiAgICAgICAgKHBhcnQpID0+IGZyb21HZW1pbmlQYXJ0KHBhcnQsIGpzb25Nb2RlKVxuICAgICAgKVxuICAgIH0sXG4gICAgZmluaXNoUmVhc29uOiBmcm9tR2VtaW5pRmluaXNoUmVhc29uKGNhbmRpZGF0ZS5maW5pc2hSZWFzb24pLFxuICAgIGZpbmlzaE1lc3NhZ2U6IGNhbmRpZGF0ZS5maW5pc2hNZXNzYWdlLFxuICAgIGN1c3RvbToge1xuICAgICAgc2FmZXR5UmF0aW5nczogY2FuZGlkYXRlLnNhZmV0eVJhdGluZ3MsXG4gICAgICBjaXRhdGlvbk1ldGFkYXRhOiBjYW5kaWRhdGUuY2l0YXRpb25NZXRhZGF0YVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdvb2dsZUFJTW9kZWwobmFtZSwgYXBpS2V5LCBhcGlWZXJzaW9uLCBiYXNlVXJsKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IG1vZGVsTmFtZSA9IGBnb29nbGVhaS8ke25hbWV9YDtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICBhcGlLZXkgPSBpbXBvcnRfcHJvY2Vzcy5kZWZhdWx0LmVudi5HT09HTEVfR0VOQUlfQVBJX0tFWSB8fCBpbXBvcnRfcHJvY2Vzcy5kZWZhdWx0LmVudi5HT09HTEVfQVBJX0tFWTtcbiAgfVxuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiUGxlYXNlIHBhc3MgaW4gdGhlIEFQSSBrZXkgb3Igc2V0IHRoZSBHT09HTEVfR0VOQUlfQVBJX0tFWSBvciBHT09HTEVfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cXG5Gb3IgbW9yZSBkZXRhaWxzIHNlZSBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9nZW5raXQvcGx1Z2lucy9nb29nbGUtZ2VuYWlcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgbW9kZWwgPSBTVVBQT1JURURfTU9ERUxTW25hbWVdO1xuICBpZiAoIW1vZGVsKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZWw6ICR7bmFtZX1gKTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IFtdO1xuICBpZiAoU1VQUE9SVEVEX1YxX01PREVMU1tuYW1lXSkge1xuICAgIG1pZGRsZXdhcmUucHVzaCgoMCwgaW1wb3J0X21pZGRsZXdhcmUuc2ltdWxhdGVTeXN0ZW1Qcm9tcHQpKCkpO1xuICB9XG4gIGlmICgoX2IgPSAoX2EgPSBtb2RlbCA9PSBudWxsID8gdm9pZCAwIDogbW9kZWwuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1cHBvcnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWVkaWEpIHtcbiAgICBtaWRkbGV3YXJlLnB1c2goXG4gICAgICAoMCwgaW1wb3J0X21pZGRsZXdhcmUuZG93bmxvYWRSZXF1ZXN0TWVkaWEpKHtcbiAgICAgICAgbWF4Qnl0ZXM6IDEwMjQgKiAxMDI0ICogMTAsXG4gICAgICAgIC8vIGRvbid0IGRvd25sYW9kIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHVzaW5nIHRoZSBGaWxlcyBBUElcbiAgICAgICAgZmlsdGVyOiAocGFydCkgPT4gIXBhcnQubWVkaWEudXJsLnN0YXJ0c1dpdGgoXG4gICAgICAgICAgXCJodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9cIlxuICAgICAgICApXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfbW9kZWwuZGVmaW5lTW9kZWwpKFxuICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgbmFtZTogbW9kZWxOYW1lXG4gICAgfSwgbW9kZWwuaW5mbyksIHtcbiAgICAgIGNvbmZpZ1NjaGVtYTogbW9kZWwuY29uZmlnU2NoZW1hLFxuICAgICAgdXNlOiBtaWRkbGV3YXJlXG4gICAgfSksXG4gICAgKHJlcXVlc3QsIHN0cmVhbWluZ0NhbGxiYWNrKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yLCBfcztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFwaUNsaWVudDogaW1wb3J0X2NvcmUuR0VOS0lUX0NMSUVOVF9IRUFERVIgfTtcbiAgICAgIGlmIChhcGlWZXJzaW9uKSB7XG4gICAgICAgIG9wdGlvbnMuYXBpVmVyc2lvbiA9IGFwaVZlcnNpb247XG4gICAgICB9XG4gICAgICBpZiAoYXBpVmVyc2lvbikge1xuICAgICAgICBvcHRpb25zLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGltcG9ydF9nZW5lcmF0aXZlX2FpLkdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpLmdldEdlbmVyYXRpdmVNb2RlbChcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiAoKF9hMiA9IHJlcXVlc3QuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnZlcnNpb24pIHx8IG1vZGVsLnZlcnNpb24gfHwgbmFtZVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBbLi4ucmVxdWVzdC5tZXNzYWdlc107XG4gICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBwcm92aWRlZC5cIik7XG4gICAgICBsZXQgc3lzdGVtSW5zdHJ1Y3Rpb24gPSB2b2lkIDA7XG4gICAgICBpZiAoU1VQUE9SVEVEX1YxNV9NT0RFTFNbbmFtZV0pIHtcbiAgICAgICAgY29uc3Qgc3lzdGVtTWVzc2FnZSA9IG1lc3NhZ2VzLmZpbmQoKG0pID0+IG0ucm9sZSA9PT0gXCJzeXN0ZW1cIik7XG4gICAgICAgIGlmIChzeXN0ZW1NZXNzYWdlKSB7XG4gICAgICAgICAgbWVzc2FnZXMuc3BsaWNlKG1lc3NhZ2VzLmluZGV4T2Yoc3lzdGVtTWVzc2FnZSksIDEpO1xuICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uID0gdG9HZW1pbmlTeXN0ZW1JbnN0cnVjdGlvbihzeXN0ZW1NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9vbHMgPSBbXTtcbiAgICAgIGlmICgoX2IyID0gcmVxdWVzdC50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5sZW5ndGgpIHtcbiAgICAgICAgdG9vbHMucHVzaCh7XG4gICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IHJlcXVlc3QudG9vbHMubWFwKHRvR2VtaW5pVG9vbClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoKF9jID0gcmVxdWVzdC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jb2RlRXhlY3V0aW9uKSB7XG4gICAgICAgIHRvb2xzLnB1c2goe1xuICAgICAgICAgIGNvZGVFeGVjdXRpb246IHJlcXVlc3QuY29uZmlnLmNvZGVFeGVjdXRpb24gPT09IHRydWUgPyB7fSA6IHJlcXVlc3QuY29uZmlnLmNvZGVFeGVjdXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBqc29uTW9kZSA9ICgoKF9kID0gcmVxdWVzdC5vdXRwdXQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5mb3JtYXQpID09PSBcImpzb25cIiB8fCAhISgoX2UgPSByZXF1ZXN0Lm91dHB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnNjaGVtYSkpICYmIHRvb2xzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWcgPSB7XG4gICAgICAgIGNhbmRpZGF0ZUNvdW50OiByZXF1ZXN0LmNhbmRpZGF0ZXMgfHwgdm9pZCAwLFxuICAgICAgICB0ZW1wZXJhdHVyZTogKF9mID0gcmVxdWVzdC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfZi50ZW1wZXJhdHVyZSxcbiAgICAgICAgbWF4T3V0cHV0VG9rZW5zOiAoX2cgPSByZXF1ZXN0LmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgdG9wSzogKF9oID0gcmVxdWVzdC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfaC50b3BLLFxuICAgICAgICB0b3BQOiAoX2kgPSByZXF1ZXN0LmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLnRvcFAsXG4gICAgICAgIHN0b3BTZXF1ZW5jZXM6IChfaiA9IHJlcXVlc3QuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2ouc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgcmVzcG9uc2VNaW1lVHlwZToganNvbk1vZGUgPyBcImFwcGxpY2F0aW9uL2pzb25cIiA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbixcbiAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZyxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIGhpc3Rvcnk6IG1lc3NhZ2VzLnNsaWNlKDAsIC0xKS5tYXAoKG1lc3NhZ2UpID0+IHRvR2VtaW5pTWVzc2FnZShtZXNzYWdlLCBtb2RlbCkpLFxuICAgICAgICBzYWZldHlTZXR0aW5nczogKF9rID0gcmVxdWVzdC5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfay5zYWZldHlTZXR0aW5nc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1zZyA9IHRvR2VtaW5pTWVzc2FnZShtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXSwgbW9kZWwpO1xuICAgICAgY29uc3QgZnJvbUpTT05Nb2RlU2NvcGVkR2VtaW5pQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZnJvbUdlbWluaUNhbmRpZGF0ZShjYW5kaWRhdGUsIGpzb25Nb2RlKTtcbiAgICAgIH07XG4gICAgICBpZiAoc3RyZWFtaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgY2xpZW50LnN0YXJ0Q2hhdChjaGF0UmVxdWVzdCkuc2VuZE1lc3NhZ2VTdHJlYW0obXNnLnBhcnRzLCBvcHRpb25zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBpdGVyID0gX19mb3JBd2FpdChyZXN1bHQuc3RyZWFtKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSB5aWVsZCBpdGVyLm5leHQoKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIChfbCA9IGl0ZW0uY2FuZGlkYXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sLmZvckVhY2goKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjID0gZnJvbUpTT05Nb2RlU2NvcGVkR2VtaW5pQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgIHN0cmVhbWluZ0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBpbmRleDogYy5pbmRleCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjLm1lc3NhZ2UuY29udGVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodGVtcCkge1xuICAgICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmICh5aWVsZCB0ZW1wLmNhbGwoaXRlcikpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHRocm93IGVycm9yWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlc3VsdC5yZXNwb25zZTtcbiAgICAgICAgaWYgKCEoKF9tID0gcmVzcG9uc2UuY2FuZGlkYXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tLmxlbmd0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCBjYW5kaWRhdGVzIHJldHVybmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZXM6ICgoX24gPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX24ubWFwKGZyb21KU09OTW9kZVNjb3BlZEdlbWluaUNhbmRpZGF0ZSkpIHx8IFtdLFxuICAgICAgICAgIGN1c3RvbTogcmVzcG9uc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNsaWVudC5zdGFydENoYXQoY2hhdFJlcXVlc3QpLnNlbmRNZXNzYWdlKG1zZy5wYXJ0cywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghKChfbyA9IHJlc3VsdC5yZXNwb25zZS5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX28ubGVuZ3RoKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCBjYW5kaWRhdGVzIHJldHVybmVkLlwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VDYW5kaWRhdGVzID0gKChfcCA9IHJlc3VsdC5yZXNwb25zZS5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3AubWFwKGZyb21KU09OTW9kZVNjb3BlZEdlbWluaUNhbmRpZGF0ZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZXM6IHJlc3BvbnNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICBjdXN0b206IHJlc3VsdC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgKDAsIGltcG9ydF9tb2RlbC5nZXRCYXNpY1VzYWdlU3RhdHMpKHJlcXVlc3QubWVzc2FnZXMsIHJlc3BvbnNlQ2FuZGlkYXRlcykpLCB7XG4gICAgICAgICAgICBpbnB1dFRva2VuczogKF9xID0gcmVzdWx0LnJlc3BvbnNlLnVzYWdlTWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfcS5wcm9tcHRUb2tlbkNvdW50LFxuICAgICAgICAgICAgb3V0cHV0VG9rZW5zOiAoX3IgPSByZXN1bHQucmVzcG9uc2UudXNhZ2VNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IChfcyA9IHJlc3VsdC5yZXNwb25zZS51c2FnZU1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3MudG90YWxUb2tlbkNvdW50XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNVUFBPUlRFRF9WMTVfTU9ERUxTLFxuICBTVVBQT1JURURfVjFfTU9ERUxTLFxuICBmcm9tR2VtaW5pQ2FuZGlkYXRlLFxuICBnZW1pbmkxNUZsYXNoLFxuICBnZW1pbmkxNUZsYXNoOEIsXG4gIGdlbWluaTE1UHJvLFxuICBnZW1pbmlQcm8sXG4gIGdlbWluaVByb1Zpc2lvbixcbiAgZ2VtaW5pVWx0cmEsXG4gIGdvb2dsZUFJTW9kZWwsXG4gIHRvR2VtaW5pTWVzc2FnZSxcbiAgdG9HZW1pbmlTeXN0ZW1JbnN0cnVjdGlvblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW1pbmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/googleai/lib/gemini.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/chunk-7OAPEGJQ.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/chunk-7OAPEGJQ.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __async: () => (/* binding */ __async),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __spreadProps: () => (/* binding */ __spreadProps),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => {\n  return (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  };\n  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));\n  var it = {};\n  return generator = generator.apply(__this, __arguments), it[__knownSymbol(\"asyncIterator\")] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\n\n\n//# sourceMappingURL=chunk-7OAPEGJQ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9jaHVuay03T0FQRUdKUS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsK0JBQStCLHNCQUFzQixnQkFBZ0I7QUFDbEwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9haS9saWIvY2h1bmstN09BUEVHSlEubWpzP2VmYTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19rbm93blN5bWJvbCA9IChuYW1lLCBzeW1ib2wpID0+IHtcbiAgcmV0dXJuIChzeW1ib2wgPSBTeW1ib2xbbmFtZV0pID8gc3ltYm9sIDogU3ltYm9sLmZvcihcIlN5bWJvbC5cIiArIG5hbWUpO1xufTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19hd2FpdCA9IGZ1bmN0aW9uKHByb21pc2UsIGlzWWllbGRTdGFyKSB7XG4gIHRoaXNbMF0gPSBwcm9taXNlO1xuICB0aGlzWzFdID0gaXNZaWVsZFN0YXI7XG59O1xudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHZhciByZXN1bWUgPSAoaywgdiwgeWVzLCBubykgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgeCA9IGdlbmVyYXRvcltrXSh2KSwgaXNBd2FpdCA9ICh2ID0geC52YWx1ZSkgaW5zdGFuY2VvZiBfX2F3YWl0LCBkb25lID0geC5kb25lO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGlzQXdhaXQgPyB2WzBdIDogdikudGhlbigoeSkgPT4gaXNBd2FpdCA/IHJlc3VtZShrID09PSBcInJldHVyblwiID8gayA6IFwibmV4dFwiLCB2WzFdID8geyBkb25lOiB5LmRvbmUsIHZhbHVlOiB5LnZhbHVlIH0gOiB5LCB5ZXMsIG5vKSA6IHllcyh7IHZhbHVlOiB5LCBkb25lIH0pKS5jYXRjaCgoZSkgPT4gcmVzdW1lKFwidGhyb3dcIiwgZSwgeWVzLCBubykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5vKGUpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG1ldGhvZCA9IChrKSA9PiBpdFtrXSA9ICh4KSA9PiBuZXcgUHJvbWlzZSgoeWVzLCBubykgPT4gcmVzdW1lKGssIHgsIHllcywgbm8pKTtcbiAgdmFyIGl0ID0ge307XG4gIHJldHVybiBnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cyksIGl0W19fa25vd25TeW1ib2woXCJhc3luY0l0ZXJhdG9yXCIpXSA9ICgpID0+IGl0LCBtZXRob2QoXCJuZXh0XCIpLCBtZXRob2QoXCJ0aHJvd1wiKSwgbWV0aG9kKFwicmV0dXJuXCIpLCBpdDtcbn07XG5cbmV4cG9ydCB7XG4gIF9fc3ByZWFkVmFsdWVzLFxuICBfX3NwcmVhZFByb3BzLFxuICBfX2FzeW5jLFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstN09BUEVHSlEubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/chunk-7OAPEGJQ.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/ai/lib/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@genkit-ai/ai/lib/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Candidate: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.Candidate),\n/* harmony export */   GenerateRequest: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.GenerateRequest),\n/* harmony export */   GenerateRequestData: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.GenerateRequestData),\n/* harmony export */   GenerateResponse: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.GenerateResponse),\n/* harmony export */   GenerateResponseData: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.GenerateResponseData),\n/* harmony export */   GenerationUsage: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.GenerationUsage),\n/* harmony export */   MediaPart: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.MediaPart),\n/* harmony export */   Message: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.Message),\n/* harmony export */   NoValidCandidatesError: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.NoValidCandidatesError),\n/* harmony export */   Part: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.Part),\n/* harmony export */   ToolRequestPart: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.ToolRequestPart),\n/* harmony export */   ToolResponsePart: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_3__.ToolResponsePart),\n/* harmony export */   asTool: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_6__.asTool),\n/* harmony export */   definePrompt: () => (/* reexport safe */ _prompt_js__WEBPACK_IMPORTED_MODULE_4__.definePrompt),\n/* harmony export */   defineTool: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_6__.defineTool),\n/* harmony export */   evaluate: () => (/* reexport safe */ _evaluator_js__WEBPACK_IMPORTED_MODULE_1__.evaluate),\n/* harmony export */   evaluatorRef: () => (/* reexport safe */ _evaluator_js__WEBPACK_IMPORTED_MODULE_1__.evaluatorRef),\n/* harmony export */   generate: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.generate),\n/* harmony export */   generateStream: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.generateStream),\n/* harmony export */   index: () => (/* reexport safe */ _retriever_js__WEBPACK_IMPORTED_MODULE_5__.index),\n/* harmony export */   indexerRef: () => (/* reexport safe */ _retriever_js__WEBPACK_IMPORTED_MODULE_5__.indexerRef),\n/* harmony export */   renderPrompt: () => (/* reexport safe */ _prompt_js__WEBPACK_IMPORTED_MODULE_4__.renderPrompt),\n/* harmony export */   retrieve: () => (/* reexport safe */ _retriever_js__WEBPACK_IMPORTED_MODULE_5__.retrieve),\n/* harmony export */   retrieverRef: () => (/* reexport safe */ _retriever_js__WEBPACK_IMPORTED_MODULE_5__.retrieverRef),\n/* harmony export */   toGenerateRequest: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_2__.toGenerateRequest)\n/* harmony export */ });\n/* harmony import */ var _chunk_7OAPEGJQ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7OAPEGJQ.mjs */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/chunk-7OAPEGJQ.mjs\");\n/* harmony import */ var _evaluator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./evaluator.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/evaluator.js\");\n/* harmony import */ var _generate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generate.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/generate.js\");\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/model.js\");\n/* harmony import */ var _prompt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prompt.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/prompt.js\");\n/* harmony import */ var _retriever_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./retriever.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/retriever.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/tool.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/@genkit-ai/ai/lib/types.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types_js__WEBPACK_IMPORTED_MODULE_7__) if([\"default\",\"Candidate\",\"GenerateRequest\",\"GenerateRequestData\",\"GenerateResponse\",\"GenerateResponseData\",\"GenerationUsage\",\"MediaPart\",\"Message\",\"NoValidCandidatesError\",\"Part\",\"ToolRequestPart\",\"ToolResponsePart\",\"asTool\",\"definePrompt\",\"defineTool\",\"evaluate\",\"evaluatorRef\",\"generate\",\"generateStream\",\"index\",\"indexerRef\",\"renderPrompt\",\"retrieve\",\"retrieverRef\",\"toGenerateRequest\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types_js__WEBPACK_IMPORTED_MODULE_7__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2FpL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBSU47QUFTRDtBQVVIO0FBQ3FDO0FBTWpDO0FBQ3VCO0FBQ3BCO0FBMkJ6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvYWkvbGliL2luZGV4Lm1qcz85ZWVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vY2h1bmstN09BUEVHSlEubWpzXCI7XG5pbXBvcnQge1xuICBldmFsdWF0ZSxcbiAgZXZhbHVhdG9yUmVmXG59IGZyb20gXCIuL2V2YWx1YXRvci5qc1wiO1xuaW1wb3J0IHtcbiAgQ2FuZGlkYXRlLFxuICBHZW5lcmF0ZVJlc3BvbnNlLFxuICBNZXNzYWdlLFxuICBOb1ZhbGlkQ2FuZGlkYXRlc0Vycm9yLFxuICBnZW5lcmF0ZSxcbiAgZ2VuZXJhdGVTdHJlYW0sXG4gIHRvR2VuZXJhdGVSZXF1ZXN0XG59IGZyb20gXCIuL2dlbmVyYXRlLmpzXCI7XG5pbXBvcnQge1xuICBHZW5lcmF0ZVJlcXVlc3QsXG4gIEdlbmVyYXRlUmVxdWVzdERhdGEsXG4gIEdlbmVyYXRlUmVzcG9uc2VEYXRhLFxuICBHZW5lcmF0aW9uVXNhZ2UsXG4gIE1lZGlhUGFydCxcbiAgUGFydCxcbiAgVG9vbFJlcXVlc3RQYXJ0LFxuICBUb29sUmVzcG9uc2VQYXJ0XG59IGZyb20gXCIuL21vZGVsLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9tcHQsIHJlbmRlclByb21wdCB9IGZyb20gXCIuL3Byb21wdC5qc1wiO1xuaW1wb3J0IHtcbiAgaW5kZXgsXG4gIGluZGV4ZXJSZWYsXG4gIHJldHJpZXZlLFxuICByZXRyaWV2ZXJSZWZcbn0gZnJvbSBcIi4vcmV0cmlldmVyLmpzXCI7XG5pbXBvcnQgeyBhc1Rvb2wsIGRlZmluZVRvb2wgfSBmcm9tIFwiLi90b29sLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuZXhwb3J0IHtcbiAgQ2FuZGlkYXRlLFxuICBHZW5lcmF0ZVJlcXVlc3QsXG4gIEdlbmVyYXRlUmVxdWVzdERhdGEsXG4gIEdlbmVyYXRlUmVzcG9uc2UsXG4gIEdlbmVyYXRlUmVzcG9uc2VEYXRhLFxuICBHZW5lcmF0aW9uVXNhZ2UsXG4gIE1lZGlhUGFydCxcbiAgTWVzc2FnZSxcbiAgTm9WYWxpZENhbmRpZGF0ZXNFcnJvcixcbiAgUGFydCxcbiAgVG9vbFJlcXVlc3RQYXJ0LFxuICBUb29sUmVzcG9uc2VQYXJ0LFxuICBhc1Rvb2wsXG4gIGRlZmluZVByb21wdCxcbiAgZGVmaW5lVG9vbCxcbiAgZXZhbHVhdGUsXG4gIGV2YWx1YXRvclJlZixcbiAgZ2VuZXJhdGUsXG4gIGdlbmVyYXRlU3RyZWFtLFxuICBpbmRleCxcbiAgaW5kZXhlclJlZixcbiAgcmVuZGVyUHJvbXB0LFxuICByZXRyaWV2ZSxcbiAgcmV0cmlldmVyUmVmLFxuICB0b0dlbmVyYXRlUmVxdWVzdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/ai/lib/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/chunk-XEFTB2OF.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/chunk-XEFTB2OF.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __async: () => (/* binding */ __async),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\n//# sourceMappingURL=chunk-XEFTB2OF.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2NodW5rLVhFRlRCMk9GLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi9jaHVuay1YRUZUQjJPRi5tanM/Y2RhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG5leHBvcnQge1xuICBfX3NwcmVhZFZhbHVlcyxcbiAgX19hc3luY1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVhFRlRCMk9GLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/chunk-XEFTB2OF.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/core/lib/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@genkit-ai/core/lib/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GENKIT_CLIENT_HEADER: () => (/* binding */ GENKIT_CLIENT_HEADER),\n/* harmony export */   GENKIT_VERSION: () => (/* binding */ GENKIT_VERSION),\n/* harmony export */   GenkitError: () => (/* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_4__.GenkitError),\n/* harmony export */   defineJsonSchema: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.defineJsonSchema),\n/* harmony export */   defineSchema: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.defineSchema)\n/* harmony export */ });\n/* harmony import */ var _chunk_XEFTB2OF_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-XEFTB2OF.mjs */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/chunk-XEFTB2OF.mjs\");\n/* harmony import */ var _codegen_version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./__codegen/version.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/__codegen/version.js\");\n/* harmony import */ var _action_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./action.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/action.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _action_js__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"GENKIT_CLIENT_HEADER\",\"GENKIT_VERSION\",\"GenkitError\",\"defineJsonSchema\",\"defineSchema\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _action_js__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/config.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _config_js__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"GENKIT_CLIENT_HEADER\",\"GENKIT_VERSION\",\"GenkitError\",\"defineJsonSchema\",\"defineSchema\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _config_js__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./error.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/error.js\");\n/* harmony import */ var _flowTypes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flowTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/flowTypes.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _flowTypes_js__WEBPACK_IMPORTED_MODULE_5__) if([\"default\",\"GENKIT_CLIENT_HEADER\",\"GENKIT_VERSION\",\"GenkitError\",\"defineJsonSchema\",\"defineSchema\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _flowTypes_js__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schema.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/schema.js\");\n/* harmony import */ var _telemetryTypes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./telemetryTypes.js */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/telemetryTypes.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _telemetryTypes_js__WEBPACK_IMPORTED_MODULE_7__) if([\"default\",\"GENKIT_CLIENT_HEADER\",\"GENKIT_VERSION\",\"GenkitError\",\"defineJsonSchema\",\"defineSchema\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _telemetryTypes_js__WEBPACK_IMPORTED_MODULE_7__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\nconst GENKIT_VERSION = _codegen_version_js__WEBPACK_IMPORTED_MODULE_1__.version;\nconst GENKIT_CLIENT_HEADER = `genkit-node/${GENKIT_VERSION} gl-node/${process.versions.node}`;\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2NvcmUvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ21CO0FBQ2pELHVCQUF1Qix3REFBTztBQUM5Qiw0Q0FBNEMsZ0JBQWdCLFVBQVUsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDYTtBQUNWO0FBQzhCO0FBQ3pCO0FBT2xDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hc3RlcnkzNjAvLi9ub2RlX21vZHVsZXMvQGdlbmtpdC1haS9jb3JlL2xpYi9pbmRleC5tanM/NGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuL2NodW5rLVhFRlRCMk9GLm1qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL19fY29kZWdlbi92ZXJzaW9uLmpzXCI7XG5jb25zdCBHRU5LSVRfVkVSU0lPTiA9IHZlcnNpb247XG5jb25zdCBHRU5LSVRfQ0xJRU5UX0hFQURFUiA9IGBnZW5raXQtbm9kZS8ke0dFTktJVF9WRVJTSU9OfSBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfWA7XG5leHBvcnQgKiBmcm9tIFwiLi9hY3Rpb24uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgR2Vua2l0RXJyb3IgfSBmcm9tIFwiLi9lcnJvci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZmxvd1R5cGVzLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVKc29uU2NoZW1hLCBkZWZpbmVTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWEuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbGVtZXRyeVR5cGVzLmpzXCI7XG5leHBvcnQge1xuICBHRU5LSVRfQ0xJRU5UX0hFQURFUixcbiAgR0VOS0lUX1ZFUlNJT04sXG4gIEdlbmtpdEVycm9yLFxuICBkZWZpbmVKc29uU2NoZW1hLFxuICBkZWZpbmVTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/core/lib/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/googleai/lib/chunk-WFI2LP4G.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@genkit-ai/googleai/lib/chunk-WFI2LP4G.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __async: () => (/* binding */ __async),\n/* harmony export */   __forAwait: () => (/* binding */ __forAwait),\n/* harmony export */   __spreadProps: () => (/* binding */ __spreadProps),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => {\n  return (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar __forAwait = (obj, it, method) => (it = obj[__knownSymbol(\"asyncIterator\")]) ? it.call(obj) : (obj = obj[__knownSymbol(\"iterator\")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method(\"next\"), method(\"return\"), it);\n\n\n//# sourceMappingURL=chunk-WFI2LP4G.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZWFpL2xpYi9jaHVuay1XRkkyTFA0Ry5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0pBQWtKLDBMQUEwTCxhQUFhOztBQU92VjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvZ29vZ2xlYWkvbGliL2NodW5rLVdGSTJMUDRHLm1qcz9hNGJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fa25vd25TeW1ib2wgPSAobmFtZSwgc3ltYm9sKSA9PiB7XG4gIHJldHVybiAoc3ltYm9sID0gU3ltYm9sW25hbWVdKSA/IHN5bWJvbCA6IFN5bWJvbC5mb3IoXCJTeW1ib2wuXCIgKyBuYW1lKTtcbn07XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fZm9yQXdhaXQgPSAob2JqLCBpdCwgbWV0aG9kKSA9PiAoaXQgPSBvYmpbX19rbm93blN5bWJvbChcImFzeW5jSXRlcmF0b3JcIildKSA/IGl0LmNhbGwob2JqKSA6IChvYmogPSBvYmpbX19rbm93blN5bWJvbChcIml0ZXJhdG9yXCIpXSgpLCBpdCA9IHt9LCBtZXRob2QgPSAoa2V5LCBmbikgPT4gKGZuID0gb2JqW2tleV0pICYmIChpdFtrZXldID0gKGFyZykgPT4gbmV3IFByb21pc2UoKHllcywgbm8sIGRvbmUpID0+IChhcmcgPSBmbi5jYWxsKG9iaiwgYXJnKSwgZG9uZSA9IGFyZy5kb25lLCBQcm9taXNlLnJlc29sdmUoYXJnLnZhbHVlKS50aGVuKCh2YWx1ZSkgPT4geWVzKHsgdmFsdWUsIGRvbmUgfSksIG5vKSkpKSwgbWV0aG9kKFwibmV4dFwiKSwgbWV0aG9kKFwicmV0dXJuXCIpLCBpdCk7XG5cbmV4cG9ydCB7XG4gIF9fc3ByZWFkVmFsdWVzLFxuICBfX3NwcmVhZFByb3BzLFxuICBfX2FzeW5jLFxuICBfX2ZvckF3YWl0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstV0ZJMkxQNEcubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/googleai/lib/chunk-WFI2LP4G.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@genkit-ai/googleai/lib/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@genkit-ai/googleai/lib/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   gemini15Flash: () => (/* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.gemini15Flash),\n/* harmony export */   gemini15Flash8B: () => (/* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.gemini15Flash8B),\n/* harmony export */   gemini15Pro: () => (/* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.gemini15Pro),\n/* harmony export */   geminiPro: () => (/* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.geminiPro),\n/* harmony export */   geminiProVision: () => (/* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.geminiProVision),\n/* harmony export */   googleAI: () => (/* binding */ googleAI),\n/* harmony export */   textEmbeddingGecko001: () => (/* reexport safe */ _embedder_js__WEBPACK_IMPORTED_MODULE_2__.textEmbeddingGecko001)\n/* harmony export */ });\n/* harmony import */ var _chunk_WFI2LP4G_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-WFI2LP4G.mjs */ \"(action-browser)/./node_modules/@genkit-ai/googleai/lib/chunk-WFI2LP4G.mjs\");\n/* harmony import */ var _genkit_ai_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @genkit-ai/core */ \"(action-browser)/./node_modules/@genkit-ai/core/lib/index.mjs\");\n/* harmony import */ var _embedder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./embedder.js */ \"(action-browser)/./node_modules/@genkit-ai/googleai/lib/embedder.js\");\n/* harmony import */ var _gemini_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gemini.js */ \"(action-browser)/./node_modules/@genkit-ai/googleai/lib/gemini.js\");\n\n\n\n\nconst googleAI = (0,_genkit_ai_core__WEBPACK_IMPORTED_MODULE_1__.genkitPlugin)(\n  \"googleai\",\n  (options) => (0,_chunk_WFI2LP4G_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(void 0, null, function* () {\n    let models;\n    let embedders;\n    let apiVersions = [\"v1\"];\n    if (options == null ? void 0 : options.apiVersion) {\n      if (Array.isArray(options == null ? void 0 : options.apiVersion)) {\n        apiVersions = options == null ? void 0 : options.apiVersion;\n      } else {\n        apiVersions = [options == null ? void 0 : options.apiVersion];\n      }\n    }\n    if (apiVersions.includes(\"v1beta\")) {\n      embedders = [], models = [\n        ...Object.keys(_gemini_js__WEBPACK_IMPORTED_MODULE_3__.SUPPORTED_V15_MODELS).map(\n          (name) => (0,_gemini_js__WEBPACK_IMPORTED_MODULE_3__.googleAIModel)(name, options == null ? void 0 : options.apiKey, \"v1beta\", options == null ? void 0 : options.baseUrl)\n        )\n      ];\n    }\n    if (apiVersions.includes(\"v1\")) {\n      models = [\n        ...Object.keys(_gemini_js__WEBPACK_IMPORTED_MODULE_3__.SUPPORTED_V1_MODELS).map(\n          (name) => (0,_gemini_js__WEBPACK_IMPORTED_MODULE_3__.googleAIModel)(name, options == null ? void 0 : options.apiKey, void 0, options == null ? void 0 : options.baseUrl)\n        ),\n        ...Object.keys(_gemini_js__WEBPACK_IMPORTED_MODULE_3__.SUPPORTED_V15_MODELS).map(\n          (name) => (0,_gemini_js__WEBPACK_IMPORTED_MODULE_3__.googleAIModel)(name, options == null ? void 0 : options.apiKey, void 0, options == null ? void 0 : options.baseUrl)\n        )\n      ];\n      embedders = [\n        ...Object.keys(_embedder_js__WEBPACK_IMPORTED_MODULE_2__.SUPPORTED_MODELS).map(\n          (name) => (0,_embedder_js__WEBPACK_IMPORTED_MODULE_2__.textEmbeddingGeckoEmbedder)(name, { apiKey: options == null ? void 0 : options.apiKey })\n        )\n      ];\n    }\n    return {\n      models,\n      embedders\n    };\n  })\n);\nvar src_default = googleAI;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2Vua2l0LWFpL2dvb2dsZWFpL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRThCO0FBQ2lCO0FBS3hCO0FBVUY7QUFDckIsaUJBQWlCLDZEQUFZO0FBQzdCO0FBQ0EsZUFBZSw0REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBb0I7QUFDM0Msb0JBQW9CLHlEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkRBQW1CO0FBQzFDLG9CQUFvQix5REFBYTtBQUNqQztBQUNBLHVCQUF1Qiw0REFBb0I7QUFDM0Msb0JBQW9CLHlEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBZTtBQUN0QyxvQkFBb0Isd0VBQTBCLFNBQVMsbURBQW1EO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uYXN0ZXJ5MzYwLy4vbm9kZV9tb2R1bGVzL0BnZW5raXQtYWkvZ29vZ2xlYWkvbGliL2luZGV4Lm1qcz81ZjIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIF9fYXN5bmNcbn0gZnJvbSBcIi4vY2h1bmstV0ZJMkxQNEcubWpzXCI7XG5pbXBvcnQgeyBnZW5raXRQbHVnaW4gfSBmcm9tIFwiQGdlbmtpdC1haS9jb3JlXCI7XG5pbXBvcnQge1xuICBTVVBQT1JURURfTU9ERUxTIGFzIEVNQkVEREVSX01PREVMUyxcbiAgdGV4dEVtYmVkZGluZ0dlY2tvMDAxLFxuICB0ZXh0RW1iZWRkaW5nR2Vja29FbWJlZGRlclxufSBmcm9tIFwiLi9lbWJlZGRlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ2VtaW5pMTVGbGFzaCxcbiAgZ2VtaW5pMTVGbGFzaDhCLFxuICBnZW1pbmkxNVBybyxcbiAgZ2VtaW5pUHJvLFxuICBnZW1pbmlQcm9WaXNpb24sXG4gIGdvb2dsZUFJTW9kZWwsXG4gIFNVUFBPUlRFRF9WMTVfTU9ERUxTLFxuICBTVVBQT1JURURfVjFfTU9ERUxTXG59IGZyb20gXCIuL2dlbWluaS5qc1wiO1xuY29uc3QgZ29vZ2xlQUkgPSBnZW5raXRQbHVnaW4oXG4gIFwiZ29vZ2xlYWlcIixcbiAgKG9wdGlvbnMpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGxldCBtb2RlbHM7XG4gICAgbGV0IGVtYmVkZGVycztcbiAgICBsZXQgYXBpVmVyc2lvbnMgPSBbXCJ2MVwiXTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hcGlWZXJzaW9uKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFwaVZlcnNpb24pKSB7XG4gICAgICAgIGFwaVZlcnNpb25zID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBpVmVyc2lvbnMgPSBbb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hcGlWZXJzaW9uXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwaVZlcnNpb25zLmluY2x1ZGVzKFwidjFiZXRhXCIpKSB7XG4gICAgICBlbWJlZGRlcnMgPSBbXSwgbW9kZWxzID0gW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhTVVBQT1JURURfVjE1X01PREVMUykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiBnb29nbGVBSU1vZGVsKG5hbWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBpS2V5LCBcInYxYmV0YVwiLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVcmwpXG4gICAgICAgIClcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChhcGlWZXJzaW9ucy5pbmNsdWRlcyhcInYxXCIpKSB7XG4gICAgICBtb2RlbHMgPSBbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKFNVUFBPUlRFRF9WMV9NT0RFTFMpLm1hcChcbiAgICAgICAgICAobmFtZSkgPT4gZ29vZ2xlQUlNb2RlbChuYW1lLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFwaUtleSwgdm9pZCAwLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVcmwpXG4gICAgICAgICksXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKFNVUFBPUlRFRF9WMTVfTU9ERUxTKS5tYXAoXG4gICAgICAgICAgKG5hbWUpID0+IGdvb2dsZUFJTW9kZWwobmFtZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hcGlLZXksIHZvaWQgMCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5iYXNlVXJsKVxuICAgICAgICApXG4gICAgICBdO1xuICAgICAgZW1iZWRkZXJzID0gW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhFTUJFRERFUl9NT0RFTFMpLm1hcChcbiAgICAgICAgICAobmFtZSkgPT4gdGV4dEVtYmVkZGluZ0dlY2tvRW1iZWRkZXIobmFtZSwgeyBhcGlLZXk6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBpS2V5IH0pXG4gICAgICAgIClcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RlbHMsXG4gICAgICBlbWJlZGRlcnNcbiAgICB9O1xuICB9KVxuKTtcbnZhciBzcmNfZGVmYXVsdCA9IGdvb2dsZUFJO1xuZXhwb3J0IHtcbiAgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2VtaW5pMTVGbGFzaCxcbiAgZ2VtaW5pMTVGbGFzaDhCLFxuICBnZW1pbmkxNVBybyxcbiAgZ2VtaW5pUHJvLFxuICBnZW1pbmlQcm9WaXNpb24sXG4gIGdvb2dsZUFJLFxuICB0ZXh0RW1iZWRkaW5nR2Vja28wMDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@genkit-ai/googleai/lib/index.mjs\n");

/***/ })

};
;